/*
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡦⡦⡦⡦⡦⡦⡦⡦⡦⡦⡦⡦⡦⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣄⣄⣿⣯⣯⣯⣯⣯⣯⣯⣯⣫⣯⣯⣯⣇⢠⢠⠀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣯⣯⣧⣧⣫⣧⣧⣫⣧⣧⣧⣧⣧⣫⣫⣇⢂⢂⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣯⣯⣧⣧⣧⣫⣫⣫⢪⢪⢪⢪⢪⢪⢪⢪⢪⢪⢪⢪⢪⢂⢊⢊⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡿⣯⣯⣧⣧⣧⣫⣫⢇⢪⢪⣧⣧⣧⣧⣧⣣⣧⣧⣧⣧⣧⣪⣣⣇⢪⢪⢪⢪⠃⠀⠀⢀⢀⢀⢀⢀⠀⠀⠀⢀⢀⢀⢀⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡿⣯⣯⣧⣫⢺⣾⣾⣆⢪⣧⢪⢪⢺⣾⣾⣾⣾⣾⣾⣾⣧⢪⢪⣧⣧⣧⢪⢪⣇⢢⢢⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⡤⡤⡿⣯⣯⣧⣧⣾⢛⢛⢣⢪⢪⣦⣦⣾⣿⣿⣿⣿⣿⣿⣿⣯⣦⣦⣎⢪⢪⣧⣧⣇⢊⢊⢀⢀⢀⢀⢀⢀⠀⠀⠀⠀⠀⢀⢀⢀⢀⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣯⣯⣯⣯⣯⣿⣿⣧⢪⢪⢪⢪⢪⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⣎⣎⢪⢪⣇⣠⣠⣀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⠀⠀⢀⢀⢀⢀⢀⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣯⣯⣯⣯⣯⣿⣿⣧⢪⢪⢪⢪⢪⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢪⢪⢪⢪⢪⢂⢂⢊⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣯⣯⣯⣯⣯⣿⣿⣧⢪⢪⢪⢪⢪⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢪⢪⢪⢪⢪⢪⢪⢪⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢂⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣯⣯⣯⣯⣯⢪⢪⢺⣿⣿⣇⢪⢪⢊⢊⢪⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢪⢪⢪⢪⢪⢀⢀⢀⢀⢀⢸⣿⣿⣅⢀⢀⢂⢂⢂⢀⢀⣿⣿⣿⢀⢀⢂⢐⢐⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠉⡯⣯⣯⣧⣧⣎⢫⢫⢣⣧⣧⢪⢪⢪⢋⢋⢋⢋⢋⢋⢋⢋⢋⢋⢋⢋⢋⢪⢪⢪⢪⢪⢀⢀⢀⢀⢀⢈⢉⢉⢀⢀⢀⢀⢀⢀⢀⢀⢉⢉⢉⢀⢀⢂⢀⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠋⠛⠛⣯⣯⣧⣧⣧⣧⣧⣧⣧⣧⣎⢪⢪⢪⢪⢪⣧⣧⣧⣧⣧⣎⢪⢪⢪⢪⢪⢪⢪⣤⣤⣤⣤⣤⣄⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⣤⣤⣤⣤⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠿⠯⠯⠯⠯⣿⣯⣯⣧⣫⣧⢪⢪⢪⢪⢪⠿⠿⢿⢯⢯⣇⣪⣪⣪⣪⣪⣪⣪⠿⠿⠿⢿⢯⢇⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⢯⢯⠿⠿⠿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡯⣯⣯⣫⣫⣧⢪⢪⢪⢪⢪⢀⢀⢨⢪⢪⣯⣯⣯⣯⣯⣯⣯⣯⠀⢀⢀⢀⢀⢸⣯⣯⣯⣯⣯⣯⣯⣯⣯⣯⣯⣯⣯⢀⢀⢂⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠨⣯⣯⣧⣧⣫⢪⢪⢪⢪⢪⢪⢪⢪⢪⢪⢪⢪⢪⠀⠀⠀⠀⠀⢨⢪⢪⢂⢀⢀⢀⢀⢀⢀⢀⠀⠀⠀⢀⢀⢀⠀⠀⢨⢀⢀⢀⢀⢨⢪⢪⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣯⣿⣿⣿⣯⣯⣯⣯⣯⣯⢪⢪⢪⢪⢪⣧⣧⣧⢀⢀⢸⢪⢪⢀⢀⢀⢀⢀⢀⢀⢀⢢⢢⢢⢀⢀⢂⢢⢢⢪⢀⢀⢀⢀⢨⢪⢪⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠉⠉⠉⠉⢩⣧⣧⣧⣧⣧⣧⣧⣧⣧⣧⣆⢪⢪⣦⣦⣎⢪⢪⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢸⣧⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⠛⠛⠛⠛⠛⣧⣧⣧⣧⣧⣧⣧⣧⣧⣧⣧⣧⣧⣄⣠⣠⣠⣠⣠⣠⣠⣠⣠⣠⣠⣠⣠⣠⣠⣠⣠⣠⣠⣠⣸⣧⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣯⣯⣿⣯⣯⣯⣯⣯⣯⣯⣯⣯⣯⣇⣊⣊⣊⣊⣣⣊⣊⣊⣣⣊⣊⣊⣊⣊⣊⣣⣊⣊⣊⣊⣪⣯⣯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⣯⣯⣯⣯⣯⣯⣯⣯⣯⣯⣯⣯⣯⣯⣯⣯⣯⣯⣯⣯⣯⣯⣯⣯⣯⣯⣯⣯⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀WARNING!⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀THIS PROPERTY IS GUARDED & PROTECTED BY REPTILIANS.⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ENTER AT YOUR OWN RISK.⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
*/

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.17;

import "./ERC721A.sol";
import "./Ownable.sol";
import "./SafeMath.sol";
import "./ReentrancyGuard.sol";
import "./Strings.sol";
import "./MerkleProof.sol";

contract ReptilianRepublic is ERC721A, Ownable, ReentrancyGuard {
    using SafeMath for uint256;
    using Strings for uint256;

    string public baseURI = "";
    string public hiddenMetadataUri;
    string public baseExtension = ".json";

    uint256 public constant maxSupply = 7777;
    uint256 public maxWhitelist = 1111;
    uint256 public price = 0.005 ether;
    uint256 public presalePrice = 0 ether;
    uint256 public maxPerWLWallet = 1;
    uint256 public maxPerWallet = 2;
    
    bytes32 public whitelistMerkleRoot;

    address public constant w1 = 0xf6444329f67d32bCeaF39fE37E3Dd21759c35F2A;

    bool public publicSaleStarted = false;
    bool public presaleStarted = false;
    bool public revealed;

    mapping(address => bool) public whitelistClaimed;
    mapping(address => uint256) private _walletMints;

    constructor(
    string memory _hiddenMetadataUri
    ) ERC721A("Reptilian Republic", "RR") {
    setHiddenMetadataUri(_hiddenMetadataUri);
    }
    
    modifier isValidMerkleProof(bytes32[] calldata merkleProof, bytes32 root) {
        require(
            MerkleProof.verify(
                merkleProof,
                root,
                keccak256(abi.encodePacked(msg.sender))
            ),
            "Address does not exist in list"
        );
        _;
    }

    modifier isCorrectPayment(uint256 numberOfTokens) {
        require(
            price * numberOfTokens == msg.value,
            "Incorrect ETH value sent"
        );
        _;
    }

    // TOGGLE START EVENT

    function togglePresaleStarted() external onlyOwner {
        presaleStarted = !presaleStarted;
    }

    function togglePublicSaleStarted() external onlyOwner {
        publicSaleStarted = !publicSaleStarted;
    }

    // SETUP MAX

    function setMaxPerWallet(uint256 _newMaxPerWallet) external onlyOwner {
        maxPerWallet = _newMaxPerWallet;
    }

    function setMaxPerWLWallet(uint256 _newMaxPerWLWallet) external onlyOwner {
        maxPerWLWallet = _newMaxPerWLWallet;
    }

    // WHITELIST MERKLE ROOT

    function setWhitelistMerkleRoot(bytes32 merkleRoot) external onlyOwner {
        whitelistMerkleRoot = merkleRoot;
    }

    // BY PASS #0 TOKEN ID

    function _startTokenId() internal pure override returns (uint256) {
        return 1;
    }

    // METADATA HANDLING
    
    function setHiddenMetadataUri(string memory _hiddenMetadataUri) public onlyOwner {
        hiddenMetadataUri = _hiddenMetadataUri;
    }
    
    function setBaseURI(string memory _newBaseURI) external onlyOwner {
        baseURI = _newBaseURI;
    }

    function _baseURI() internal view override returns (string memory) {
        return baseURI;
    }
    
    function tokenURI(uint256 _tokenId) public view virtual override returns (string memory) {
        require(_exists(_tokenId), "URI does not exist!");
    
        if (revealed) {
            return string(abi.encodePacked(_baseURI(), _tokenId.toString(), baseExtension));
        } else {
            return hiddenMetadataUri;
        }
    }
    
    function reveal() public onlyOwner {
        revealed = true;
    }

    // MINT SECTION

    function mintWhitelist(
      bytes32[] calldata merkleProof
    )
        public
        payable
        isValidMerkleProof(merkleProof, whitelistMerkleRoot)
        isCorrectPayment(presalePrice)
        nonReentrant
    {
        require(presaleStarted, "Sale has not started");
        require(maxPerWLWallet <= maxWhitelist, "Minted the maximum # of whitelist tokens");
        require(!whitelistClaimed[msg.sender], "NFT is already claimed by this wallet");
        _mint(msg.sender, maxPerWLWallet);
        maxPerWLWallet++;
        whitelistClaimed[msg.sender] = true;
    }

    function mint(uint256 tokens) external payable {
        require(publicSaleStarted, "Sale has not started");
        require(totalSupply() + tokens <= maxSupply, "Minting would exceed max supply");
        require(tokens > 0, "Must mint at least one Reptilian");
        require(_walletMints[_msgSender()] + tokens <= maxPerWallet, "Limit for this wallet reached");
        require(price * tokens <= msg.value, "Not enough ETH");

        _walletMints[_msgSender()] += tokens;
        _safeMint(_msgSender(), tokens);
    }

    // RESERVE REPTILIAN

    function reserve(uint256 tokens) external onlyOwner {
        require(totalSupply() + tokens <= maxSupply, "Minting would exceed max supply");
        require(tokens > 0, "Must mint at least one Reptilian");
        require(_walletMints[_msgSender()] + tokens <= 100, "Can only reserve 100 tokens");

        _walletMints[_msgSender()] += tokens;
        _safeMint(_msgSender(), tokens);
    }

    // WITHDRAW

    function withdrawAll() public onlyOwner {
        uint256 balance = address(this).balance;
        require(balance > 0, "Insufficent balance");
        _withdraw(w1, ((balance * 100) / 100));
    }

    function _withdraw(address _address, uint256 _amount) private {
        (bool success, ) = _address.call{value: _amount}("");
        require(success, "Failed to withdraw Ether");
    }
}