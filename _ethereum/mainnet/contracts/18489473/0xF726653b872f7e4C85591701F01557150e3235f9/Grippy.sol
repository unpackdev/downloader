// SPDX-License-Identifier: MIT  

//https://twitter.com/sbfnogrippy

//^:^:^::^^~^^^:.:^::^^^^^^^~^^^^::::^:^^:::::^^~~~~^:::::::^:^:^^^:~~^^::^^^~~~~~~~~~~~~~~~~~~~~~~~~~
//^:^^^^:^^~:^^:.:^::^^^^^^^~^^::::::^::::^^~!7?JYYJ?7?777!^::^:^^^:~^^^::^^^~~~~~~~~~~~~~~~~~~~~~~~~^
//^^^^^^:^^~::^^.:^::^^^^^.::^^::::::::^~7?7!7J5PPGPPP5YYJJ?!^^:^^^:~~~^::^^^~~~~~~~~~~~~~~~~~~~~~~~~:
//::^^^^^^^^:^^^.:^::^:..:.:::^:::^::^!7??77!!7???????JJJJ5Y?77~::::^:^^::^^~~~~~~~~~~~~~~~~~~~~~~~~~:
//::^^^~~^^::^^~.:^:.^:::^::::^:::^^7J?!!77??JJJJJJ?????JYPPPYJ?!::::::::.::^~~^~~~~~~~^^^^^~~~~~~~~^.
//::^:^~~~^^:^~~::^:.^::::::::^:::^?Y7!!?JJJJJJJJJJJ??????J5PPPYY7::^~^::....:::^::~~~~:^::^!~~~~~~~^:
//^^:^:~~~^^:^~~:.^::^::::^:::^:::75?!!77??JJJJJJJ??????777?J5YJ?57^^~::::..::^^^~:~!!~:^::^!~~^^~^..:
//^::^.:^~^^:^~^..::::::::^:::^::^YY7!!!7?JJJJJJJJY5PPP5Y?777?PGYJJ^^~::^~..:^^^~~:~!!^^^::^!~:..^~^.:
//^^~!:.^~~~~~~~~^^^^^::::::::^::!5J!~7YPPP5YJJJYPPPPYJYYJ?PJ7J##YP7^~::^~..^^^^~~:^~~^^:::^^^::^^~~::
//!^~7:.^~~~~~~~~!~~~~^:::::::^::~57!7JY55555GJJPY5P5PGYJ?75?7?G#GGP~~::^~..^^^^~^^^~~^:::::^~~~^::^::
//::~7:.:~~~~~^^:::^~^^:::^:::^::^JJ!77JP#BGPPJ?PG5PPGB5YJ?J7!!JBBP5!~::^^.:^^^^~~~!~~^::::~~~~~::^^::
//^:^!^.:~~~~~:.....:.::::^:::^:::75!~7JYPP55Y7??PP5YYYYYJY?!~~7YJJ57^::^^.:~^^^~!!!~~^::^^!!!!!~~!~.:
//::^!^.:~~~~~~~:..:^:::::^:::::::~?7!!?JJJJ?!??7?Y5JJJJJ??7!~~75P?55!::^^:^~^^~^~~~~^~~!!!!!!!!!!!~^^
//:^^!~.:^~~~~^^::::^:::^^::^^^^::^J~~!7???Y?7?????55YJ????7!~!JYJJBBJ::~~~!!!!!!!!!!!!!777~!!!!!!!!!!
//^^^~~.:^~~~~^^:::^~^::^::::::^::^P?~!7??Y5Y??JJYJYYYJJJ?7!!^7J?Y#&B7::~!!~~!!!~!!~~~^~~~~~~!!~~!!~~~
//!7!~!.:^~^~~~~^^:^^:::~:::::^^^^7GG!~!7JY55J??YJJJ5GPYJ?7!~7###&G#G~::~~~~~!!~~~~~~~~~~^^~^~!!!~~~~!
//~!!~!.:^~~~^~~^^^~~~^:~~~^:^:^^^J5PGY~!7J5PY??JJJYYYYY?77!7B@&&GPGB?::~~^^~~!!~~!~~!~~~~~!!~!~~~!~~!
//^:^~^:^!77!~~!~~!!77~:::::::::^!YBGGBY!~7?777?JYJ?????7!!?P@#G##5G&B!:!!~~~~~!!!!!!!!!~~~~!!!!~!!!!!
//^^^~:^~7777!~^^^~!!7!!^.....::~5YG#BGGGJ!!~!7?JJJ??7!!7?JYB@#BBBBP&&J:~!!!~^^^~!!!~~!!!!!!!!77!~!!!!
//!!~^^!!!!^::..:.:::^!77~:...::!5PB##G5P5YY7~!7????77?JJJJ5#&&##BGB&G!^^~!!7!~^^!~^^~77!!77!~~~!!!!!!
//::......:..^^:^~~~:^::^^:.:.^^?YG&#BYJGPGGY?77??JJJJJ?JJYP&&#G&#G5GJ~^^^^^~!!7^~!~~!!7^:!!~~^^^~~~~:
//::..:::....^^::^^^^^:.:^^:::::?Y#BBP5BBP5PY??????J??JJJY5B@&###B#BBP7~^:::.:^::~!::~!!~~~:::^^~~~!!^
//:::.::^::..~~::^~~~^^::..:^:^^JPG#BGBB##GPYJ??????JJJYY5G#@@@#GB#BB#5J7!~^^^:...:..:~~~~~^!!!!!!^~~~
//:::.:::::..^~::^~^^^^^:^~!7??!?PBB&BBBP55YJJJ????JJJYY5PB&@@@&P#&GGBGPJ77??JJ?!~^...^^:^~^:~!!!:.:.:
//:::.:.:^^^:^!:::~^^^~7?JYJYYJ7YGBB##&B5YYJJJJ????JJJJJ5PB#@@@BPG#BP555YJJJYYJYYJ?7^^^^~~^^~~!7!.....
//::::^~~!7!~~~^^^::~?YYYYYY5?7JPBGG#BGYJJJ????????JJJ??YPG#@&&&GJ##5YYJYY5PYJY555GP57!!!!~::::^~:...:
//^^^~777!7!!~!!~!~~YP5PBPP5Y?Y5P5P&#PPY?777????77????7?JPB&&#&BYP@@&PYJ?77J55YPGPPBBP!~~~~^::::::::::
//~!~~!!~~!7!!!!!~~YPBYP##BBPY5YPG&&#G##GPYJ??7777????JYPB#&###B5GB##@B55YYY5GGPBG5GG#5~!~~^^^::::::::
//77!!!7!!!~^^^~^^YB5BPP&&#Y5Y5GB#BB#B#####BBGGPPP55PGGB##@&GB###GPPY#BGGPYJ?YGB#G5BG&#7^~~~!!!~~~~^::
//!!7?777!7~~^^^^!B#5GG5##PYYYGB####BBGBGGBBBBBB####&##&#&&&##GPB&#BGBGPBGY?JPB##GP#G&@Y^~~!!!!!!!!~::
//..:^~~!~^^~~~~^Y@&PPP5#BPYYGGB#####BGGGGGGGBBBBBBBBGGB###BB@&#G&@&@BGGPGBYYPGG#BPBG&@B~~~~~~!!!77~::
//  .. ....^~~~~^P&#GPPP&#PYYPG#BBBBBBBGGGGGGGGGGGGBGGGGB#BGB##GPG&&BP#@B5PYJYY5BBPGB@@&!^~~~~!~~^^:..
// ..^!~^^~~!!~~!B&&#PP5#BPY55PBBGPBGGGGGGGGGGGGGGGBGGBGBGP#BBGG55G#PBB#BPYY5PG##GPPB@@&?^~~~!7!~..::.
//:::!!!~!!!~~~^?#&&#GPYP555555GGGPGGGGGGGGGPGGGGGGGBBBBBPBBGBBBP5Y5PGPGGPPP5GPB#PPP#@@&J^^^^^^^~~~^^:
//^:~7!77~!7!!!!J##&#GPYPPP5PYYGGP5PGGGGGGGGGGGGGGGGGBBBBBBBBB#BBBBBPPPGP55YYBPPBGGG#@@&J^^^^^^^^~~~^:

pragma solidity 0.8.19;

import "./Ownable.sol";
import "./ERC20.sol";
import "./IUniswapV2Router02.sol";

contract GRIPPY is ERC20, Ownable {

    IUniswapV2Router02 public immutable uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);

    uint256 public tradingStartTimeStamp;
    uint256 public maxHoldingAmount;
    uint256 public maxTransactionAmount;
    uint256 private swapTokensAt;

    address public deployerWallet;
    address public marketingWallet;
    address public bankWallet;
    address public uniswapV2Pair;

    bool public limited;
    bool public swapEnabled;
    bool private swapping;
    

    mapping (address => bool) private _ExcludedFromFees;
    mapping (address => bool) private _ExcludedFromTransactionAmount;

    error CanOnlySetPairOnce(address);
    error InvalidPresalePrice(uint256);
    error ExceedsHoldingAmount(uint256);
    error ExceedsMaxTransactionAmount(uint256);
    error TradingHasNotStarted();
    error WithdrawFailed();

    constructor(
        uint256 _totalSupply, 
        address _marketingWallet,
        address _bankWallet
    ) ERC20("SBFABitchInJailNoGrippySonicBoom", "SBFNoGrippy") {

        _mint(msg.sender, _totalSupply);

        swapTokensAt = (_totalSupply * 9) / 10_000;

        swapEnabled = true;

        deployerWallet = msg.sender;

        marketingWallet = _marketingWallet;

        bankWallet = _bankWallet;

        excludeFromFees(msg.sender, true);
        excludeFromFees(address(this), true);
        excludeFromFees(marketingWallet, true);
        excludeFromMaxTransaction(marketingWallet, true);
        excludeFromMaxTransaction(bankWallet, true);
        excludeFromMaxTransaction(address(uniswapV2Router), true);
        excludeFromMaxTransaction(msg.sender, true);
        excludeFromMaxTransaction(address(this), true);
    }

    receive() external payable {}

    function commenceTrading(address _uniswapV2Pair) external onlyOwner {

        if (tradingStartTimeStamp != 0) revert CanOnlySetPairOnce(uniswapV2Pair);

        uniswapV2Pair = _uniswapV2Pair;
        tradingStartTimeStamp = block.timestamp;
    }

    function setLimits(
        bool _limited, 
        uint256 _maxHoldingAmount,
        uint256 _maxTransactionAmount
    ) external onlyOwner {
        limited = _limited;
        maxTransactionAmount = _maxTransactionAmount;
        maxHoldingAmount = _maxHoldingAmount;
    }

    function toggleSwapping(bool _bool) external onlyOwner {
        swapEnabled = _bool;
    }

    function excludeFromFees(address _account, bool _excluded) public onlyOwner {
        _ExcludedFromFees[_account] = _excluded;
    }

    function excludeFromMaxTransaction(address _account, bool _excluded) public onlyOwner {
        _ExcludedFromTransactionAmount[_account] = _excluded;
    }

    function withdrawFunds(address payable _address) external onlyOwner {
        (bool success, ) = _address.call{value: address(this).balance}("");
        if (!success) revert WithdrawFailed();
    }

    function withdrawTokens(address payable _address, address _tokenContract) external onlyOwner {
        uint256 balanceInContract = IERC20(_tokenContract).balanceOf(address(this));
        _transfer(address(this), _address, balanceInContract);
    }


    function _getTaxes(
        uint256 _currentTimestamp
    ) internal view returns (uint256 _buyTax, uint256 _sellTax, bool _eligibleForTax) {
        uint256 elapsedTime = _currentTimestamp - tradingStartTimeStamp;
        uint256 buyTax = 5;
        uint256 sellTax = 5;
        bool eligibleForTax = true;
        if (elapsedTime < 1 minutes) {
            buyTax = 5;
            sellTax = 5;
            eligibleForTax = true;
        } else if (elapsedTime >= 1 minutes && elapsedTime < 3 minutes) {
            buyTax = 5;
            sellTax = 5;
            eligibleForTax = true;
        } 

        return (buyTax, sellTax, eligibleForTax);
    }

    function _transfer(
        address from, 
        address to, 
        uint256 amount
    ) internal override {
        if (uniswapV2Pair == address(0) && from != address(0) && from != owner()) revert TradingHasNotStarted();

        if(
            from != owner() &&
            to != owner() &&
            to != address(0) &&
            to != address(0xdead) &&
            !swapping
        )
            {
                if (limited) {
                    if (from == uniswapV2Pair && !_ExcludedFromTransactionAmount[to]) {
                        if (amount > maxTransactionAmount) revert ExceedsMaxTransactionAmount(amount);
                        if (balanceOf(to) + amount > maxHoldingAmount) revert ExceedsHoldingAmount(amount);
                    }
                    else if (to == uniswapV2Pair && !_ExcludedFromTransactionAmount[from]) {
                        if (amount > maxTransactionAmount) revert ExceedsMaxTransactionAmount(amount);
                    }
                    else if (!_ExcludedFromTransactionAmount[to]) {
                        if (balanceOf(to) + amount > maxHoldingAmount) revert ExceedsHoldingAmount(amount);
                    }
                }
            }
        
        uint256 contractBalance = balanceOf(address(this));

        
        bool canSwap = contractBalance >= swapTokensAt;

        if( 
            canSwap &&
            swapEnabled &&
            !swapping &&
            from != uniswapV2Pair &&
            !_ExcludedFromFees[from] &&
            !_ExcludedFromFees[to]
        ) {
            swapping = true;
            
            _swapBack(contractBalance);

            swapping = false;
        }

        bool takeFee = !swapping;

        
        if(_ExcludedFromFees[from] || _ExcludedFromFees[to]) {
            takeFee = false;
        }

        if (takeFee) {
            (uint256 buyTax, uint256 sellTax, bool eligibleForTax) = _getTaxes(block.timestamp);
            if (from == uniswapV2Pair && eligibleForTax) {
                uint256 tax = (amount * buyTax) / 100;
                super._transfer(from, address(bankWallet), tax);
                amount -= tax;
            }

            if (to == uniswapV2Pair && eligibleForTax) {
                uint256 tax = (amount * sellTax) / 100;
                super._transfer(from, address(marketingWallet), tax);
                amount -= tax;
            }
        }
        super._transfer(from, to, amount);
    }

    function _swapBack(uint256 _contractBalance) private {
        if (_contractBalance == 0) { return; }

        // Swap tokens for ETH
        _swapTokensForEth(_contractBalance); 

        uint256 totalEth = address(this).balance;

        // Send ETH to marketing wallet
        (bool success,) = address(marketingWallet).call{value: totalEth}("");
    }


    function _swapTokensForEth(uint256 _tokenAmount) private {

        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapV2Router.WETH();

        _approve(address(this), address(uniswapV2Router), _tokenAmount);

        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(
            _tokenAmount,
            0, 
            path,
            address(this),
            block.timestamp
        );
    }
}