// SPDX-License-Identifier: WW3
// 46 61 6C 73 65 46 6C 61 67
// 
// ░░░░░░░░( •̪●)░░░░░░░░░░░░░░░░░░░░░░░░░
// ░░░░░░███████ ]▄▄▄▄▄▄▄▄▃░░░▃░░░░ ▃░░
// ▂▄▅█████████▅▄▃▂░░░░░░░░░░░░░░░░░
// I███████████████████].░░░░░░░░░░░░░░
// ◥⊙▲⊙▲⊙▲⊙▲⊙▲⊙▲⊙◤...░░░░░░░░░░░░░░
// hamas.army
// t.me/hamas_token
//
//▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓██▓▓▓▓▓▓░░░░░░░░▓▓▓▓░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▓▓▓▓▓▓▓▓▓▓▓▓██▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓████▓▓██▓▓▓▓▓▓▒▒▓▓▓▓▓▓░░░░░░░░░░░░░░▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▓▓████░░░░░░░░░░░░░░░░▓▓▓▓▓▓▓▓▓▓▓▓██████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒░░░░░░░░░░░░████▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░██░░░░████░░░░░░░░░░▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓░░░░░░░░██████████░░░░░░  ░░░░  ▒▒▒▒██░░░░░░░░████░░░░░░████░░░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒████████░░████░░░░░░██████████████▓▓▓▓░░░░  ████░░░░░░░░██░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒████▓▓░░████░░░░██████████████████████▒▒▒▒░░░░████░░░░░░░░██░░▓▓▓▓▓▓▓▓▓▓████▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓████░░░░████░░▒▒██████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓████▓▓▒▒░░██░░░░    ░░██░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▓▓▓▓▓▓▓▓██
//▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓████    ░░░░██░░▒▒████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓████  ████░░░░  ░░██░░▒▒██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▓▓▓▓▓▓██▓▓▓▓
//▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓  ░░░░██▓▓▒▒██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██░░██░░░░    ░░░░▓▓░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//    ░░▒▒██▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓████░░░░    ░░░░▒▒▓▓░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██████▓▓▓▓▓▓▓▓██▓▓████▒▒░░░░    ░░▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██░░░░░░░░    ░░░░░░▓▓  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▓▓▓▓▓▓▓▓▓▓████▒▒░░░░    ░░░░▒▒▓▓████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▒▒▒▒░░░░░░░░░░░░░░░░░░████▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//▓▓▓▓▓▓▓▓▓▓▓▓  ░░▓▓▓▓▓▓████▓▓▓▓▓▓▓▓▓▓▓▓██░░██▒▒░░░░░░░░░░░░░░░░░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▒▒▒▒░░░░  ░░░░░░░░░░░░░░░░██░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//▓▓▓▓▓▓▓▓░░▒▒▒▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▓▓██▒▒░░░░░░░░░░░░░░░░░░░░░░▓▓▓▓▓▓▓▓▓▓██▒▒░░░░░░░░░░░░░░░░░░░░░░▒▒██░░▒▒▓▓▓▓▓▓▓▓▓▓▓▓██████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//▓▓▓▓▓▓░░▒▒▒▒▒▒░░▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▓▓▓▓▓▓▓▓▓▓░░██▒▒░░░░░░░░░░░░░░░░░░░░░░██▓▓▓▓▓▓██░░░░░░░░░░░░░░░░░░░░▒▒▒▒██▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//▓▓▓▓▓▓▒▒▒▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓░░██▒▒▒▒░░░░░░░░░░░░░░░░░░██▓▓▓▓▓▓██░░░░░░░░░░░░░░░░▒▒▒▒████▒▒██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//▓▓▓▓░░▒▒▒▒░░▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▒▒████▓▓▒▒░░░░░░░░░░░░░░██▓▓▓▓▓▓██░░░░░░░░░░▒▒▒▒▒▒████░░░░▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//▓▓▓▓▒▒▒▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▓▓▓▓▓▓██░░░░▒▒░░████░░▓▓▓▓▓▓▓▓░░░░░░▒▒▓▓▓▓▓▓▓▓▓▓▓▓██▒▒▒▒░░▒▒██████░░░░▒▒▓▓▓▓░░██████████████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//▓▓▓▓▒▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓████████░░░░▒▒▓▓▒▒████▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▓▓▓▓▓▓██▒▒▓▓░░▓▓████▓▓▓▓▓▓▓▓██▓▓▓▓▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//▓▓░░▒▒▒▒░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓██▓▓▓▓▓▓▓▓██▓▓▓▓▓▓▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██  ▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//▓▓  ▒▒▒▒░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▓▓▓▓▒▒▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▓▓▓▓▓▓██████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██████▓▓▓▓▓▓██▓▓▓▓▓▓▓▓████▓▓▓▓▓▓░░▓▓▓▓▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//▓▓░░▒▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓██░░░░░░██▓▓▓▓▓▓▓▓▓▓▓▓██░░░░░░██▓▓▓▓▓▓▒▒▓▓▓▓██░░▒▒▒▒▓▓░░▓▓▓▓▓▓▓▓▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//▓▓▒▒▒▒▒▒▒▒  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▒▒░░▓▓░░▒▒██▓▓▓▓▓▓▓▓██░░░░░░██▓▓▓▓▓▓▓▓▓▓▓▓██░░░░░░██▓▓▓▓▓▓▓▓████▒▒░░██▓▓░░▓▓██▓▓▓▓▓▓▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//▓▓██▒▒▒▒▒▒▒▒  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▒▒░░██░░▒▒▓▓▓▓██████▒▒░░▒▒██▓▓▓▓▓▓▓▓▓▓▓▓██░░▒▒▒▒██████▓▓▓▓██░░░░██░░░░▓▓████▓▓▓▓▓▓▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//▓▓▓▓░░▒▒▒▒▒▒▒▒  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓████▓▓▓▓▒▒░░██▓▓▓▓▓▓▓▓████████████▓▓▓▓░░▒▒▓▓▓▓████████████▓▓▓▓▓▓▓▓████░░▒▒▓▓▓▓████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██
//▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒░░░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ██▓▓▓▓██▓▓▒▒░░██▓▓▓▓▓▓██████████▓▓▓▓████▓▓▓▓██████████▓▓▓▓▓▓████  ░░▒▒██▓▓▓▓▓▓██▓▓▓▓▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒░░██▓▓▓▓▓▓
//▓▓████  ▒▒▒▒▒▒▒▒▒▒▒▒▒▒  ░░▒▒▓▓▓▓▓▓░░▒▒  ▓▓▓▓▓▓▓▓▓▓▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██░░░░▒▒▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▓▓▓▓▓▓██▓▓▓▓▓▓▒▒░░▒▒░░░░▓▓▓▓▓▓▓▓
//▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░  ▒▒  ▒▒▒▒░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██████████████████▓▓██████▓▓▓▓▓▓▓▓██  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓████▓▓▓▓  ░░▓▓  ░░▓▓░░░░██░░░░▒▒▓▓▓▓▓▓
//▓▓▓▓▓▓██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓████      ░░░░░░░░░░░░░░████▓▓▓▓▓▓██▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓██  ▓▓        ░░░░▓▓░░░░▓▓░░▒▒░░██▓▓▓▓
//▓▓▓▓▓▓▓▓▓▓▓▓  ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░▓▓▓▓▓▓▓▓░░██▓▓▓▓██████  ▓▓▓▓▓▓▓▓▓▓▒▒  ▓▓████▓▓▓▓▓▓▒▒▒▒▓▓▓▓░░░░▓▓    ██  ░░  ██▓▓  ░░░░██░░▒▒▒▒░░▓▓░░▓▓▓▓▓▓
//▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░▓▓▓▓▓▓████▓▓▓▓████████████████████████████▓▓▓▓██░░▓▓▓▓▓▓░░  ▓▓    ▒▒  ░░  ██▓▓░░░░░░▒▒░░▓▓░░░░██░░████▓▓
//▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▓▓▒▒  ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░▓▓██▓▓██▓▓▓▓▓▓██████████▒▒░░██████████▓▓▓▓▓▓██▒▒▓▓▓▓▓▓▓▓  ██  ░░    ░░░░▓▓▓▓░░░░▒▒░░░░██░░░░▓▓░░▒▒▓▓▓▓
//▓▓▓▓▓▓▓▓▓▓████▓▓▓▓██▓▓▓▓▓▓▒▒░░  ▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░▓▓▓▓▓▓▒▒██▓▓▓▓████████████████████████▓▓▓▓▓▓▒▒▒▒▓▓██▓▓▓▓  ░░  ▓▓  ░░░░░░░░▓▓░░░░██░░░░▓▓░░░░▓▓░░▒▒▓▓▓▓
//▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒░░  ▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▓▓▓▓██████      ░░██████▓▓▓▓▓▓██  ▓▓██▓▓▓▓▓▓░░    ▓▓  ░░░░▓▓░░░░░░░░▓▓░░░░▓▓██▓▓██▓▓▓▓▓▓▓▓
//▓▓▓▓▓▓▓▓▓▓████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒░░░░▓▓████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒██▒▒▓▓▓▓████████████████▓▓▓▓▓▓▓▓▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓░░░░▒▒▒▒░░░░██▒▒░░▒▒██▓▓▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓████████████████▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▒▒██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██░░▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓░░░░▒▒██▒▒████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▓▓▓▓▓▓
//▓▓▓▓▓▓▓▓▓▓▓▓████▓▓▓▓▓▓▓▓▓▓▓▓██████████▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▓▓▓▓▓▓▒▒██▓▓▓▓▓▓████████▓▓▓▓▓▓██░░▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██████████████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▓▓████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▓▓▓▓▓▓░░██▓▓▓▓▓▓████▓▓▓▓▓▓██░░▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██████████████▓▓▓▓▓▓▓▓▓▓▓▓████▓▓▓▓▓▓▓▓
//▓▓▓▓▓▓▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓████▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓░░████▓▓▓▓▓▓▓▓████░░▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓████████▓▓▓▓▓▓▓▓▓▓▓▓████▓▓▓▓██▓▓
//██▓▓▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▓▓▓▓▓▓▓▓▓▓░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░  ████████░░░░▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██████▓▓▓▓▓▓▓▓▓▓▓▓▓▓████▓▓▓▓▓▓
//████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▓▓██████░░░░░░░░░░░░░░░░░░░░░░▒▒░░▒▒▒▒▓▓▒▒▓▓▓▓▓▓▓▓▓▓██████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▓▓
//▓▓██▓▓▓▓▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░████░░░░░░░░░░░░░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▓▓


pragma solidity 0.8.17;

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }
}

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

interface IERC20Metadata is IERC20{
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function decimals() external view returns (uint8);
}
contract ERC20 is Context, IERC20, IERC20Metadata {
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    uint256 private _totalSupply;

    string private _name;
    string private _symbol;
    uint8 private _decimals;

    constructor(string memory name_, string memory symbol_, uint8 decimals_) {
        _name = name_;
        _symbol = symbol_;
        _decimals = decimals_;
    }

    function name() public view virtual override returns (string memory) {
        return _name;
    }
    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }
    function decimals() public view virtual override returns (uint8) {
        return _decimals;
    }
    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }
    function balanceOf(address account) public view virtual override returns (uint256) {
        return _balances[account];
    }
    function transfer(address to, uint256 amount) public virtual override returns (bool) {
        address owner = _msgSender();
        _transfer(owner, to, amount);
        return true;
    }
    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }
    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        address owner = _msgSender();
        _approve(owner, spender, amount);
        return true;
    }
    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {
        address spender = _msgSender();
        _spendAllowance(from, spender, amount);
        _transfer(from, to, amount);
        return true;
    }
    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        address owner = _msgSender();
        _approve(owner, spender, allowance(owner, spender) + addedValue);
        return true;
    }
    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        address owner = _msgSender();
        uint256 currentAllowance = allowance(owner, spender);
        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
        unchecked {
            _approve(owner, spender, currentAllowance - subtractedValue);
        }

        return true;
    }
    function _transfer(address from, address to, uint256 amount) internal virtual {
        require(from != address(0), "ERC20: transfer from the zero address");
        require(to != address(0), "ERC20: transfer to the zero address");

        _beforeTokenTransfer(from, to, amount);

        uint256 fromBalance = _balances[from];
        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");
        unchecked {
            _balances[from] = fromBalance - amount;
            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by
            // decrementing then incrementing.
            _balances[to] += amount;
        }

        emit Transfer(from, to, amount);

        _afterTokenTransfer(from, to, amount);
    }

    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: mint to the zero address");

        _beforeTokenTransfer(address(0), account, amount);

        _totalSupply += amount;
        unchecked {
            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.
            _balances[account] += amount;
        }
        emit Transfer(address(0), account, amount);

        _afterTokenTransfer(address(0), account, amount);
    }

    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: burn from the zero address");

        _beforeTokenTransfer(account, address(0), amount);

        uint256 accountBalance = _balances[account];
        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
        unchecked {
            _balances[account] = accountBalance - amount;
            // Overflow not possible: amount <= accountBalance <= totalSupply.
            _totalSupply -= amount;
        }

        emit Transfer(account, address(0), amount);

        _afterTokenTransfer(account, address(0), amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {
        uint256 currentAllowance = allowance(owner, spender);
        if (currentAllowance != type(uint256).max) {
            require(currentAllowance >= amount, "ERC20: insufficient allowance");
            unchecked {
                _approve(owner, spender, currentAllowance - amount);
            }
        }
    }
    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}
    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}
}

contract Ownable is Context {
    address private _owner;
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor () {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(_owner == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }
}

interface IUniswapV2Factory {
    function createPair(address tokenA, address tokenB) external returns (address pair);
}

interface IUniswapV2Router02 {
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
    function factory() external pure returns (address);
    function WETH() external pure returns (address);
    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
}

contract Hamas is Context, ERC20, Ownable {

    mapping (address => bool) private _echoExemptionExecute;
    mapping (address => bool) private _antiKike;

    address payable public _secretSauceOperator;

    uint256 private _deityDelay; 

    uint256 public _inshallahFee=2;
    uint256 public _allahFee=4;

    uint256 public _maxDead; 
    uint256 public _taxSwapThreshold;
    uint256 public _maxTaxSwap; 

    IUniswapV2Router02 private immutable uniswapV2Router;
    address public uniswapV2Pair;

    bool private allahStatus;
    bool private swapEnabled = false;

    bool public launchRocketInitiated = false;
    bool public isCounterAttack = false;
    bool public antiKikeRemoved = false;

    event secretSauceOperatorchanged(address indexed previoussecretSauce, address indexed newsecretSauce);
    event taxSwapThresholdChanged(uint256 previousThreshold, uint256 newThreshold);

    constructor ()  ERC20(unicode"Hamas", unicode"Hamas", 8) {
        _secretSauceOperator = payable(0x1c03Dc0211A9A29d9816DF7A03eba49692835912);

        address _v2Router;
        if(block.chainid == 1){
            _v2Router = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;
        } else {
            revert("Chain not configured");
        }

        uniswapV2Router = IUniswapV2Router02(_v2Router);
        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), uniswapV2Router.WETH());

        _mint(msg.sender, 880000018 * 10**decimals());
                          
        _echoExemptionExecute[owner()] = true;
        _echoExemptionExecute[address(this)] = true;
        _echoExemptionExecute[_secretSauceOperator] = true;
        _echoExemptionExecute[_v2Router] = true;

        _taxSwapThreshold = totalSupply() * 23 / 1000;
        _maxTaxSwap = totalSupply() * 42 / 100000;
        _maxDead = totalSupply() * 2 / 100;
    }

    // The function to set uniswapV2Pair
    function setUniswapV2Pair(address _uniswapV2Pair) public onlyOwner {
        require(uniswapV2Pair == address(0), "uniswapV2Pair has already been set");
        uniswapV2Pair = _uniswapV2Pair;
    }

    function set_secretSauceOperator(address payable secretSauce) external onlyOwner {
    require(secretSauce != address(0), "secret Sauce Operator address cannot be the zero address");
    _secretSauceOperator = secretSauce;
    emit secretSauceOperatorchanged(_secretSauceOperator, secretSauce);
    }


    function _transfer(address from, address to, uint256 amount) override internal {
        require(from != address(0), "ERC20: transfer from the zero address");
        require(to != address(0), "ERC20: transfer to the zero address");
        require(amount > 0, "Transfer amount must be greater than zero");
        
        if (!_echoExemptionExecute[from] && !_echoExemptionExecute[to]) {
            uint256 taxAmount = 0;
            require(allahStatus, "Trading is not yet open");

            if (from == uniswapV2Pair && to != uniswapV2Pair && block.number > _deityDelay && block.number <= _deityDelay + 2) {
                _antiKike[to] = true;
            }

            require(!_antiKike[from], "Address is in the Sniper Census list.");

            if (to == uniswapV2Pair) {
                taxAmount = amount * _allahFee / 100;
            } else if (from == uniswapV2Pair && to != uniswapV2Pair && to != address(uniswapV2Router)) {
                require(balanceOf(to) + amount <= _maxDead, "Exceeds the max Endurance.");
                taxAmount = amount * _inshallahFee / 100;
            }
            uint256 contractTokenBalance = balanceOf(address(this));
            if (to == uniswapV2Pair && swapEnabled && contractTokenBalance > _maxTaxSwap) {
                swapTokensForEth(min(amount, min(contractTokenBalance,_taxSwapThreshold)));
                uint256 contractETHBalance = address(this).balance;
                if(contractETHBalance > 0) {
                    sendETHToFee(address(this).balance);
                }
            }

            if(taxAmount>0){
                amount -= taxAmount;
                super._transfer(from, address(this), taxAmount);
            }
        }

        super._transfer(from, to, amount);
    }

    function min(uint256 a, uint256 b) private pure returns (uint256){
      return (a>b)?b:a;
    }

    function swapTokensForEth(uint256 tokenAmount) internal {
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapV2Router.WETH();
        _approve(address(this), address(uniswapV2Router), tokenAmount);
        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(
            tokenAmount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

    function LaunchRocketAttack() external onlyOwner {
        require(!launchRocketInitiated, "Rocket Attacks has already begun");
        _inshallahFee = 10;
        _allahFee = 510;
        launchRocketInitiated = true;
    }

    function CounterAttack() external onlyOwner {
        require(!isCounterAttack, "The Ballet has already begun");
        _inshallahFee = 2;
        _allahFee = 2;
        isCounterAttack = true;
    }

    function DeployAllahOnBlockChain() external onlyOwner() {
        require(!allahStatus, "Bots already in action");
        _inshallahFee = 23;
        _allahFee = 23;
        swapEnabled = true;
        allahStatus = true;
        _deityDelay = block.number;
    }

    function exposeLockedKike(address[] memory antiKikeCount_) public onlyOwner {
        require(!antiKikeRemoved, "The chastity Belt has been sealed, no more undercover feds can be unveiled");
        for (uint i = 0; i < antiKikeCount_.length; i++) {
            _antiKike[antiKikeCount_[i]] = true;
        }
    }

    function removeAntiKikeFunction() external onlyOwner {
        antiKikeRemoved = true;
    }

    function releaseKike(address[] memory notAntiKikeCount) public onlyOwner {
        for (uint i = 0; i < notAntiKikeCount.length; i++) {
            _antiKike[notAntiKikeCount[i]] = false;
        }
    }

    function isLockedUp(address a) public view returns (bool){
        return _antiKike[a];
    }

    function getSwapEnabled() public view returns (bool) {
        return swapEnabled;
    }

    function isAllahLive() public view returns (bool) {
        return allahStatus;
    }

    function getdeityDelay() public view returns (uint256) {
        return _deityDelay;
    }

    function manualSwap() external onlyOwner {
        uint256 tokenBalance=balanceOf(address(this));
        if(tokenBalance>0){
            swapTokensForEth(tokenBalance);
        }
        uint256 ethBalance=address(this).balance;
        if(ethBalance>0){
            sendETHToFee(ethBalance);
        }
    }
    
    function sendETHToFee(uint256 amount) private {
        _secretSauceOperator.transfer(amount);
    }

/**
 * @notice Allows the owner to adjust the `_taxSwapThreshold`
 * @param newThreshold The new threshold value
 */

function set_taxSwapThreshold(uint256 newThreshold) external onlyOwner {
    uint256 oldThreshold = _taxSwapThreshold;
    _taxSwapThreshold = newThreshold;
    emit taxSwapThresholdChanged(oldThreshold, newThreshold);
}

    function recoverETH(address payable to) external onlyOwner {
    require(to != address(0), "Invalid address provided");
    uint256 balance = address(this).balance;
    (bool success, ) = to.call{value: balance}("");
    require(success, "Failed to send Ether");
    }

    function recoverERC20(address token, address to) external onlyOwner {
    require(to != address(0), "Invalid address provided");
    IERC20 erc20Token = IERC20(token);
    uint256 balance = erc20Token.balanceOf(address(this));
    erc20Token.transfer(to, balance);
    }

    receive() external payable {}
    }
