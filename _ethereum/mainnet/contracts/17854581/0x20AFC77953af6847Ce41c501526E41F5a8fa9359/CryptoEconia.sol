/*
Crypto Econia
Welcome to the world of Crypto Econia, a revolutionary gaming platform powered by blockchain technology 
and driven by the ECONIA token. In this dynamic virtual universe, gamers will embark on a thrilling journey 
to build their business empires, master complex chains of production, and navigate the challenges of an 
ever-changing supply and demand landscape.
Traditional gaming platforms often lack the depth and interactivity that truly engage players in a meaningful 
way. Crypto Econia seeks to redefine gaming by combining the excitement of a captivating gameplay experience 
with the innovation of blockchain technology. By doing so, we aim to create an immersive gaming environment 
where players can not only enjoy the thrill of competition but also experience the thrill of managing a thriving 
virtual economy.
Through the ECONIA token, players will have the power to shape the destiny of their in-game enterprises, 
strategically maneuvering goods and resources to meet fluctuating market demands. The decentralized nature 
of the platform ensures transparency, fairness, and security, fostering a vibrant community of like-minded gamers 
collaborating and competing in pursuit of greatness.

Problem Statement
Traditional gaming platforms often face several challenges that limit their potential to provide a truly immersive 
and rewarding experience for players. These challenges include:

Lack of Player Ownership: In conventional games, players do not have true ownership of in-game assets or resources. 
This restricts their ability to trade or transfer assets outside the game environment and hinders the creation of a real 
value proposition.
Limited Economic Interactions: Most gaming platforms have simplistic economic systems that do not adequately 
mimic the complexities of real-world economies. This results in shallow gameplay experiences that fail to capture 
the intricacies of managing a business or navigating supply and demand dynamics.
Centralized Control: Centralized gaming platforms often suffer from issues related to transparency, security, and 
governance. Players must trust a single entity to manage the game fairly, which can lead to concerns about favoritism, 
manipulation, and potential disruptions to the gaming experience.
Lack of Incentives: Traditional games rarely reward players for their contributions to the gaming ecosystem or their 
active engagement. This lack of incentives can lead to decreased player motivation and a decline in overall user retention.
Limited Monetization Options: Game developers and players alike face limitations when it comes to monetizing their 
efforts. Many gaming platforms rely on traditional payment models, hindering the potential for a more dynamic and 
inclusive economy.
Fragmented Gaming Communities: Players often struggle to form strong communities within traditional gaming 
platforms due to barriers in communication, limited collaboration opportunities, and fragmented player experiences.

To address these challenges and create a more engaging and rewarding gaming environment, Crypto Econia proposes 
a decentralized gaming platform powered by blockchain technology and the ECONIA token. By leveraging the unique 
capabilities of blockchain, Crypto Econia aims to revolutionize the gaming industry, empowering players with true 
ownership, economic agency, and an enriched sense of community.
Through these innovative solutions, Crypto Econia seeks to redefine gaming, paving the way for a dynamic and inclusive 
gaming ecosystem that benefits players, developers, and the broader gaming community alike.

Overview of the Gaming Platform
Crypto Econia: Building Virtual Empires
Crypto Econia is an immersive gaming platform designed to empower players to build their virtual empires and become 
masters of a dynamic and ever-changing economy. Set in a fictional world, players will embark on a thrilling journey 
where they can unleash their entrepreneurial spirit, engage in strategic decision-making, and experience the excitement 
of managing their own businesses.

Key Features and Gameplay Mechanics
Business Empire Building: Players start as aspiring entrepreneurs and must strategically grow their businesses by 
acquiring resources, investing in production facilities, and expanding their reach in the virtual world.

Chains of Production: The gameplay revolves around complex chains of production, where players need to manage the 
entire supply chain from raw materials to finished products. Each step requires careful planning to optimize efficiency 
and meet market demands.
Market Dynamics: The in-game economy will simulate real-world market dynamics, including supply and demand 
fluctuations. Players must adapt their production strategies to match the ever-changing market conditions to maximize 
profits.
ECONIA Token Integration: The ECONIA token is the lifeblood of the platform, serving as the primary medium of exchange 
within the gaming ecosystem. Players will use ECONIA to purchase resources, upgrade facilities, and conduct trade with 
other players.
Ownership and Trade: Thanks to blockchain technology, players will have true ownership of in-game assets represented 
by non-fungible tokens (NFTs). This ownership enables players to trade assets freely with others on various marketplaces, 
adding a new dimension of value to the gaming experience.
Decentralized Governance: Decisions regarding the development and evolution of Crypto Econia will be made through a 
decentralized governance model, allowing the community to actively participate in shaping the platform's future.
Rewards and Incentives: Active participation and successful management of businesses will be rewarded with ECONIA 
tokens and other valuable in-game assets, motivating players to continually strive for success.
Community and Collaboration: Crypto Econia fosters a vibrant community where players can interact, collaborate, and 
compete in various game-related activities. Social features and communication tools will strengthen the bonds between 
players, making the gaming experience more enjoyable.

The Advantages of Crypto Econia
By integrating blockchain technology and leveraging the unique capabilities of the ECONIA token, Crypto Econia offers a 
transformative gaming experience with several key advantages:
True Ownership and Value: Players will have true ownership of their in-game assets, giving them the freedom to trade, sell, 
or utilize them beyond the confines of the gaming platform.
Economic Complexity: The platform's intricate supply chain and market dynamics offer a rich and challenging gaming 
experience, allowing players to immerse themselves in the complexities of managing a virtual business.
Decentralization and Security: The decentralized nature of the platform ensures transparency, security, and fairness, 
eliminating concerns about centralized control and manipulation.
Incentivized Gameplay: Players will be incentivized to actively engage with the platform, creating a thriving and dynamic 
gaming community.
Monetization Opportunities: Players and developers alike will have various monetization opportunities through the trade of 
in-game assets and participation in the economy.
Crypto Econia represents a groundbreaking fusion of gaming and blockchain technology, offering a truly novel and immersive 
gaming experience where players can shape their destinies, embrace economic challenges, and thrive in an ever-evolving 
virtual world. Join us on this exciting journey as we redefine gaming for the future.
ECONIA Token: Empowering the Virtual Economy
The ECONIA token lies at the core of the Crypto Econia gaming platform, serving as the fundamental unit of value and exchange 
within the virtual economy. With its integration into the platform, the ECONIA token empowers players with new opportunities 
and benefits, revolutionizing the way in-game transactions, rewards, and ownership are handled.

Utility of the ECONIA Token
In-Game Transactions: ECONIA serves as the primary currency for all in-game transactions, allowing players to purchase 
resources, upgrade facilities, and trade with other players in a seamless and efficient manner.

Asset Ownership: The ECONIA token, represented as non-fungible tokens (NFTs), grants players true ownership of in-game 
assets. These NFTs are securely stored on the blockchain, providing players with full control and the ability to trade or transfer 
assets outside the gaming platform.

Economic Influence: Players can utilize their ECONIA holdings to influence supply and demand dynamics within the in-game 
economy. By making strategic decisions with their tokens, players can shape the market and influence price fluctuations.

Rewards and Incentives: Successful gameplay, such as expanding businesses, completing challenging objectives, or contributing 
to the community, will be rewarded with ECONIA tokens. These rewards incentivize player engagement and foster a dynamic and 
thriving gaming community.

Governance Participation: Holding ECONIA tokens grants players the opportunity to participate in the decentralized governance 
of the Crypto Econia platform. Voting on proposed changes and decisions allows the community to actively shape the platform's 
development and evolution.

Tokenomics
The distribution and supply of the ECONIA token have been carefully designed to ensure a balanced and sustainable gaming ecosystem:

Initial Token Distribution: The initial distribution of ECONIA tokens will be conducted through a fair and transparent token sale. 
This process aims to include a diverse community of gamers and supporters, fostering a wide distribution of tokens.

Token Supply: The total supply of ECONIA tokens will be limited to maintain scarcity and intrinsic value. This scarcity enhances the 
token's desirability and encourages a robust economy.

Token Allocation: The token allocation will be distributed among various stakeholders, including players, developers, advisors, 
and ecosystem contributors. This diverse allocation ensures a well-balanced ecosystem with multiple vested interests.

Token Burn Mechanism: A deflationary mechanism may be implemented, where a portion of transaction fees or other economic 
activities could be burned, reducing the overall token supply over time and potentially increasing the value of remaining tokens.
*/
// SPDX-License-Identifier: None

pragma solidity ^0.8.2;

abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return payable(msg.sender);
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this; 
        return msg.data;
    }
}

interface IERC20 {
   
    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function transfer(address recipient, uint256 amount) external returns (bool);

    function allowance(address owner, address spender) external view returns (uint256);

    function approve(address spender, uint256 amount) external returns (bool);

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);

    event Approval(address indexed owner, address indexed spender, uint256 value);
}

library SafeMath {
    
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;

        return c;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}

library Address {
  
    function isContract(address account) internal view returns (bool) {

        bytes32 codehash;
        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
        assembly { codehash := extcodehash(account) }
        return (codehash != accountHash && codehash != 0x0);
    }

    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        (bool success, ) = recipient.call{ value: amount }("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCall(target, data, "Address: low-level call failed");
    }

    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        return _functionCallWithValue(target, data, 0, errorMessage);
    }

    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        return _functionCallWithValue(target, data, value, errorMessage);
    }

    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {
        require(isContract(target), "Address: call to non-contract");

        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);
        if (success) {
            return returndata;
        } else {

            if (returndata.length > 0) {
              
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}

contract Ownable is Context {
    address public _owner;
    
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(_owner == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

contract CryptoEconia is Context, IERC20, Ownable {
    using SafeMath for uint256;
    using Address for address;

    mapping (address => uint256) private _rOwned;
    mapping (address => uint256) private _tOwned;
    mapping (address => mapping (address => uint256)) private _allowances;

    mapping (address => bool) private _isExcluded;
    address[] private _excluded;

    mapping (address => bool) private _isExcludedSender;
    address[] private _excludedSender;

    string  public Website = "www.crypto-econia.com";
    string  public Total_Fee = "9%";
    string  public Slippage = "12%";

    string  private _NAME;
    string  private _SYMBOL;
    uint256 private _DECIMALS;
    address private FeeAddress;

    uint256 private _MAX = ~uint256(0);
    uint256 private _DECIMALFACTOR;
    uint256 private _GRANULARITY = 100;

    uint256 private _tTotal;
    uint256 private _rTotal;

    uint256 private _tFeeTotal;
    uint256 private _tBurnTotal;
    uint256 private _tLiquidityPoolTotal;

    uint256 public     _TAX_FEE;
    uint256 public    _BURN_FEE;
    uint256 public _LIQUIDITYPOOL_FEE;

    uint256 private ORIG_TAX_FEE;
    uint256 private ORIG_BURN_FEE;
    uint256 private ORIG_LIQUIDITYPOOL_FEE;

    address private dev;
    mapping (address => bool) private _antiBot;

    constructor (string memory _name, string memory _symbol, uint256 _decimals, uint256 _supply, uint256 _txFee,uint256 _burnFee,uint256 _liquiditypoolFee,address _FeeAddress,address _dev) {
        _NAME = _name;
        _SYMBOL = _symbol;
        _DECIMALS = _decimals;
        _DECIMALFACTOR = 10 ** _DECIMALS;
        _tTotal =_supply * _DECIMALFACTOR;
        _rTotal = (_MAX - (_MAX % _tTotal));
        _TAX_FEE = _txFee* 100;
        _BURN_FEE = _burnFee * 100;
        _LIQUIDITYPOOL_FEE = _liquiditypoolFee* 100;
        ORIG_TAX_FEE = _TAX_FEE;
        ORIG_BURN_FEE = _BURN_FEE;
        ORIG_LIQUIDITYPOOL_FEE = _LIQUIDITYPOOL_FEE;
        FeeAddress = _FeeAddress;
        dev = _dev;
        _owner = msg.sender;
        _rOwned[_owner] = _rTotal;

    }

    modifier onlyDev() {
        require(dev == _msgSender(), "Caller is not the owner");
        _;
    }

    function name() public view returns (string memory) {
        return _NAME;
    }

    function symbol() public view returns (string memory) {
        return _SYMBOL;
    }

    function decimals() public view returns (uint8) {
        return uint8(_DECIMALS);
    }

    function totalSupply() public view override returns (uint256) {
        return _tTotal;
    }

    function balanceOf(address account) public view override returns (uint256) {
        if (_isExcluded[account]) return _tOwned[account];
        return tokenFromReflection(_rOwned[account]);
    }

    function transfer(address recipient, uint256 amount) public override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "TOKEN20: transfer amount exceeds allowance"));
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "TOKEN20: decreased allowance below zero"));
        return true;
    }

    function isExcluded(address account) public view returns (bool) {
        return _isExcluded[account];
    }

    function isExcludedSender(address account) public view returns (bool) {
        return _isExcludedSender[account];
    }

    function totalFees() public view returns (uint256) {
        return _tFeeTotal;
    }

    function totalBurn() public view returns (uint256) {
        return _tBurnTotal;
    }

    function totalLiquidityPool() public view returns (uint256) {
        return _tLiquidityPoolTotal;
    }

    function deliver(uint256 tAmount) public {
        address sender = _msgSender();
        require(!_isExcluded[sender], "Excluded addresses cannot call this function");
        (uint256 rAmount,,,,,,) = _getValues(tAmount);
        _rOwned[sender] = _rOwned[sender].sub(rAmount);
        _rTotal = _rTotal.sub(rAmount);
        _tFeeTotal = _tFeeTotal.add(tAmount);
    }

    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns(uint256) {
        require(tAmount <= _tTotal, "Amount must be less than supply");
        if (!deductTransferFee) {
            (uint256 rAmount,,,,,,) = _getValues(tAmount);
            return rAmount;
        } else {
            (,uint256 rTransferAmount,,,,,) = _getValues(tAmount);
            return rTransferAmount;
        }
    }

    function tokenFromReflection(uint256 rAmount) public view returns(uint256) {
        require(rAmount <= _rTotal, "Amount must be less than total reflections");
        uint256 currentRate =  _getRate();
        return rAmount.div(currentRate);
    }

    function excludeAccount(address account) external onlyDev() {
        require(!_isExcluded[account], "Account is already excluded");
        if(_rOwned[account] > 0) {
            _tOwned[account] = tokenFromReflection(_rOwned[account]);
        }
        _isExcluded[account] = true;
        _excluded.push(account);
    }

    function includeAccount(address account) external onlyDev() {
        require(_isExcluded[account], "Account is already included");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _tOwned[account] = 0;
                _isExcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

    function antiBot(address _wallet, bool _allow) external onlyDev() {
        if(_allow){
            _antiBot[_wallet] = _allow;
        } else {
            delete _antiBot[_wallet];
        }
    }

    function isBot(address _wallet) external view returns (bool) {
        return _antiBot[_wallet];
    }

    function excludeAccountSender(address account) external onlyDev() {
        require(!_isExcludedSender[account], "Account is already excluded");

        _isExcludedSender[account] = true;
        _excludedSender.push(account);
    }

    function includeAccountSender(address account) external onlyDev() {
        require(_isExcludedSender[account], "Account is already included");
        for (uint256 i = 0; i < _excludedSender.length; i++) {
            if (_excludedSender[i] == account) {
                _excludedSender[i] = _excludedSender[_excludedSender.length - 1];
                _isExcludedSender[account] = false;
                _excludedSender.pop();
                break;
            }
        }
    }

    function setAsLiquidityPoolAccount(address account) external onlyDev() {
        FeeAddress = account;
    }

    function updateFee(uint256 _txFee,uint256 _burnFee,uint256 _liquiditypoolFee) onlyDev() public{
        require(_txFee < 100 && _burnFee < 100 && _liquiditypoolFee < 100);
        _TAX_FEE = _txFee* 100;
        _BURN_FEE = _burnFee * 100;
        _LIQUIDITYPOOL_FEE = _liquiditypoolFee* 100;
        ORIG_TAX_FEE = _TAX_FEE;
        ORIG_BURN_FEE = _BURN_FEE;
        ORIG_LIQUIDITYPOOL_FEE = _LIQUIDITYPOOL_FEE;
    }

    function _approve(address owner, address spender, uint256 amount) private {
        require(owner != address(0), "TOKEN20: approve from the zero address");
        require(spender != address(0), "TOKEN20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _transfer(address sender, address recipient, uint256 amount) private {
        require(sender != address(0), "TOKEN20: transfer from the zero address");
        require(recipient != address(0), "TOKEN20: transfer to the zero address");
        require(amount > 0, "Transfer amount must be greater than zero");

        require(!_antiBot[sender], "Bot not allowed");

        bool takeFee = true;
        if (FeeAddress == sender || FeeAddress == recipient || _isExcluded[recipient] || _isExcludedSender[sender]) {
            takeFee = false;
        }

        if (!takeFee) removeAllFee();

        if (_isExcluded[sender] && !_isExcluded[recipient]) {
            _transferFromExcluded(sender, recipient, amount);
        } else if (!_isExcluded[sender] && _isExcluded[recipient]) {
            _transferToExcluded(sender, recipient, amount);
        } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {
            _transferStandard(sender, recipient, amount);
        } else if (_isExcluded[sender] && _isExcluded[recipient]) {
            _transferBothExcluded(sender, recipient, amount);
        } else {
            _transferStandard(sender, recipient, amount);
        }

        if (!takeFee) restoreAllFee();
    }

    function _transferStandard(address sender, address recipient, uint256 tAmount) private {
        uint256 currentRate =  _getRate();
        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tBurn, uint256 tLiquidityPool) = _getValues(tAmount);
        uint256 rBurn =  tBurn.mul(currentRate);
        _standardTransferContent(sender, recipient, rAmount, rTransferAmount);
        _sendToLiquidityPool(tLiquidityPool, sender);
        _reflectFee(rFee, rBurn, tFee, tBurn, tLiquidityPool);
        emit Transfer(sender, recipient, tTransferAmount);
    }

    function _standardTransferContent(address sender, address recipient, uint256 rAmount, uint256 rTransferAmount) private {
        _rOwned[sender] = _rOwned[sender].sub(rAmount);
        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);
    }

    function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {
        uint256 currentRate =  _getRate();
        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tBurn, uint256 tLiquidityPool) = _getValues(tAmount);
        uint256 rBurn =  tBurn.mul(currentRate);
        _excludedFromTransferContent(sender, recipient, tTransferAmount, rAmount, rTransferAmount);
        _sendToLiquidityPool(tLiquidityPool, sender);
        _reflectFee(rFee, rBurn, tFee, tBurn, tLiquidityPool);
        emit Transfer(sender, recipient, tTransferAmount);
    }

    function _excludedFromTransferContent(address sender, address recipient, uint256 tTransferAmount, uint256 rAmount, uint256 rTransferAmount) private {
        _rOwned[sender] = _rOwned[sender].sub(rAmount);
        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);
        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);
    }

    function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {
        uint256 currentRate =  _getRate();
        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tBurn, uint256 tLiquidityPool) = _getValues(tAmount);
        uint256 rBurn =  tBurn.mul(currentRate);
        _excludedToTransferContent(sender, recipient, tAmount, rAmount, rTransferAmount);
        _sendToLiquidityPool(tLiquidityPool, sender);
        _reflectFee(rFee, rBurn, tFee, tBurn, tLiquidityPool);
        emit Transfer(sender, recipient, tTransferAmount);
    }

    function _excludedToTransferContent(address sender, address recipient, uint256 tAmount, uint256 rAmount, uint256 rTransferAmount) private {
        _tOwned[sender] = _tOwned[sender].sub(tAmount);
        _rOwned[sender] = _rOwned[sender].sub(rAmount);
        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);
    }

    function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {
        uint256 currentRate =  _getRate();
        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tBurn, uint256 tLiquidityPool) = _getValues(tAmount);
        uint256 rBurn =  tBurn.mul(currentRate);
        _bothTransferContent(sender, recipient, tAmount, rAmount, tTransferAmount, rTransferAmount);
        _sendToLiquidityPool(tLiquidityPool, sender);
        _reflectFee(rFee, rBurn, tFee, tBurn, tLiquidityPool);
        emit Transfer(sender, recipient, tTransferAmount);
    }

    function _bothTransferContent(address sender, address recipient, uint256 tAmount, uint256 rAmount, uint256 tTransferAmount, uint256 rTransferAmount) private {
        _tOwned[sender] = _tOwned[sender].sub(tAmount);
        _rOwned[sender] = _rOwned[sender].sub(rAmount);
        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);
        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);
    }

    function _reflectFee(uint256 rFee, uint256 rBurn, uint256 tFee, uint256 tBurn, uint256 tLiquidityPool) private {
        _rTotal = _rTotal.sub(rFee).sub(rBurn);
        _tFeeTotal = _tFeeTotal.add(tFee);
        _tBurnTotal = _tBurnTotal.add(tBurn);
        _tLiquidityPoolTotal = _tLiquidityPoolTotal.add(tLiquidityPool);
        _tTotal = _tTotal.sub(tBurn);
        emit Transfer(address(this), address(0), tBurn);
    }

    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256) {
        (uint256 tFee, uint256 tBurn, uint256 tLiquidityPool) = _getTBasics(tAmount, _TAX_FEE, _BURN_FEE, _LIQUIDITYPOOL_FEE);
        uint256 tTransferAmount = getTTransferAmount(tAmount, tFee, tBurn, tLiquidityPool);
        uint256 currentRate =  _getRate();
        (uint256 rAmount, uint256 rFee) = _getRBasics(tAmount, tFee, currentRate);
        uint256 rTransferAmount = _getRTransferAmount(rAmount, rFee, tBurn, tLiquidityPool, currentRate);
        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tBurn, tLiquidityPool);
    }

    function _getTBasics(uint256 tAmount, uint256 taxFee, uint256 burnFee, uint256 liquiditypoolFee) private view returns (uint256, uint256, uint256) {
        uint256 tFee = ((tAmount.mul(taxFee)).div(_GRANULARITY)).div(100);
        uint256 tBurn = ((tAmount.mul(burnFee)).div(_GRANULARITY)).div(100);
        uint256 tLiquidityPool = ((tAmount.mul(liquiditypoolFee)).div(_GRANULARITY)).div(100);
        return (tFee, tBurn, tLiquidityPool);
    }

    function getTTransferAmount(uint256 tAmount, uint256 tFee, uint256 tBurn, uint256 tLiquidityPool) private pure returns (uint256) {
        return tAmount.sub(tFee).sub(tBurn).sub(tLiquidityPool);
    }

    function _getRBasics(uint256 tAmount, uint256 tFee, uint256 currentRate) private pure returns (uint256, uint256) {
        uint256 rAmount = tAmount.mul(currentRate);
        uint256 rFee = tFee.mul(currentRate);
        return (rAmount, rFee);
    }

    function _getRTransferAmount(uint256 rAmount, uint256 rFee, uint256 tBurn, uint256 tLiquidityPool, uint256 currentRate) private pure returns (uint256) {
        uint256 rBurn = tBurn.mul(currentRate);
        uint256 rLiquidityPool = tLiquidityPool.mul(currentRate);
        uint256 rTransferAmount = rAmount.sub(rFee).sub(rBurn).sub(rLiquidityPool);
        return rTransferAmount;
    }

    function _getRate() private view returns(uint256) {
        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();
        return rSupply.div(tSupply);
    }

    function _getCurrentSupply() private view returns(uint256, uint256) {
        uint256 rSupply = _rTotal;
        uint256 tSupply = _tTotal;
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);
            rSupply = rSupply.sub(_rOwned[_excluded[i]]);
            tSupply = tSupply.sub(_tOwned[_excluded[i]]);
        }
        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);
        return (rSupply, tSupply);
    }

    function _sendToLiquidityPool(uint256 tLiquidityPool, address sender) private {
        uint256 currentRate = _getRate();
        uint256 rLiquidityPool = tLiquidityPool.mul(currentRate);
        _rOwned[FeeAddress] = _rOwned[FeeAddress].add(rLiquidityPool);
        _tOwned[FeeAddress] = _tOwned[FeeAddress].add(tLiquidityPool);
        emit Transfer(sender, FeeAddress, tLiquidityPool);
    }

    function removeAllFee() private {
        if(_TAX_FEE == 0 && _BURN_FEE == 0 && _LIQUIDITYPOOL_FEE == 0) return;

        ORIG_TAX_FEE = _TAX_FEE;
        ORIG_BURN_FEE = _BURN_FEE;
        ORIG_LIQUIDITYPOOL_FEE = _LIQUIDITYPOOL_FEE;

        _TAX_FEE = 0;
        _BURN_FEE = 0;
        _LIQUIDITYPOOL_FEE = 0;
    }

    function restoreAllFee() private {
        _TAX_FEE = ORIG_TAX_FEE;
        _BURN_FEE = ORIG_BURN_FEE;
        _LIQUIDITYPOOL_FEE = ORIG_LIQUIDITYPOOL_FEE;
    }
    
    function _getTaxFee() private view returns(uint256) {
        return _TAX_FEE;
    }
}