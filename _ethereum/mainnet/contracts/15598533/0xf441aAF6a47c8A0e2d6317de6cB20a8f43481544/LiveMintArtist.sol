// SPDX-License-Identifier: MIT-BROUGKR
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
/**
 * @dev: @brougkr
 */
pragma solidity 0.8.17;
import "./IERC721.sol";
import "./ERC721.sol";
import "./IERC20.sol";
import "./Ownable.sol";
import "./ReentrancyGuard.sol";
import "./MerkleProof.sol";
import "./IMinter.sol";
import "./IMP.sol";
contract LiveMintArtist is Ownable, ReentrancyGuard
{   
    struct Artist
    {
        string _Name;
        uint _ProjectID;
        address _MintPass;
        address _Minter;
        address _ERC20;
        bytes32 _Root;
        uint _MaxQR;
        uint _CurrentQR;
        bool _QRsActive;
    }

    struct User
    {
        bool Eligible;
        uint Allocation;
    }

    /*-------------------*/
    /*     MAPPINGS      */
    /*-------------------*/
    
    mapping(uint => Artist) public Artists;                             // Returns [ArtistID] => Artist Struct
    mapping(uint => mapping(address => bool)) public RedeemedQR;        // Returns [ArtistID][Address] => Boolean If User Has BrightList Minted NFT
    mapping(uint => mapping(address => uint)) public QRAllocation;      // Returns [ArtistID][Address] => User's QR Code Allocation
    mapping(uint => mapping(uint => address)) public BrightListArtist;  // Returns [ArtistID][TicketID] => Address Of Minting Receiver For Artist Mint 
    mapping(uint => mapping(uint => bool)) public MintedArtist;         // Returns [ArtistID][TicketID] => Boolean If Artist MintPass ID Has Minted Or Not
    mapping(uint => mapping(uint => uint)) private _MintedTokenID;      // Returns [ArtistID][TicketID] => Minted Work TokenID
    mapping(uint => mapping(uint=>string)) public _Data;                // Returns [ArtistID][TicketID] => Data
    mapping(address => bool) public Role;                               // Returns [Address] => BRT Minter Role Mapping

    /*-------------------*/
    /*      EVENTS       */
    /*-------------------*/

    event LiveMintCompleteArtist(address indexed Recipient, uint ArtistID, uint TicketID, uint MintedWorkTokenID);
    event ArtistMintPassRedeemed(address indexed Redeemer, uint ArtistID, uint TicketID, string Data);
    event ArtistChangedMinter(uint[] ArtistIDs, address[] NewAddresses);
    event MinterAdded(address NewMinter);
    event NewArtist(uint ArtistID);
    event MinterRemoved(address RemovedMinter);
    event ArtistChangedProjectIDs(uint[] ArtistIDs, uint[] ProjectIDs);
    event ERC20AddressChanged(address OldERC20Address, address NewERC20Address);
    event ArtistChangedMintPass(uint[] ArtistIDs, address[] NewContractAddresses);
    event MerkleRootChanged(uint[] ArtistIDs, bytes32[] NewRoots);
    event QRAllocationsOverwritten(address[] Addresses, uint[] Amounts);
    event QRAllocationsIncremented(address[] Addresses, uint[] Amounts);
    event ArtistChangedMintPasses(uint[] ArtistIDs, address[] NewAddresses);

    /*-------------------*/
    /*    CONSTRUCTOR    */
    /*-------------------*/

    constructor()
    { 
        Role[0x1A0a3E3AE390a0710f8A6d00587082273eA8F6C9] = true; // BRT Minter #1
        Role[0x4d8013b0c264034CBf22De9DF33e22f58D52F207] = true; // BRT Minter #2
        Role[0x4D9A8CF2fE52b8D49C7F7EAA87b2886c2bCB4160] = true; // BRT Minter #3
        Role[0x124fd966A0D83aA020D3C54AE2c9f4800b46F460] = true; // BRT Minter #4
        Role[0x100469feA90Ac1Fe1073E1B2b5c020A8413635c4] = true; // BRT Minter #5
        Role[0x756De4236373fd17652b377315954ca327412bBA] = true; // BRT Minter #6
        Role[0xc5Dfba6ef7803665C1BDE478B51Bd7eB257A2Cb9] = true; // BRT Minter #7
        Role[0xFBF32b29Bcf8fEe32d43a4Bfd3e7249daec457C0] = true; // BRT Minter #8
        Role[0xF2A15A83DEE7f03C70936449037d65a1C100FF27] = true; // BRT Minter #9
        Role[0x1D2BAB965a4bB72f177Cd641C7BacF3d8257230D] = true; // BRT Minter #10
        Role[0x2e51E8b950D72BDf003b58E357C2BA28FB77c7fB] = true; // BRT Minter #11
        Role[0x8a7186dECb91Da854090be8226222eA42c5eeCb6] = true; // BRT Minter #12
        Role[0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700] = true; // BRT Minter #13
        Role[0x7603C5eed8e57Ad795ec5F0081eFB21d1eEBf937] = true; // BRT Minter #14
        Role[0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700] = true; // BRT Minter #15
        _transferOwnership(0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700);                  
    }

    /*-------------------*/
    /*  PUBLIC FUNCTIONS */
    /*-------------------*/

    /**
     * @dev Redeems Artist Mint Passes & BrightLists Address To Receive Artist Mint
     **/
    function RedeemArtistPass(
        uint[] calldata ArtistIDs, 
        uint[] calldata TicketIDs, 
        string calldata Data
    ) external nonReentrant {
        unchecked
        {
            for(uint x; x < ArtistIDs.length; x++)
            {
                require(
                    IERC721(Artists[ArtistIDs[x]]._MintPass).ownerOf(TicketIDs[x]) == msg.sender, 
                    "LiveMintArtist: Sender Does Not Own Token With The Input Token ID"
                );
                BrightListArtist[ArtistIDs[x]][TicketIDs[x]] = IMP(Artists[ArtistIDs[x]]._MintPass)._LiveMintBurn(TicketIDs[x]);
                _Data[ArtistIDs[x]][TicketIDs[x]] = Data;
                emit ArtistMintPassRedeemed(msg.sender, ArtistIDs[x], TicketIDs[x], Data);
            }
        }
    }

    /**
     * @dev Redeems Spot For IRL Minting
     */
    function RedeemQR(uint ArtistID, bytes32[] calldata Proof, string calldata Data) external nonReentrant
    {
        require(readQREligibility(ArtistID, msg.sender, Proof), "LiveMint: User Is Not Eligible To Redeem QR");
        unchecked
        {
            RedeemedQR[ArtistID][msg.sender] = true;
            if(QRAllocation[ArtistID][msg.sender] == 0) // User Is Able To Redeem Explicitly 1 QR Code
            {
                require(!RedeemedQR[ArtistID][msg.sender], "LiveMint: User Has Already Redeemed");
                Artists[ArtistID]._CurrentQR++;
                _Data[ArtistID][Artists[ArtistID]._CurrentQR] = Data;
                BrightListArtist[ArtistID][Artists[ArtistID]._CurrentQR] = msg.sender;
                emit ArtistMintPassRedeemed(msg.sender, ArtistID, Artists[ArtistID]._CurrentQR, Data);
            }
            else // User Is Able To Redeem More Than 1 QR Code Because Their Integer Allocation > 0
            {
                uint CurrentQR = Artists[ArtistID]._CurrentQR;
                uint Limit = CurrentQR + QRAllocation[ArtistID][msg.sender];
                QRAllocation[ArtistID][msg.sender] = 0;
                Artists[ArtistID]._CurrentQR = Limit;
                for(CurrentQR; CurrentQR < Limit; CurrentQR++)
                {
                    _Data[ArtistID][CurrentQR] = Data;
                    BrightListArtist[ArtistID][CurrentQR] = msg.sender;
                    emit ArtistMintPassRedeemed(msg.sender, ArtistID, CurrentQR, Data);
                }
            }
        }
    }

    /*----------------------
     * ARTIST LIVE MINTING *
    ------------------------/

    /**
     * @dev Batch Mints Verified Users On The Brightlist A Singular Artist's NFTs
     */
    function _LiveMintArtist(uint ArtistID, uint[] calldata TicketIDs) external onlyMinter 
    {
        unchecked
        {
            for(uint TicketID; TicketID < TicketIDs.length; TicketID++)
            {
                require(!MintedArtist[ArtistID][TicketIDs[TicketID]], "LiveMintArtist: Artist Mint Pass Already Minted");
                address Recipient;
                if(BrightListArtist[ArtistID][TicketIDs[TicketID]] != address(0)) { Recipient = BrightListArtist[ArtistID][TicketIDs[TicketID]]; }
                else { Recipient = IMP(Artists[ArtistID]._MintPass)._LiveMintBurn(TicketIDs[TicketID]); }
                require(Recipient != address(0), "LiveMintArtist: Mint Pass Entered Is Not Brightlisted");
                MintedArtist[ArtistID][TicketIDs[TicketID]] = true;
                uint MintedWorkTokenID = IMinter(Artists[ArtistID]._Minter).purchaseTo(Recipient, Artists[ArtistID]._ProjectID);
                _MintedTokenID[ArtistID][TicketIDs[TicketID]] = MintedWorkTokenID;
                emit LiveMintCompleteArtist(Recipient, ArtistID, TicketIDs[TicketID], MintedWorkTokenID);
            }
        }
    }

    /**
     * @dev Batch Mints Verified Users On The Brightlist Multiple Artist's NFTs
     */
    function _LiveMintArtistBatch(uint[] calldata ArtistIDs, uint[] calldata TicketIDs) external onlyMinter 
    {
        require(ArtistIDs.length == TicketIDs.length, "LiveMint: Invalid Array Lengths");
        unchecked
        {
            for(uint Index; Index < TicketIDs.length; Index++)
            {
                require(!MintedArtist[ArtistIDs[Index]][TicketIDs[Index]], "LiveMintArtist: Artist Mint Pass Already Minted");
                address Recipient;
                if(BrightListArtist[ArtistIDs[Index]][TicketIDs[Index]] != address(0)) { Recipient = BrightListArtist[ArtistIDs[Index]][TicketIDs[Index]]; }
                else { Recipient = IMP(Artists[ArtistIDs[Index]]._MintPass)._LiveMintBurn(TicketIDs[Index]); }
                require(Recipient != address(0), "LiveMintArtist: Mint Pass Entered Is Not Brightlisted");
                MintedArtist[ArtistIDs[Index]][TicketIDs[Index]] = true;
                uint MintedWorkTokenID = IMinter(Artists[ArtistIDs[Index]]._Minter).purchaseTo(Recipient, Artists[ArtistIDs[Index]]._ProjectID);
                _MintedTokenID[ArtistIDs[Index]][TicketIDs[Index]] = MintedWorkTokenID;
                emit LiveMintCompleteArtist(Recipient, ArtistIDs[Index], TicketIDs[Index], MintedWorkTokenID);
            }
        }
    }

    /*-------------------*/
    /*  OWNER FUNCTIONS  */
    /*-------------------*/

    /**
     * @dev Batch Approves BRT For Purchasing
     */
    function __BatchApproveERC20(address[] calldata ERC20s, address[] calldata Operators, uint[] calldata Amounts) external onlyOwner
    {
        require(ERC20s.length == Operators.length && Operators.length == Amounts.length, "LiveMintArtist: Arrays Must Be Equal Length");
        for(uint i; i < ERC20s.length; i++)
        {
            IERC20(ERC20s[i]).approve(Operators[i], Amounts[i]);
        }
    }

    /**``
     * @dev Grants Address BRT Minter Role
     **/
    function __MinterAdd(address Minter) external onlyOwner { Role[Minter] = true; }

    /**
     * @dev Deactivates Address From BRT Minter Role
     **/
    function __MinterRemove(address Minter) external onlyOwner { Role[Minter] = false; }

    /**
     * @dev Changes Name
     */
    function __ChangeArtistNames(uint[] calldata ArtistIDs, string[] calldata Names) external onlyOwner 
    {
        require(ArtistIDs.length == Names.length, "LiveMintArtist: Arrays Must Be Of Equal Length");
        for(uint Index; Index < ArtistIDs.length; Index++) { Artists[ArtistIDs[Index]]._Name = Names[Index]; }
    }

    /**
     * @dev Modifies The Current ArtBlocks ProjectID
     **/
    function __ChangeProjectIDs(uint[] calldata ArtistIDs, uint[] calldata ArtBlocksProjectIDs) external onlyOwner 
    { 
        require(ArtistIDs.length == ArtBlocksProjectIDs.length, "LiveMintArtist: Arrays Must Be Of Equal Length");
        for(uint Index; Index < ArtistIDs.length; Index++) { Artists[ArtistIDs[Index]]._ProjectID = ArtBlocksProjectIDs[Index]; }
    }

    /**
     * @dev Changes Artist Mint Passes
     */
    function __ChangeArtistMintPasses(uint[] calldata ArtistIDs, address[] calldata NewAddresses) external onlyOwner
    {
        require(ArtistIDs.length == NewAddresses.length, "LiveMintArtist: Arrays Must Be Of Equal Length");
        for(uint Index; Index < ArtistIDs.length; Index++) { Artists[ArtistIDs[Index]]._MintPass = NewAddresses[Index]; }
    }

    /**
     * @dev Modifies Artist Minter Contract Addresses
     */
    function __ChangeArtistMinter(uint[] calldata ArtistIDs, address[] calldata NewAddresses) external onlyOwner
    {
        require(ArtistIDs.length == NewAddresses.length, "LiveMintArtist: Arrays Must Be Of Equal Length");
        for(uint Index; Index < ArtistIDs.length; Index++) { Artists[ArtistIDs[Index]]._Minter = NewAddresses[Index]; }
    }

    /**
     * @dev Modifies ERC20 BRT Minting Token Address
     */
    function __ChangeERC20Addresses(uint[] calldata ArtistIDs, address[] calldata NewERC20Addresses) external onlyOwner 
    { 
        require(ArtistIDs.length == NewERC20Addresses.length, "LiveMintArtist: Arrays Must Be Of Equal Length");
        for(uint Index; Index < ArtistIDs.length; Index++) { Artists[ArtistIDs[Index]]._ERC20 = NewERC20Addresses[Index]; }
    }

    /**
     * @dev Changes Merkle Root
     */
    function __NewRoots(uint[] calldata ArtistIDs, bytes32[] calldata NewRoots) external onlyOwner
    {
        require(ArtistIDs.length == NewRoots.length, "LiveMintArtist: Arrays Must Be Of Equal Length");
        for(uint Index; Index < ArtistIDs.length; Index++) { Artists[ArtistIDs[Index]]._Root = NewRoots[Index]; }
    }

    /**
     * @dev Modifies Max QR Index
     */
    function __ChangeArtistMaxQR(uint[] calldata ArtistIDs, uint[] calldata MaxQRIndex) external onlyOwner
    {
        require(ArtistIDs.length == MaxQRIndex.length, "LiveMintArtist: Arrays Must Be Of Equal Length");
        for(uint Index; Index < ArtistIDs.length; Index++) { Artists[ArtistIDs[Index]]._MaxQR = MaxQRIndex[Index]; }
    }

    /**
     * @dev Modifies Current QR Index
     */
    function __ChangeArtistCurrentQR(uint[] calldata ArtistIDs, uint[] calldata CurrentQRIndexes) external onlyOwner
    {
        require(ArtistIDs.length == CurrentQRIndexes.length, "LiveMintArtist: Arrays Must Be Of Equal Length");
        for(uint Index; Index < ArtistIDs.length; Index++) { Artists[ArtistIDs[Index]]._CurrentQR = CurrentQRIndexes[Index]; }
    }

    /**
     * @dev Overwrites QR Allocation
     */
    function __ChangeArtistQRAllocations(uint ArtistID, address[] calldata Addresses, uint[] calldata Amounts) external onlyOwner
    {
        require(Addresses.length == Amounts.length, "LiveMintArtist: Input Arrays Must Match");
        for(uint Index; Index < Addresses.length; Index++) { QRAllocation[ArtistID][Addresses[Index]] = Amounts[Index]; }
    }

    /**
     * @dev Increments QR Allocations
     */
    function __ChangeArtistIncrementQRAllocations(uint ArtistID, address[] calldata Addresses, uint[] calldata Amounts) external onlyOwner
    {
        require(Addresses.length == Amounts.length, "LiveMintArtist: Input Arrays Must Match");
        for(uint Index; Index < Addresses.length; Index++) { QRAllocation[ArtistID][Addresses[Index]] += Amounts[Index]; }
    }

    /**
     * @dev Modifies Artist's QR Active State
     */
    function __ChangeArtistQRsActive(uint[] calldata ArtistIDs, bool[] calldata States) external onlyOwner 
    {
        require(ArtistIDs.length == States.length, "LiveMintArtist: Input Arrays Must Match");
        for(uint Index; Index < ArtistIDs.length; Index++) { Artists[ArtistIDs[Index]]._QRsActive = States[Index]; }
    }

    /**
     * @dev Modifies Artist Mapping At Index `ArtistID`
     */
    function __OverwriteArtistStruct(uint ArtistID, Artist memory New) external onlyOwner { Artists[ArtistID] = New; }


    /**
     * @dev Batch Changes State Variables For LiveMintArtist
     * note: __ApproveBRT(_ERC20_BRT_Token) Will Need To Be Called On This Contract After This Function
     * note: This Is So That Variables Can Be Double Checked & Mint Will Not Be Active Until That Is Complete
     */
    function __OverwriteArtist(
        uint ArtistID,
        string calldata Name,
        uint ProjectID,
        address MintPass,
        address Minter,
        address ERC20,
        bytes32 Root,
        uint MaxQR,
        uint CurrentQR
    ) external onlyOwner {
        Artists[ArtistID]._Name = Name;
        Artists[ArtistID]._ProjectID = ProjectID;
        Artists[ArtistID]._MintPass = MintPass;
        Artists[ArtistID]._Minter = Minter;
        Artists[ArtistID]._ERC20 = ERC20;
        Artists[ArtistID]._Root = Root;
        Artists[ArtistID]._MaxQR = MaxQR;
        Artists[ArtistID]._CurrentQR = CurrentQR;
        Artists[ArtistID]._ERC20 = ERC20;
        IERC20(Artists[ArtistID]._ERC20).approve(Minter, 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffff);
        emit NewArtist(ArtistID);
    }

    /**
     * @dev Withdraws Any Ether Mistakenly Sent to Contract to Multisig
     **/
    function __WithdrawEther() external onlyOwner { payable(msg.sender).transfer(address(this).balance); }

    /**
     * @dev Withdraws ERC20 Tokens to Multisig
     **/
    function __WithdrawERC20(address TokenAddress) external onlyOwner 
    { 
        IERC20 erc20Token = IERC20(TokenAddress);
        uint balance = erc20Token.balanceOf(address(this));
        require(balance > 0, "0 ERC20 Balance At `TokenAddress`");
        erc20Token.transfer(msg.sender, balance);
    }

    /**
     * @dev Withdraws Any NFT Mistakenly Sent To This Contract.
     */
    function __WithdrawERC721(address ContractAddress, address Recipient, uint TokenID) external onlyOwner
    {
        IERC721(ContractAddress).transferFrom(address(this), Recipient, TokenID);
    }
    
    /*-------------------*/
    /*    PUBLIC VIEW    */
    /*-------------------*/

    /**
     * @dev Returns A Singular Artist
     */
    function readArtist(uint ArtistID) public view returns (Artist memory) { return Artists[ArtistID]; }

    /**
     * @dev Returns Multiple Artists
     */
    function readArtists(uint[] calldata ArtistIDs) public view returns (Artist[] memory)
    {
        Artist[] memory _Artists = new Artist[](ArtistIDs.length);
        for(uint ArtistID; ArtistID < ArtistIDs.length; ArtistID++)
        {
            _Artists[ArtistID] = Artists[ArtistIDs[ArtistID]];
        }
        return _Artists;
    }

    /**
     * @dev Returns BrightListed Address Corresponding to Mint Pass `ArtistID` & `TicketID`
     */
    function readBrightListArtist(uint ArtistID, uint TicketID) public view returns(address) { return BrightListArtist[ArtistID][TicketID]; }

    /**
     * @dev Returns A Batch Of BrightListed Addresses
     */
    function readBrightListArtistBatch(uint[] calldata ArtistIDs, uint Range) public view returns(address[][] memory)
    {
        address[][] memory Addresses = new address[][](ArtistIDs.length);
        for(uint ArtistID; ArtistID < ArtistIDs.length; ArtistID++)
        {
            for(uint TokenID; TokenID < Range; TokenID++) 
            { 
                Addresses[ArtistID][TokenID] = BrightListArtist[ArtistIDs[ArtistID]][TokenID]; 
            }
        }
        return Addresses;
    }

    /**
     * @dev Returns All TicketID Data Corresponding To ArtistID
     */
    function readData(uint[] calldata ArtistIDs, uint Range) public view returns(string[][] memory AllDatas)
    {
        string[][] memory AllData = new string[][](Range);
        for(uint ArtistID; ArtistID < ArtistIDs.length; ArtistID++)
        {
            for(uint TicketID; TicketID < Range; TicketID++) 
            { 
                AllData[ArtistIDs[ArtistID]][TicketID] = _Data[ArtistIDs[ArtistID]][TicketID]; 
            }
        }
        return AllData;
    }

    /**
     * @dev Returns A 2d Array Of Checked In & Unminted TicketIDs
     */
    function readCheckedInTicketIDs(uint[] calldata ArtistIDs, uint Range) public view returns(uint[][] memory TokenIDs)
    {
        uint[][] memory _TokenIDs = new uint[][](ArtistIDs.length);
        uint Index;
        for(uint ArtistID; ArtistID < ArtistIDs.length; ArtistID++)
        {
            uint[] memory CheckedIn = new uint[](Range);
            uint Counter;
            for(uint TokenID; TokenID < Range; TokenID++)
            {
                if(BrightListArtist[ArtistIDs[ArtistID]][TokenID] != address(0)) 
                { 
                    CheckedIn[Counter] = TokenID; 
                    Counter++;
                }
            }
            uint[] memory FormattedCheckedInTickets = new uint[](Counter);
            uint Found;
            for(uint x; x < Counter; x++)
            {
                if(CheckedIn[x] != 0 || (CheckedIn[x] == 0 && x == 0))
                {
                    FormattedCheckedInTickets[Found] = CheckedIn[x];
                    Found++;
                }
            }
            _TokenIDs[Index] = FormattedCheckedInTickets;
            Index++;
        }
        return (_TokenIDs);
    }

    /**
     * @dev Returns A 2d Array Of Minted ArtistIDs
     */
    function readMintedTicketIDs(uint[] calldata ArtistIDs, uint Range) public view returns(uint[][] memory TokenIDs)
    {
        uint[][] memory _TokenIDs = new uint[][](ArtistIDs.length);
        uint Index;
        for(uint ArtistID; ArtistID < ArtistIDs.length; ArtistID++)
        {
            uint[] memory MintedTokenIDs = new uint[](Range);
            uint Counter;
            for(uint TokenID; TokenID < Range; TokenID++)
            {
                if(MintedArtist[ArtistIDs[ArtistID]][TokenID])
                { 
                    MintedTokenIDs[Counter] = TokenID; 
                    Counter++;
                }
            }
            uint[] memory FormattedMintedTokenIDs = new uint[](Counter);
            uint Found;
            for(uint x; x < Counter; x++)
            {
                if(MintedTokenIDs[x] != 0 || (MintedTokenIDs[x] == 0 && x == 0))
                {
                    FormattedMintedTokenIDs[Found] = MintedTokenIDs[x];
                    Found++;
                }
            }
            _TokenIDs[Index] = FormattedMintedTokenIDs;
            Index++;
        }
        return (_TokenIDs);
    }

    /**
     * @dev Returns Minted TokenID
     */
    function readMintedTokenID(uint ArtistID, uint TicketID) external view returns (uint)
    {
        if(!MintedArtist[ArtistID][TicketID]) { return 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff; }
        else { return _MintedTokenID[ArtistID][TicketID]; }
    }

    /**
     * @dev Returns A 2d Array Of Minted ArtistIDs
     */
    function readUnmintedTicketIDs(uint[] calldata ArtistIDs, uint Range) public view returns(uint[][] memory TokenIDs)
    {
        uint[][] memory _TokenIDs = new uint[][](ArtistIDs.length);
        uint Index;
        for(uint ArtistID; ArtistID < ArtistIDs.length; ArtistID++)
        {
            uint[] memory UnmintedArtistTokenIDs = new uint[](Range);
            uint Counter;
            for(uint TokenID; TokenID < Range; TokenID++)
            {
                bool TicketIDBurned;
                try IERC721(Artists[ArtistIDs[ArtistID]]._MintPass).ownerOf(TokenID) { } // checks if token is burned
                catch { TicketIDBurned = true; }
                if(
                    !MintedArtist[ArtistIDs[ArtistID]][TokenID]
                    &&
                    (
                        BrightListArtist[ArtistIDs[ArtistID]][TokenID] != address(0)
                        ||
                        TicketIDBurned == false
                    )
                ) 
                { 
                    UnmintedArtistTokenIDs[Counter] = TokenID; 
                    Counter++;
                }
            }
            uint[] memory FormattedUnMintedArtistIDs = new uint[](Counter);
            uint Found;
            for(uint x; x < Counter; x++)
            {
                if(UnmintedArtistTokenIDs[x] != 0 || (UnmintedArtistTokenIDs[x] == 0 && x == 0))
                {
                    FormattedUnMintedArtistIDs[Found] = UnmintedArtistTokenIDs[x];
                    Found++;
                }
            }
            _TokenIDs[Index] = FormattedUnMintedArtistIDs;
            Index++;
        }
        return (_TokenIDs);
    }

    /**
     * @dev Returns A 2d Array Of Minted ArtistIDs
     */
    function readMintedWorkTokenIDs(uint[] calldata ArtistIDs, uint Range) public view returns(uint[][] memory TokenIDs)
    {
        uint[][] memory _TokenIDs = new uint[][](ArtistIDs.length);
        uint Index;
        for(uint ArtistID; ArtistID < ArtistIDs.length; ArtistID++)
        {
            uint[] memory MintedWorkTokenIDs = new uint[](Range);
            uint Counter;
            for(uint TokenID; TokenID < Range; TokenID++)
            {
                if(MintedArtist[ArtistIDs[ArtistID]][TokenID])
                { 
                    MintedWorkTokenIDs[Counter] = _MintedTokenID[ArtistIDs[ArtistID]][TokenID]; 
                    Counter++;
                }
            }
            uint[] memory FormattedMintedTokenIDs = new uint[](Counter);
            uint Found;
            for(uint x; x < Counter; x++)
            {
                if(MintedWorkTokenIDs[x] != 0 || (MintedWorkTokenIDs[x] == 0 && x == 0))
                {
                    FormattedMintedTokenIDs[Found] = MintedWorkTokenIDs[x];
                    Found++;
                }
            }
            _TokenIDs[Index] = FormattedMintedTokenIDs;
            Index++;
        }
        return (_TokenIDs);
    }

    /**
     * @dev Returns If User Is Eligible To Redeem QR Code
     */
    function readEligibility(uint ArtistID, address Recipient, bytes32[] memory Proof) public view returns(User memory)
    {
        bool Eligible = readQREligibility(ArtistID, Recipient, Proof);
        uint Allocation;
        if(Eligible && QRAllocation[ArtistID][Recipient] > 0) { Allocation = QRAllocation[ArtistID][Recipient]; }
        return User(Eligible, Allocation);
    }

    /**
     * @dev Returns If User Is Eligible To Redeem QR Code
     */
    function readQREligibility(uint ArtistID, address Recipient, bytes32[] memory Proof) public view returns(bool)
    {
        bytes32 Leaf = keccak256(abi.encodePacked(Recipient));
        bool BrightListEligible = MerkleProof.verify(Proof, Artists[ArtistID]._Root, Leaf);
        if(
            (BrightListEligible && !RedeemedQR[ArtistID][Recipient])
            || 
            (BrightListEligible && QRAllocation[ArtistID][Recipient] > 0)
        ) { return true; }
        else { return false; }
    }

    /**
     * @dev Returns If User Is Eligible To Redeem QR Codes
     */
    function readQREligibilites(uint[] calldata ArtistIDs, address Recipient, bytes32[][] memory Proofs) public view returns(bool[] memory)
    {
        bytes32 Leaf = keccak256(abi.encodePacked(Recipient));
        bool[] memory Eligibilities = new bool[](ArtistIDs.length);
        for(uint ArtistID; ArtistID < ArtistIDs.length; ArtistID++)
        {
            bool BrightListEligible = MerkleProof.verify(Proofs[ArtistID], Artists[ArtistIDs[ArtistID]]._Root, Leaf);
            if(
                (BrightListEligible && !RedeemedQR[ArtistIDs[ArtistID]][Recipient])
                || 
                (BrightListEligible && QRAllocation[ArtistIDs[ArtistID]][Recipient] > 0)
            ) { Eligibilities[ArtistID] = true; }
        }
        return Eligibilities;
    }

    /*------------------*/
    /*     MODIFIERS    */
    /*------------------*/

    /**
     * @dev Function Modifier That Allows Only BrightListed BRT Minters To Access
     **/
    modifier onlyMinter() 
    {
        require(Role[msg.sender] == true, "OnlyMinter: Caller Is Not Approved BRT Minter");
        _;
    }
}
