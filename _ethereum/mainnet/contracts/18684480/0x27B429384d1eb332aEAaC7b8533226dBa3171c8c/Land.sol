// SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;

import "ERC721.sol";
import "ERC721Enumerable.sol";
import "ERC721Pausable.sol";
import "AccessControl.sol";
import "EIP712.sol";
import "ERC721Burnable.sol";
import "Initializable.sol";
import "IERC1271.sol";
import "ECDSA.sol";

contract Land is
    Initializable,
    ERC721,
    ERC721Enumerable,
    ERC721Pausable,
    AccessControl,
    ERC721Burnable,
    EIP712
{
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
    bytes32 public constant BLACKLISTER_ROLE = keccak256("BLACKLISTER_ROLE");
    bytes32 public constant UPGRADE_ROLE = keccak256("UPGRADE_ROLE");
    bytes32 private immutable _PERMIT_TYPEHASH =
        keccak256(
            "Permit(address spender,uint256 tokenId,uint256 nonce,uint256 deadline)"
        );
    string private _name;
    string private _symbol;

    mapping(address => bool) internal blacklisted;
    mapping(uint256 => bool) internal blacklistedId;
    mapping(uint256 => uint256) private _nonces;
    uint256 private _tokenIdTracker;

    string private _baseTokenURI;

    constructor(
        string memory name_,
        string memory symbol_,
        string memory baseTokenURI_
    ) ERC721(name_, symbol_) EIP712(name_, "1") {
        _name = name_;
        _symbol = symbol_;
    }

    function initialize(
        string memory name_,
        string memory symbol_,
        string memory baseTokenURI_,
        address owner
    ) public initializer {
        _name = name_;
        _symbol = symbol_;
        _baseTokenURI = baseTokenURI_;
        _grantRole(DEFAULT_ADMIN_ROLE, owner);
        _grantRole(PAUSER_ROLE, owner);
        _grantRole(MINTER_ROLE, owner);
        _grantRole(UPGRADE_ROLE, owner);
    }

    /**
     * @dev See {IERC721Metadata-name}.
     */
    function name() public view virtual override returns (string memory) {
        return _name;
    }

    /**
     * @dev See {IERC721Metadata-symbol}.
     */
    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    function _baseURI() internal view virtual override returns (string memory) {
        return _baseTokenURI;
    }

    function updateBaseURI(
        string memory baseTokenURI
    ) public virtual onlyRole(UPGRADE_ROLE) returns (string memory) {
        return _baseTokenURI = baseTokenURI;
    }

    function nonces(
        uint256 tokenId
    ) external view virtual returns (uint256) {
        return _nonces[tokenId];
    }

    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparatorV4();
    }

    function permit(
        address spender,
        uint256 tokenId,
        uint256 deadline,
        bytes memory signature
    ) external {
        _permit(spender, tokenId, deadline, signature);
    }

    function _permit(
        address spender,
        uint256 tokenId,
        uint256 deadline,
        bytes memory signature
    ) internal virtual {
        // solhint-disable-next-line not-rely-on-time
        require(block.timestamp <= deadline, "ERC721Permit: expired deadline");

        bytes32 structHash = keccak256(
            abi.encode(
                _PERMIT_TYPEHASH,
                spender,
                tokenId,
                _nonces[tokenId],
                deadline
            )
        );
        bytes32 hash = _hashTypedDataV4(structHash);

        (address signer, ECDSA.RecoverError a, bytes32 b) = ECDSA.tryRecover(hash, signature);
        bool isValidEOASignature = signer != address(0) &&
            _isAuthorized(signer, spender, tokenId);

        require(
            isValidEOASignature ||
                _isValidContractERC1271Signature(
                    ownerOf(tokenId),
                    hash,
                    signature
                ) ||
                _isValidContractERC1271Signature(
                    getApproved(tokenId),
                    hash,
                    signature
                ),
            "ERC721Permit: invalid signature"
        );

        _approve(spender, tokenId, address(0));
    }

    function _isValidContractERC1271Signature(
        address signer,
        bytes32 hash,
        bytes memory signature
    ) private view returns (bool) {
        (bool success, bytes memory result) = signer.staticcall(
            abi.encodeWithSelector(
                IERC1271.isValidSignature.selector,
                hash,
                signature
            )
        );
        return (success &&
            result.length == 32 &&
            abi.decode(result, (bytes4)) == IERC1271.isValidSignature.selector);
    }

    /**
     * @dev Creates a new token for `to`. Its token ID will be automatically
     * assigned (and available on the emitted {IERC721-Transfer} event), and the token
     * URI autogenerated based on the base URI passed at construction.
     *
     * See {ERC721-_mint}.
     *
     * Requirements:
     *
     * - the caller must have the `MINTER_ROLE`.
     */
    function mint(address to) public virtual onlyRole(MINTER_ROLE) {
        uint256 tokenId = _tokenIdTracker++;
        _safeMint(to, tokenId);
    }

    /**
     * @dev Pauses all token transfers.
     *
     * See {ERC721Pausable} and {Pausable-_pause}.
     *
     * Requirements:
     *
     * - the caller must have the `PAUSER_ROLE`.
     */
    function pause() public virtual onlyRole(PAUSER_ROLE) {
        _pause();
    }

    /**
     * @dev Unpauses all token transfers.
     *
     * See {ERC721Pausable} and {Pausable-_unpause}.
     *
     * Requirements:
     *
     * - the caller must have the `PAUSER_ROLE`.
     */
    function unpause() public virtual onlyRole(PAUSER_ROLE) {
        _unpause();
    }

    function supportsInterface(
        bytes4 interfaceId
    )
        public
        view
        override(ERC721, ERC721Enumerable, AccessControl)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }

    function _update(
        address to,
        uint256 tokenId,
        address auth
    )
        internal
        virtual
        override(ERC721, ERC721Enumerable, ERC721Pausable)
        whenNotPaused
        notBlacklisted(msg.sender)
        notBlacklisted(to)
        notBlacklistedId(tokenId)
        returns (address)
    {
        _nonces[tokenId]++;
        return super._update(to, tokenId, auth);
    }

    function _increaseBalance(
        address account,
        uint128 amount
    ) internal virtual override(ERC721, ERC721Enumerable) {
        super._increaseBalance(account, amount);
    }

    // blacklisting part PAUSER_ROLE

    event Blacklisted(address indexed _account);
    event BlacklistedId(uint256 indexed _tokenId);
    event UnBlacklisted(address indexed _account);
    event UnBlacklistedId(uint256 indexed _tokenId);

    /**
     * @dev Throws if argument account is blacklisted
     * @param _account The address to check
     */
    modifier notBlacklisted(address _account) {
        require(
            !blacklisted[_account],
            "Blacklistable: account is blacklisted"
        );
        _;
    }

    /**
     * @dev Throws if argument tokenId is blacklisted
     * @param _tokenId The address to check
     */
    modifier notBlacklistedId(uint256 _tokenId) {
        require(
            !blacklistedId[_tokenId],
            "Blacklistable: tokenId is blacklisted"
        );
        _;
    }

    /**
     * @dev Checks if account is blacklisted
     * @param _account The address to check
     */
    function isBlacklisted(address _account) external view returns (bool) {
        return blacklisted[_account];
    }

    /**
     * @dev Checks if tokenId is blacklisted
     * @param _tokenId The address to check
     */
    function isBlacklistedId(uint256 _tokenId) external view returns (bool) {
        return blacklistedId[_tokenId];
    }

    /**
     * @dev Adds account to blacklist
     * @param _account The address to blacklist
     */
    function blacklist(address _account) external onlyRole(BLACKLISTER_ROLE) {
        blacklisted[_account] = true;
        emit Blacklisted(_account);
    }

    /**
     * @dev Adds tokenId to blacklist
     * @param _tokenId The address to blacklist
     */
    function blacklist(uint256 _tokenId) external onlyRole(BLACKLISTER_ROLE) {
        blacklistedId[_tokenId] = true;
        emit BlacklistedId(_tokenId);
    }

    /**
     * @dev Removes account from blacklist
     * @param _account The address to remove from the blacklist
     */
    function unBlacklist(address _account) external onlyRole(BLACKLISTER_ROLE) {
        blacklisted[_account] = false;
        emit UnBlacklisted(_account);
    }

    /**
     * @dev Removes tokenId from blacklist
     * @param _tokenId The address to remove from the blacklist
     */
    function unBlacklist(uint256 _tokenId) external onlyRole(BLACKLISTER_ROLE) {
        blacklistedId[_tokenId] = false;
        emit UnBlacklistedId(_tokenId);
    }
}
