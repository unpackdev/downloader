// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.17;

import "./ERC721.sol";
import "./AccessControl.sol";
import "./ERC165.sol";
import "./ReentrancyGuard.sol";
import "./Strings.sol";
import "./IERC2981.sol";
import "./IRAIR721_Contract.sol";

/// @title  Extended ERC721 contract for the RAIR system
/// @notice Uses ERC2981 and ERC165 for standard royalty info
/// @notice Uses AccessControl for the minting mechanisms
/// @author Juan M. Sanchez M.
/// @dev    Ideally generated by a RAIR Token Factory
contract RAIR721_Contract is
    IERC2981,
    ERC165,
    IRAIR721_Contract,
    ERC721,
    AccessControl,
    ReentrancyGuard
{
    // Allows the conversion of numbers to strings (used in the token URI functions)
    using Strings for uint;

    // Auxiliary struct used to avoid Stack too deep errors
    struct rangeData {
        uint rangeLength;
        uint price;
        uint tokensAllowed;
        uint lockedTokens;
        string name;
    }

    mapping(uint => uint) public tokenToRange;
    mapping(uint => uint) public rangeToCollection;

    //URIs
    mapping(uint => string) internal uniqueTokenURI;
    mapping(uint => string) internal collectionURI;
    mapping(uint => string) internal rangeURI;
    mapping(uint => bool) internal appendTokenIndexToCollectionURI;
    mapping(uint => bool) internal appendTokenIndexToRangeURI;

    string internal baseURI;
    string internal contractMetadataURI;

    bool appendTokenIndexToContractURI;
    bool _requireTrader;

    range[] private _ranges;
    collection[] private _collections;

    // Roles
    bytes32 public constant MINTER = keccak256("MINTER");
    bytes32 public constant TRADER = keccak256("TRADER");

    address public creatorAddress;
    address public factory;
    string private _symbol;
    uint16 private _royaltyFee;
    string private _metadataExtension;

    /// @notice	Makes sure the collection exists before doing changes to it
    /// @param	collectionID	Collection to verify
    modifier collectionExists(uint collectionID) {
        require(
            _collections.length > collectionID,
            "RAIR ERC721: Collection does not exist"
        );
        _;
    }

    /// @notice	Makes sure the range exists
    /// @param	rangeIndex	Range to verify
    modifier rangeExists(uint rangeIndex) {
        require(
            _ranges.length > rangeIndex,
            "RAIR ERC721: Range does not exist"
        );
        _;
    }

    /// @notice	Sets up the role system from AccessControl
    /// @dev	RAIR is the default symbol for the token, this can be updated with setTokenSymbol
    /// @param	_contractName	Name of the contract
    /// @param	_creatorAddress	Address of the creator of the contract
    constructor(string memory _contractName, address _creatorAddress)
        ERC721(_contractName, "RAIR")
    {
        factory = msg.sender;
        _symbol = "RAIR";
        _royaltyFee = 30000;
        _setupRole(DEFAULT_ADMIN_ROLE, _creatorAddress);
        _setupRole(MINTER, _creatorAddress);
        _setupRole(TRADER, _creatorAddress);
        _requireTrader = false;
        creatorAddress = _creatorAddress;
    }

    /// @notice  Updates the metadata extension added at the end of all tokens
    /// @dev     Must include the . before the extension
    /// @param extension     Extension to be added at the end of all contract wide tokens
    function setMetadataExtension(string calldata extension) external onlyRole(DEFAULT_ADMIN_ROLE) {
        require(bytes(extension)[0] == '.', "RAIR ERC721: Extension must start with a '.'");
        _metadataExtension = extension;
        emit UpdatedURIExtension(_metadataExtension);
    }

    /// @notice 	Transfers the ownership of a contract to a new address
    /// @param 	newOwner 	Address of the new owner of the contract
    function transferOwnership(address newOwner)
        public
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        _grantRole(DEFAULT_ADMIN_ROLE, newOwner);
        creatorAddress = newOwner;
        renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    /// @notice 	Updates the royalty fee used by the 2981 standard
    /// @param 	newRoyalty 	Percentage that should be sent to the owner of the contract (3 decimals, 30% = 30000)
    function setRoyaltyFee(uint16 newRoyalty)
        public
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        _royaltyFee = newRoyalty;
    }

    /// @notice 	Updates the token symbol
    /// @param 	newSymbol 	New symbol to be returned from the symbol() function
    function setTokenSymbol(string calldata newSymbol)
        external
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        _symbol = newSymbol;
    }

    /// @notice 	Returns the symbol for this contract
    /// @dev 	By default, the symbol is RAIR
    function symbol() public view override returns (string memory) {
        return _symbol;
    }

    /// @notice 	Enables or disables the requirement of the TRADER role to do NFT transfers
    function requireTraderRole(bool required) public onlyRole(DEFAULT_ADMIN_ROLE) {
        _requireTrader = required;
    }

    /// @notice 	Emits an event that OpenSea recognizes as a signal to never update the metadata for this token
    /// @dev 	The metadata can still be updated, but OpenSea won't update it on their platform
    /// @param 	tokenId 	Identifier of the token to be frozen
    function freezeMetadataOpensea(uint tokenId) public onlyRole(DEFAULT_ADMIN_ROLE) {
        emit PermanentURI(tokenURI(tokenId), tokenId);
    }

    /// @notice 	Updates the URL that OpenSea uses to fetch the contract's metadata
    /// @param 	newURI 	URL of the metadata for the token
    function setContractURI(string calldata newURI)
        external
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        contractMetadataURI = newURI;
        emit UpdatedContractURI(newURI);
    }

    /// @notice 	Returns the metadata for the entire contract
    /// @dev 	Not the NFTs, this is information about the contract itself
    function contractURI() public view returns (string memory) {
        return contractMetadataURI;
    }

    /// @notice	Sets the Base URI for ALL tokens
    /// @dev	Can be overriden by the collection-wide URI or the specific token URI
    /// @param	newURI	URI to be used
    function setBaseURI(string calldata newURI, bool appendTokenIndex)
        external
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        baseURI = newURI;
        appendTokenIndexToContractURI = appendTokenIndex;
        emit UpdatedBaseURI(newURI, appendTokenIndex, _metadataExtension);
    }

    /// @notice	Overridden function from the ERC721 contract that returns our
    ///			variable base URI instead of the hardcoded URI
    function _baseURI() internal view override(ERC721) returns (string memory) {
        return baseURI;
    }

    /// @notice	Updates the unique URI of a token, but in a single transaction
    /// @dev	Uses the single function so it also emits an event
    /// @param	tokenIds	Token Indexes that will be given an URI
    /// @param	newURIs		New URIs to be set
    function setUniqueURIBatch(
        uint[] calldata tokenIds,
        string[] calldata newURIs
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        require(
            tokenIds.length == newURIs.length,
            "RAIR ERC721: Token IDs and URIs should have the same length"
        );
        for (uint i = 0; i < tokenIds.length; i++) {
            setUniqueURI(tokenIds[i], newURIs[i]);
        }
    }

    /// @notice	Gives an individual token an unique URI
    /// @dev	Emits an event so there's provenance
    /// @param	tokenId	Token Index that will be given an URI
    /// @param	newURI	New URI to be given
    function setUniqueURI(uint tokenId, string calldata newURI)
        public
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        uniqueTokenURI[tokenId] = newURI;
        emit UpdatedTokenURI(tokenId, newURI);
    }

    /// @notice	Gives all tokens within a range a specific URI
    /// @dev	Emits an event so there's provenance
    /// @param	rangeId	Token Index that will be given an URI
    /// @param	newURI		    New URI to be given
    function setRangeURI(
        uint rangeId,
        string calldata newURI,
        bool appendTokenIndex
    ) public onlyRole(DEFAULT_ADMIN_ROLE) {
        rangeURI[rangeId] = newURI;
        appendTokenIndexToRangeURI[rangeId] = appendTokenIndex;
        emit UpdatedRangeURI(rangeId, newURI, appendTokenIndex, _metadataExtension);
    }

    /// @notice	Gives all tokens within a collection a specific URI
    /// @dev	Emits an event so there's provenance
    /// @param	collectionId	Token Index that will be given an URI
    /// @param	newURI		New URI to be given
    function setCollectionURI(
        uint collectionId,
        string calldata newURI,
        bool appendTokenIndex
    ) public onlyRole(DEFAULT_ADMIN_ROLE) {
        collectionURI[collectionId] = newURI;
        appendTokenIndexToCollectionURI[collectionId] = appendTokenIndex;
        emit UpdatedProductURI(collectionId, newURI, appendTokenIndex, _metadataExtension);
    }

	function tokenToCollection(uint tokenId) internal view returns (uint) {
		return rangeToCollection[tokenToRange[tokenId]];
	}

    /// @notice	Returns a token's URI
    /// @dev	Will return unique token URI or product URI or contract URI
    /// @param	tokenId		Token Index to look for
    function tokenURI(uint tokenId)
        public
        view
        override(ERC721)
        returns (string memory)
    {
        // Unique token URI
        string memory URI = uniqueTokenURI[tokenId];
        if (bytes(URI).length > 0) {
            return URI;
        }

        // Range wide URI
        URI = rangeURI[tokenToRange[tokenId]];
        if (bytes(URI).length > 0) {
            if (appendTokenIndexToRangeURI[tokenToRange[tokenId]]) {
                return
                    string(
                        abi.encodePacked(
                            URI,
                            tokenToCollectionIndex(tokenId).toString(),
                            _metadataExtension
                        )
                    );
            }
            return URI;
        }

        // Collection wide URI
        URI = collectionURI[tokenToCollection(tokenId)];
        if (bytes(URI).length > 0) {
            if (appendTokenIndexToCollectionURI[tokenToCollection(tokenId)]) {
                return
                    string(
                        abi.encodePacked(
                            URI,
                            tokenToCollectionIndex(tokenId).toString(),
                            _metadataExtension
                        )
                    );
            }
            return URI;
        }

        URI = baseURI;
        if (appendTokenIndexToContractURI) {
            return
                string(
                    abi.encodePacked(
                        URI,
                        tokenId.toString(),
                        _metadataExtension
                    )
                );
        }
        return URI;
    }

    /// @notice	Creates a subdivision of tokens inside the contract (collection is the same as product)
    /// @dev	The collections are generated sequentially, there can be no gaps between collections
    /// @param	_collectionName 	Name of the collection
    /// @param	_copies				Amount of tokens inside the collection
    function createProduct(string memory _collectionName, uint _copies)
        public
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        uint lastTokenFromPreviousCollection;
        if (_collections.length != 0) {
            lastTokenFromPreviousCollection =
                _collections[_collections.length - 1].endingToken +
                1;
        }

        collection storage newCollection = _collections.push();

        newCollection.startingToken = lastTokenFromPreviousCollection;
        // -1 because we include the initial token
        newCollection.endingToken = newCollection.startingToken + _copies - 1;
        newCollection.name = string(_collectionName);

        emit CreatedCollection(
            _collections.length - 1,
            _collectionName,
            lastTokenFromPreviousCollection,
            _copies
        );
    }

    /// @notice This function will create ranges in batches
    /// @dev 	There isn't any gas savings here
    /// @param	collectionId	Contains the identification for the product
    /// @param	data 			An array with the data for all the ranges that we want to implement
    function createRangeBatch(uint collectionId, rangeData[] calldata data)
        external
        onlyRole(DEFAULT_ADMIN_ROLE)
        collectionExists(collectionId)
    {
        require(data.length > 0, "RAIR ERC721: Empty array");
        collection storage selectedCollection = _collections[collectionId];
        for (uint i = 0; i < data.length; i++) {
            _createRange(
                collectionId,
                data[i].rangeLength,
                data[i].tokensAllowed,
                data[i].lockedTokens,
                data[i].price,
                data[i].name,
                selectedCollection
            );
        }
    }

    /// @notice Creates a range inside a collection
    /// @dev 	This function is only available to an account with the `DEFAULT_ADMIN_ROLE` role
    /// @dev 	This function require thar the collection ID match a valid collection
    /// @param	collectionId	Contains the identification for the product
    /// @param	rangeLength		Number of tokens to be contained in this new range
    /// @param 	price 			Contains the selling price for the range of NFT
    /// @param 	tokensAllowed 	Contains all the allowed NFT tokens in the range that are available for sell
    /// @param 	lockedTokens 	Contains all the NFT tokens in the range that are unavailable for sell
    /// @param 	name 			Contains the name for the created NFT collection range
    function createRange(
        uint collectionId,
        uint rangeLength,
        uint price,
        uint tokensAllowed,
        uint lockedTokens,
        string calldata name
    ) external onlyRole(DEFAULT_ADMIN_ROLE) collectionExists(collectionId) {
        collection storage selectedCollection = _collections[collectionId];
        _createRange(
            collectionId,
            rangeLength,
            price,
            tokensAllowed,
            lockedTokens,
            name,
            selectedCollection
        );
    }

    /// @notice This is a internal function that will create the NFT range if the requirements are met
    /// @param	collectionIndex		Collection identifier
    /// @param	_rangeLength		Number of NFTs in the range
    /// @param 	_allowedTokens 		Contains all the allowed NFT tokens in the range that are available for sell
    /// @param 	_lockedTokens 		Contains all the NFT tokens in the range that are unavailable for sell
    /// @param 	_price 				Contains the selling price for the range of NFT
    /// @param 	_name 				Contains the name for the created NFT collection range
    function _createRange(
        uint collectionIndex,
        uint _rangeLength,
        uint _allowedTokens,
        uint _lockedTokens,
        uint _price,
        string calldata _name,
        collection storage selectedCollection
    ) internal {
        uint nextSequentialToken = selectedCollection.startingToken;
        if (selectedCollection.rangeList.length > 0) {
            nextSequentialToken = (
                _ranges[
                    selectedCollection.rangeList[
                        selectedCollection.rangeList.length - 1
                    ]
                ]
            ).rangeEnd;
            nextSequentialToken++;
        }

        // -1 because it includes the first token inside the range
        require(
            nextSequentialToken + _rangeLength - 1 <=
                selectedCollection.endingToken,
            "RAIR ERC721: Invalid range length"
        );
        require(
            _allowedTokens <= _rangeLength,
            "RAIR ERC721: Number of allowed tokens must be less or equal than the range's length"
        );
        require(
            _lockedTokens <= _rangeLength,
            "RAIR ERC721: Number of locked tokens must be less or equal than the range's length"
        );
        require(_price == 0 || _price >= 100, "RAIR ERC721: Minimum price for a range is 100");

        range storage newRange = _ranges.push();

        newRange.rangeStart = nextSequentialToken;
        newRange.rangeEnd = nextSequentialToken + _rangeLength - 1;
        newRange.mintableTokens = _rangeLength;
        newRange.tokensAllowed = _allowedTokens;
        newRange.lockedTokens = _lockedTokens;
        newRange.rangePrice = _price;
        newRange.rangeName = _name;

        rangeToCollection[_ranges.length - 1] = collectionIndex;

        // No need to initialize minted tokens, the default value is 0

        selectedCollection.rangeList.push(_ranges.length - 1);

        emit CreatedRange(
            collectionIndex,
            newRange.rangeStart,
            newRange.rangeEnd,
            newRange.rangePrice,
            newRange.tokensAllowed,
            newRange.lockedTokens,
            newRange.rangeName,
            _ranges.length - 1
        );
    }

    /// @notice	Updates a range
    /// @dev 	Because they are sequential, the length of the range can't be modified
    /// @param	rangeId 			Index of the collection on the contract
    /// @param	name 				Name of the range
    /// @param	price_ 				Price for the tokens in the range
    /// @param	tokensAllowed_ 		Number of tokens allowed to be sold
    /// @param	lockedTokens_ 		Number of tokens that have to be minted in order to unlock transfers
    function updateRange(
        uint rangeId,
        string memory name,
        uint price_,
        uint tokensAllowed_,
        uint lockedTokens_
    ) external onlyRole(DEFAULT_ADMIN_ROLE) rangeExists(rangeId) nonReentrant {
        range storage selectedRange = _ranges[rangeId];
        require(price_ == 0 || price_ >= 100, "RAIR ERC721: Range price must be greater or equal than 100");
        require(
            tokensAllowed_ <= selectedRange.mintableTokens,
            "RAIR ERC721: Tokens allowed should be less than the number of mintable tokens"
        );
        require(
            lockedTokens_ <= selectedRange.mintableTokens,
            "RAIR ERC721: Locked tokens should be less than the number of mintable tokens"
        );

        selectedRange.tokensAllowed = tokensAllowed_;
        if (lockedTokens_ > 0) {
            emit TradingLocked(
                rangeId,
                selectedRange.rangeStart,
                selectedRange.rangeEnd,
                lockedTokens_
            );
        }
        selectedRange.lockedTokens = lockedTokens_;
        selectedRange.rangePrice = price_;
        selectedRange.rangeName = name;

        emit UpdatedRange(rangeId, name, price_, tokensAllowed_, lockedTokens_);
    }

    /// @notice	Returns the number of collections on the contract
    /// @dev	Use with get collection to list all of the collections
    function getCollectionCount()
        external
        view
        override(IRAIR721_Contract)
        returns (uint)
    {
        return _collections.length;
    }

    /// @notice	Returns information about a collection
    /// @param	collectionIndex	Index of the collection
    function getCollection(uint collectionIndex)
        external
        view
        override(IRAIR721_Contract)
        returns (collection memory)
    {
        return _collections[collectionIndex];
    }

    /// @notice	Translates the unique index of an NFT to it's collection index
    /// @param	token	Token ID to find
    function tokenToCollectionIndex(uint token)
        public
        view
        returns (uint tokenIndex)
    {
        return token - _collections[tokenToCollection(token)].startingToken;
    }

    /// @notice	Finds the first token inside a collection that doesn't have an owner
    /// @param	collectionID	Index of the collection to search
    /// @param	startingIndex	Starting token for the search
    /// @param	endingIndex		Ending token for the search
    function getNextSequentialIndex(
        uint collectionID,
        uint startingIndex,
        uint endingIndex
    ) public view collectionExists(collectionID) returns (uint nextIndex) {
        collection memory currentCollection = _collections[collectionID];
        return
            _getNextSequentialIndexInRange(
                currentCollection.startingToken + startingIndex,
                currentCollection.startingToken + endingIndex
            );
    }

    /// @notice		Loops through a range of tokens and returns the first token without an owner
    /// @dev 		Loops are expensive in solidity, do not use this in a gas-consuming function
    /// @param 		startingToken 	Starting token for the search
    /// @param 		endingToken 	Ending token for the search
    function _getNextSequentialIndexInRange(
        uint startingToken,
        uint endingToken
    ) internal view returns (uint nextIndex) {
        for (nextIndex = startingToken; nextIndex <= endingToken; nextIndex++) {
            if (!_exists(nextIndex)) {
                break;
            }
        }
        require(
            startingToken <= nextIndex && nextIndex <= endingToken,
            "RAIR ERC721: There are no available tokens in this range."
        );
    }

    /// @notice This functions allow us to check the information of the range
    /// @dev 	This function requires that the rangeIndex_ points to an existing range
    /// @param	rangeIndex		Identification of the range to verify
    /// @return data 			Information about the range
    /// @return productIndex 	Contains the index of the product in the range
    function rangeInfo(uint rangeIndex)
        external
        view
        override(IRAIR721_Contract)
        rangeExists(rangeIndex)
        returns (range memory data, uint productIndex)
    {
        data = _ranges[rangeIndex];
        productIndex = rangeToCollection[rangeIndex];
    }

    /// @notice	Verifies if the range where a token is located is locked or not
    /// @param	_tokenId	Index of the token to search
    function isTokenLocked(uint256 _tokenId) public view returns (bool) {
        return _ranges[tokenToRange[_tokenId]].lockedTokens > 0;
    }

	function mintFromRange(
		address buyerAddress,
        uint rangeIndex,
        uint indexInCollection
	) 
        external
		override(IRAIR721_Contract)
        onlyRole(MINTER)
        rangeExists(rangeIndex)
	{
		_mintFromRange(
			buyerAddress,
			rangeIndex,
			indexInCollection,
			1
		);
	}

    /// @notice	Loops over the user's tokens looking for one that belongs to a product and a specific range
	/// @dev	Loops are expensive in solidity, so don't use this in a function that requires gas
	/// @param	userAddress			User to search
	/// @param	collectionIndex		Product to search
	/// @param	startingToken		Product to search
	/// @param	endingToken			Product to search
	function hasTokenInProduct(
        address userAddress,
        uint collectionIndex,
        uint startingToken,
        uint endingToken
    )
        collectionExists(collectionIndex)
        public
        view
        returns (bool)
    {
		collection memory aux = _collections[collectionIndex];
        require(
            aux.endingToken - aux.startingToken + 1 > startingToken &&
            aux.endingToken - aux.startingToken + 1 > endingToken, 
            "RAIR ERC721: Invalid parameters"
        );
		if (aux.endingToken != 0) {
            uint end = aux.startingToken + endingToken;
			for (uint i = aux.startingToken + startingToken; i < end; i++) {
				if (_exists(i) && ownerOf(i) == userAddress) {
                    return true;
                }
			}
		}
		return false;
	}

    /// @notice	Mints a specific token within a range
    /// @dev	Has to be used alongside getNextSequentialIndex to simulate a sequential minting
    /// @dev	Anyone that wants a specific token just has to call this function with the index they want
    /// @param	buyerAddress		Address of the new token's owner
    /// @param	rangeIndex			Index of the range
    /// @param	indexInCollection	Index of the token inside the collection
    function _mintFromRange(
        address buyerAddress,
        uint rangeIndex,
        uint indexInCollection,
		uint tokenQuantity
    )
        internal
    {
        range storage selectedRange = _ranges[rangeIndex];
        collection storage selectedCollection = _collections[
            rangeToCollection[rangeIndex]
        ];

        require(
            selectedRange.tokensAllowed >= tokenQuantity,
            "RAIR ERC721: Not allowed to mint that many tokens"
        );
        require(
            selectedRange.rangeStart <=
                selectedCollection.startingToken + indexInCollection &&
                selectedCollection.startingToken + indexInCollection + tokenQuantity - 1 <=
                selectedRange.rangeEnd,
            "RAIR ERC721: Tried to mint token outside of range"
        );

        selectedRange.tokensAllowed -= tokenQuantity;

        if (selectedRange.lockedTokens > 0) {
			if (selectedRange.lockedTokens <= tokenQuantity) {
	            selectedRange.lockedTokens = 0;
			} else {
	            selectedRange.lockedTokens -= tokenQuantity;
			}
            if (selectedRange.lockedTokens == 0) {
                emit TradingUnlocked(
                    rangeIndex,
                    selectedRange.rangeStart,
                    selectedRange.rangeEnd
                );
            }
        }

		for (; tokenQuantity > 0; tokenQuantity--) {
			_safeMint(
				buyerAddress,
				selectedCollection.startingToken + indexInCollection + tokenQuantity - 1
			);
			tokenToRange[
				selectedCollection.startingToken + indexInCollection + tokenQuantity - 1
			] = rangeIndex;
		}
    }

    /// @notice Returns the fee for the NFT sale
    /// @param _tokenId - the NFT asset queried for royalty information
    /// @param _salePrice - the sale price of the NFT asset specified by _tokenId
    /// @return receiver - address of who should be sent the royalty payment
    /// @return royaltyAmount - the royalty payment amount for _salePrice sale price
    function royaltyInfo(uint256 _tokenId, uint256 _salePrice)
        external
        view
        override(IRAIR721_Contract, IERC2981)
        returns (address receiver, uint256 royaltyAmount)
    {
        require(
            _exists(_tokenId),
            "RAIR ERC721: Royalty query for a non-existing token"
        );
        return (creatorAddress, (_salePrice * _royaltyFee) / 100000);
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(IERC165, ERC165, AccessControl, ERC721, IERC2981)
        returns (bool)
    {
        return
            interfaceId == type(IERC2981).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /// @notice Hook being called before every transfer
    /// @dev	Locks and the requirement of the TRADER role happe here
    /// @param	_from		Token's original owner
    /// @param	_to			Token's new owner
    /// @param	_tokenId	Token's ID
    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _tokenId
    ) internal virtual override(ERC721) nonReentrant{
        // If the transfer isn't to mint (from = address(0)) and it's not a burn (to = address(0))
        if (_from != address(0) && _to != address(0)) {
            //
            if (
                _ranges.length > 0 &&
                rangeToCollection[tokenToRange[_tokenId]] ==
                tokenToCollection(_tokenId)
            ) {
                require(
                    _ranges[tokenToRange[_tokenId]].lockedTokens == 0,
                    "RAIR ERC721: Transfers for this range are currently locked"
                );
            }
            if (_requireTrader) {
                _checkRole(TRADER, msg.sender);
            }
        }
        super._beforeTokenTransfer(_from, _to, _tokenId);
    }
}
