/* SPDX-License-Identifier: MIT


       []           [][][][][]           []          [[][][][][]]
      [][]         [][]    [][]         [][]        [][]]    [[][]
     [][][]        [][]                [][][]       [][]      [][]
    [][  ][]       [][][][][]]        [][  ][]      [][]          
   [][]  [][]       [[][][][][]      [][]  [][]     [][]          
  [][][][][][]             [][]     [][][][][][]    [][]      [][]
 [][]      [][]    [][]    [][]    [][]      [][]   [][]]    [[][]
[][]        [][]    [][][][][]    [][]        [][]   [[][][][][]] 



* Generated by Cyberscape Labs
* Email cyberscape.eth@gmail.com for your NFT launch needs


*/ 


pragma solidity ^0.8.13; 

import "./Ownable.sol";
import "./Strings.sol";
import "./ReentrancyGuard.sol";
import "./MerkleProof.sol";
import "./ERC721A.sol";


/*//////////////////////////////////////
            CUSTOM ERRORS
//////////////////////////////////////*/
/// @notice Thrown when completing transaction will exceed collection supply
error ExceededMintSupply();
/// @notice Thrown when transaction sender is not on whitelist
error NotOnMintList();
/// @notice Thrown when the attempted sale is not actve
error SaleNotActive();
/// @notice Thrown when the message value is less than the required amount
error ValueTooLow();
/// @notice Thrown when the amount minted exceeds max allowed per txn
error MintingTooMany();
/// @notice Thrown when the input address is 0
error ZeroAddress();
/// @notice Thrown when input data does not equal what was required
error InvalidData();
/// @notice Thrown when input arrays for a function are not the same length
error NonEqualArrays();


/**
    @title Anti Social Anime Club NFT
    @author @0x_digitalnomad with Cyberscape Labs
*/

contract AsacNFT is ERC721A, Ownable, ReentrancyGuard { 

    using Strings for uint256;

    /*//////////////////////////////////////
                STATE VARIABLES
    //////////////////////////////////////*/
    enum MintStatus {
        CLOSED,
        PRESALE,
        PUBLIC,
        SOLDOUT
    }
    MintStatus public mintStatus = MintStatus.CLOSED;

    uint256 public collectionSize;
    uint256 public maxAvailableSupply;
    uint256 public reserveSupply;
    uint256 public maxPerTxn;
    uint256 public claimable;
    uint256 public OGPrice      = 0.06 ether;
    uint256 public presalePrice = 0.07 ether;
    uint256 public salePrice    = 0.09 ether;
    uint256 private devMintCount;
    uint256 private mintData;
    string private baseURI;
    string private unrevealedURI;
    bool public revealed = false;
    bool public claimEnabled = false;

    mapping(address => bool) private whiteList;
    mapping(address => bool) private OGList;
    mapping(address => uint256) private claimList;
    
    bytes32 public merkleRoot = 
        0xabdfb9ba2690ab68ec73f7a8567586413293817709a77d893cf14d357aee0e8a;

    address private devWallet;


    /*//////////////////////////////////////
                EVENTS
    //////////////////////////////////////*/
    event ChangeBaseURI(string _baseURI);
    event UpdateSaleState(string _sale);
    event Mint(address _minter, uint256 _amount, string _type);

    /*//////////////////////////////////////
                CONSTRUCTOR
    //////////////////////////////////////*/
    constructor(
        uint collectionSize_,
        uint reserveSupply_,
        uint maxTxn_,
        uint mintData_,
        address devWallet_,
        address[] memory ogList_,
        address[] memory claimList_,
        uint256[] memory amount_
    ) ERC721A("Anti Social Anime Club", "ASAC") {
        collectionSize = collectionSize_;
        reserveSupply = reserveSupply_;
        maxPerTxn = maxTxn_;
        mintData = mintData_;
        devWallet = devWallet_;

        if(claimList_.length != amount_.length) revert NonEqualArrays();

        for(uint i = 0; i < claimList_.length; i++) {
            claimList[claimList_[i]] = amount_[i];
            claimable += amount_[i];
        }

        for(uint i = 0; i < ogList_.length; i++) {
            OGList[ogList_[i]] = true;
        }

        maxAvailableSupply = collectionSize - reserveSupply - claimable;
    }

    /*//////////////////////////////////////
                MODIFIERS
    //////////////////////////////////////*/
    modifier callerIsUser() {
        require(tx.origin == msg.sender, "Caller is another contract");
        _;
    }

    /*//////////////////////////////////////
                MINTING FUNCTIONS
    //////////////////////////////////////*/

    /**
        Dev mint function to reserve a supply for giveaways, collaborations, and marketing
        @param _address The address to mint to
        @param _amount The amount to mint
    */
    function devMint(address _address, uint256 _amount)
        external
        onlyOwner
    {
        if (_address == address(0)) revert ZeroAddress();
        if (_amount + totalSupply() > collectionSize) revert ExceededMintSupply();
        
        if (reserveSupply > 0) {
            if (_amount > reserveSupply) {
                maxAvailableSupply += reserveSupply;
                reserveSupply = 0;
            } else {
                maxAvailableSupply += _amount;
                reserveSupply -= _amount;
            }

            if (maxAvailableSupply > collectionSize) {
                maxAvailableSupply = collectionSize;
                reserveSupply = 0;
            }
        }

        _safeMint(_address, _amount);
        emit Mint(_address, _amount, "Dev");
    }

    /**
        Presale mint function using merkle proofs
        @param _proof An array of bytes representing the merkle proof for the sender's address
        @param _amount The amount to mint
    */
    function mintPresale(bytes32[] memory _proof, uint256 _amount)
        external
        payable
        callerIsUser
        nonReentrant
    {
        if (mintStatus != MintStatus.PRESALE) revert SaleNotActive();
        if (_amount > maxPerTxn) revert MintingTooMany();
        if (_amount + totalSupply() > maxAvailableSupply) revert ExceededMintSupply();
        if (!MerkleProof.verify(_proof, merkleRoot, keccak256(abi.encodePacked(msg.sender)))) revert NotOnMintList();
        
        if (OGList[msg.sender]) {
            if (msg.value != OGPrice * _amount) revert ValueTooLow();

            _safeMint(msg.sender, _amount);
            emit Mint(msg.sender, _amount, "OG");
        } else {
            if (msg.value != presalePrice * _amount) revert ValueTooLow();

            _safeMint(msg.sender, _amount);
            emit Mint(msg.sender, _amount, "Presale");
        }
    }

    /**
        Public minting function and presale backup
        @param _amount The amount to mint
        @param _data Private data required to mint
    */
    function mint(uint256 _amount, uint256 _data)
        external
        payable
        callerIsUser
        nonReentrant
    {
        if (mintStatus != MintStatus.PRESALE && mintStatus != MintStatus.PUBLIC) revert SaleNotActive();
        if (_data != mintData) revert InvalidData();
        if (_amount > maxPerTxn) revert MintingTooMany();
        if (_amount + totalSupply() > maxAvailableSupply) revert ExceededMintSupply();

        if (mintStatus == MintStatus.PRESALE) {
            if (OGList[msg.sender]) {
                if (msg.value != OGPrice * _amount) revert ValueTooLow();

                _safeMint(msg.sender, _amount);
                emit Mint(msg.sender, _amount, "OG");

            } else {
                if (!whiteList[msg.sender]) revert NotOnMintList();
                if (msg.value != presalePrice * _amount) revert ValueTooLow();

                _safeMint(msg.sender, _amount);
                emit Mint(msg.sender, _amount, "Presale");
            }

        } else if (mintStatus == MintStatus.PUBLIC){
            if (msg.value != salePrice * _amount) revert ValueTooLow();

            _safeMint(msg.sender, _amount);
            emit Mint(msg.sender, _amount, "Public");

        }
    }

    /**
        Claim tokens up to amount provided in claimList
        @param _amount The amount to claim
    */
    function claim(uint256 _amount)
        external
        callerIsUser
        nonReentrant
    {
        if (claimEnabled == false) revert SaleNotActive();
        if (claimList[msg.sender] < 1) revert NotOnMintList();
        if (_amount > claimList[msg.sender]) revert MintingTooMany();
        if (_amount + totalSupply() > maxAvailableSupply) revert ExceededMintSupply();

        claimList[msg.sender] -= _amount;
        claimable -= _amount;
        _safeMint(msg.sender, _amount);
        emit Mint(msg.sender, _amount, "Free Claim");
    }

    
    /*//////////////////////////////////////
                SETTERS
    //////////////////////////////////////*/
    /**
        Set the URI for preview image prior to reveal
    */
    function setUnrevealedURI(string calldata _unrevealedURI)
        external
        onlyOwner
    {
        unrevealedURI = _unrevealedURI;
    }

    /**
        Set the base URI for all tokens post reveal
    */
    function setBaseURI(string calldata _tokenBaseURI)
        external
        onlyOwner
    {
        baseURI = _tokenBaseURI;
        emit ChangeBaseURI(_tokenBaseURI);
    }

    /**
        Update the price for the public sale or presale.
        @param _saleType Either "presale" for presalePrice or "public" for salePrice
        @param _price The new price in gwei
    */
    function setPrice(string calldata _saleType, uint256 _price)
        external
        onlyOwner
    {
        if (keccak256(abi.encodePacked(_saleType)) == keccak256(abi.encodePacked("presale"))) {
            presalePrice = _price;
        } else if (keccak256(abi.encodePacked(_saleType)) == keccak256(abi.encodePacked("public"))) {
            salePrice = _price;
        } else if (keccak256(abi.encodePacked(_saleType)) == keccak256(abi.encodePacked("OG"))) {
            OGPrice = _price;
        }else {
            revert InvalidData();
        }
    }

    function setMaxTxn(uint256 _max)
        external
        onlyOwner
    {
        maxPerTxn = _max;
    }

    function setMintData(uint256 _data)
        external
        onlyOwner
    {
        mintData = _data;
    }

    function setMerkleRoot(bytes32 _merkleRoot)
        external
        onlyOwner
    {
        merkleRoot = _merkleRoot;
    }

    /*//////////////////////////////////////
                GETTERS
    //////////////////////////////////////*/
    function tokenURI(uint256 tokenId)
        public
        view
        virtual
        override
        returns (string memory)
    {
        require(_exists(tokenId), "URI query for nonexistent token");
        
        if (revealed == false) {
            return unrevealedURI;
        } else {
            return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), '.json')) : '';
        }
    }

    function getMintStatus()
        external
        view
        returns(string memory)
    {
        if (mintStatus == MintStatus.CLOSED) {
            return "Closed";
        } else if (mintStatus == MintStatus.PRESALE){
            return "Presale";
        } else if (mintStatus == MintStatus.PUBLIC) {
            return "Public Sale";
        } else { //mintStatus == MintStatus.SoldOut
            return "Sold Out";
        }
    }

    function getWhiteList(address _addr)
        external
        view
        returns(bool)
    {
        return whiteList[_addr];
    }

    function getOGList(address _addr)
        external
        view
        returns(bool)
    {
        return OGList[_addr];
    }

    function getClaimList(address _addr)
        external
        view
        returns(uint256)
    {
        return claimList[_addr];
    }

    /*//////////////////////////////////////
                MISC
    //////////////////////////////////////*/
    function addToWhiteList(string calldata _listType, address[] calldata _addresses)
        external
        onlyOwner
    {
        if (keccak256(abi.encodePacked(_listType)) == keccak256(abi.encodePacked("OG"))) {
            for (uint i = 0; i < _addresses.length; i++) {
                OGList[_addresses[i]] = true;
            }
        } else if (keccak256(abi.encodePacked(_listType)) == keccak256(abi.encodePacked("presale"))) {
            for (uint i = 0; i < _addresses.length; i++) {
                whiteList[_addresses[i]] = true;
            }
        } else {
            revert InvalidData();
        }
    }

    function removeFromWhiteList(string calldata _listType, address[] calldata _addresses)
        external
        onlyOwner
    {
        if (keccak256(abi.encodePacked(_listType)) == keccak256(abi.encodePacked("OG"))) {
            for (uint i = 0; i < _addresses.length; i++) {
                OGList[_addresses[i]] = false;
            }
        } else if (keccak256(abi.encodePacked(_listType)) == keccak256(abi.encodePacked("presale"))) {
            for (uint i = 0; i < _addresses.length; i++) {
                whiteList[_addresses[i]] = false;
            }
        } else {
            revert InvalidData();
        }
    }

    function addToClaimList(address[] calldata _addresses, uint256[] calldata _amounts)
        external
        onlyOwner
    {
        if (_addresses.length != _amounts.length) revert NonEqualArrays();

        for (uint i = 0; i < _addresses.length; i++) {
            claimList[_addresses[i]] = _amounts[i];
        }
    }

    function removeFromClaimList(address[] calldata _addresses)
        external
        onlyOwner
    {
        for (uint i = 0; i < _addresses.length; i++) {
            claimList[_addresses[i]] = 0;
        }
    }
    
    function reveal() external onlyOwner {
        revealed = !revealed;
    }

    function activateClaim() external onlyOwner {
        claimEnabled = !claimEnabled;

        if(maxAvailableSupply + claimable <= collectionSize) {
            maxAvailableSupply += claimable;
        } else {
            maxAvailableSupply = collectionSize;
        }
    }

    function closeSale() external onlyOwner {
        if (totalSupply() == collectionSize) {
            mintStatus = MintStatus.SOLDOUT;
            emit UpdateSaleState("Sold Out");
        } else {
            mintStatus = MintStatus.CLOSED;
            emit UpdateSaleState("Closed");
        }
    }

    function startPresale() external onlyOwner {
        mintStatus = MintStatus.PRESALE;
        emit UpdateSaleState("Presale");
    }

    function startPublicSale() external onlyOwner {
        mintStatus = MintStatus.PUBLIC;
        emit UpdateSaleState("Public");
    }

    function withdrawl() external onlyOwner {
        uint totalBalance = address(this).balance;
        payable(devWallet).transfer(totalBalance * 58 / 1000);
        payable(msg.sender).transfer(totalBalance * 942 / 1000);
    }
}