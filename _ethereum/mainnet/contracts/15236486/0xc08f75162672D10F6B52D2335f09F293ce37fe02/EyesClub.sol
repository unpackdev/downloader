// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import "./ReentrancyGuard.sol";import "./ECDSA.sol";import "./Ownable.sol";import "./ERC721A.sol";contract EyesClub is ERC721A, Ownable, ReentrancyGuard {	  using ECDSA for bytes32;    enum Status {        Pending,        PreSale,        PublicSale,        Finished    }        Status public status;        uint256 public PRICE = 0 ether;        string private _uri;    mapping(address => uint256) private _signerOfNum;    mapping(address => uint256) private _publicNumberMinted;        uint256 public immutable maxTotalSupply;    uint256 public immutable PreMaxMint;    uint256 public immutable PublicMaxMint;        event PaymentReleased(address to, uint256 amount);        constructor(string memory initURI, address signer1) ERC721A("EyesFi GlassE Pass", "EGPASS", 3) {        _uri = initURI;        maxTotalSupply = 10000;        PreMaxMint = 1;        PublicMaxMint = 3;        _signerOfNum[signer1] = 1;        status = Status.PreSale;    }        function _hash(uint256 salt, address _address) internal view returns (bytes32)    {        return keccak256(abi.encode(salt, address(this), _address));    }        function _verify(bytes32 hash, bytes memory token) internal view returns (uint256)    {        return _signerOfNum[_recover(hash, token)] ;    }        function _recover(bytes32 hash, bytes memory token) internal pure returns (address)    {        return hash.toEthSignedMessageHash().recover(token);    }        function _baseURI() internal view  override(ERC721A) returns (string memory) {        return _uri;    }        function setURI(string memory newuri) public virtual onlyOwner{        _uri = newuri;    }        function setPrice(uint256 _price) public virtual onlyOwner {        PRICE = _price;    }        function mint(uint256 num) external payable {        require(status == Status.PublicSale, "status is not publicSale");        require(publicNumberMinted(msg.sender) + num <= PublicMaxMint, "reach public mint number");        verified(num);        _safeMint(msg.sender,num);        _publicNumberMinted[msg.sender] = _publicNumberMinted[msg.sender] + num;    }        function preSaleMint(        uint256 amount,        uint256 salt,        bytes calldata token    ) external payable {        require(status == Status.PreSale, "status is not preSale");        uint256 preMaxMint = _verify(_hash(salt, msg.sender), token);        require(preMaxMint >= amount, "invalid preMax mint number");        require(numberMinted(msg.sender) + amount <= preMaxMint, "reach pre mint number");        verified(amount);        _safeMint(msg.sender, amount);    }        function setStatus(Status _status, address signer) external onlyOwner {        status = _status;        if(status == Status.PublicSale){            delete _signerOfNum[signer];            PRICE = 0.2 ether;        }    }        function verified(uint256 num) private {        require(num > 0, 'invalid mint number');        require(msg.value >= PRICE * num, 'invalid payable value');        if (msg.value > PRICE * num) {            payable(msg.sender).transfer(msg.value - PRICE * num);        }        require(totalSupply() + num <= maxTotalSupply, "reach max mint number");        require(tx.origin == msg.sender, "invalid msg sender");    }        function setSignerOfNum(address signer, uint256 num) external onlyOwner {        _signerOfNum[signer] = num;    }    function removeSignerOfNum(address signer) external onlyOwner {        delete _signerOfNum[signer];    }        function numberMinted(address owner) public view returns (uint256) {        return _numberMinted(owner);    }        function publicNumberMinted(address owner) public view returns (uint256) {        require(            owner != address(0),            "ERC721A: number minted query for the zero address"        );        return _publicNumberMinted[owner];    }        function release() public virtual nonReentrant onlyOwner{        require(address(this).balance > 0, "invalid balance");        Address.sendValue(payable(owner()), address(this).balance);        emit PaymentReleased(owner(), address(this).balance);    }}