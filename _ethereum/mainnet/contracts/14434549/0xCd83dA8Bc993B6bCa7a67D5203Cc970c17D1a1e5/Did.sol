// SPDX-License-Identifier: LGPL-3.0-or-later
pragma solidity >=0.6.0 <0.7.0;
pragma experimental ABIEncoderV2;

import "./ERC721Upgradeable.sol";
import "./CountersUpgradeable.sol";
import "./DidStorage.sol";

/// @title A simple did contract v1
/// @notice You can use this contract to claim an DID to you
/// @dev Only contains NFT and id name mapping now
contract DidV1 is ERC721Upgradeable, DidV1Storage {
    /// @dev Emitted when did claimed successfully 
    event Claim(address indexed addr, string did, uint256 indexed tokenId);

    /// @dev Emitted when did add address authorization
    event AddAuth(string did, address indexed addr, address indexed operator);

    /// @dev Emitted when did cancel address authorization
    event RemoveAuth(string did, address indexed addr, address indexed operator);

    ///@dev Emitted when the owner account has changed.
    event OwnerChanged(address previousOwner, address newOwner);

    ///@dev Emitted when did reserved.
    event DidReserved(bytes32[] didHash);


    /// @dev Initialize only once
    /// @param _name ERC721 NFT name
    /// @param _symbol ERC721 NFT symbol
    /// @param _baseTokenURI ERC721 NFT baseTokenURI
    /// @param _owner The address of the owner, i.e. This owner is used to reserve 
    ///  some special dids, such as vitalik.eth.qp.
    function initialize(
        string memory _name,
        string memory _symbol,
        string memory _baseTokenURI,
        address _owner
    ) 
        public 
        initializer 
    {
        __ERC721_init(_name, _symbol);
        _setBaseURI(_baseTokenURI);
        owner = _owner;
    }

    modifier onlyOwner() {
        require(owner == msg.sender, "Ownable: caller is not the owner");
        _;
    }

    /// @notice Unable to modify owner
    /// @dev Get the owner generated by initialization
    function getOwner() public view returns (address) {
        return owner;
    }

    /// @notice Only the owner can call the method
    /// @dev transaction did
    /// @param newOwner One address for receiving did
    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnerChanged(owner, newOwner);
        owner = newOwner;
    }

    /// @notice Only the owner can call the method
    /// @dev Reserve a batch of reserved special did
    /// @param didHash A batch of reserved special did hash
    function reserveDid(bytes32[] memory didHash) public onlyOwner {
        for (uint i = 0; i < didHash.length; i++) {
            reserved[didHash[i]] = true;
        }
        emit DidReserved(didHash);
    }

    /// @notice Claim did
    /// @dev One address can only claim once
    /// @param did did
    function claim(string memory did) public {
        require(!addrClaimed(msg.sender), "addr claimed");
        require(verifyDIDFormat(did), "illegal did");
        require(!didReserved(did), "did reserved");
        require(!didClaimed(did), "did used");
        require(balanceOf(msg.sender) == 0);

        _bindAddrDid(msg.sender, did);

        _tokenIds.increment();
        uint256 newItemId = _tokenIds.current();
        _mint(msg.sender, newItemId);

        emit Claim(msg.sender, did, newItemId);
        return;
    }

    /// @notice Check if address has claimed did
    /// @dev Check if address has claimed did
    /// @param addr The address to check if has claimed
    function addrClaimed(address addr) public view returns (bool) {
        return didHashes[addr] != 0;
    }

    /// @notice Check if did has been claimed
    /// @dev Check if did has been claimed
    /// @param did did
    function didClaimed(string memory did) public view returns (bool) {
        return addrs[keccak256(bytes(did))] != address(0);
    }

    /// @notice Check if did has been reserved
    /// @dev Check if did has been reserved
    /// @param did did
    function didReserved(string memory did) public view returns (bool) {
        return reserved[keccak256(bytes(did))];
    }

    /// @dev verify did format
    /// @param did did
    function verifyDIDFormat(string memory did) public pure returns (bool) {
        bytes memory bDid = bytes(did);

        // length within [8,57]
        if ((bDid.length < 8) || (bDid.length > 57)) {
            return false;
        }

        // allow  0-9/a-z
        for (uint256 i = 0; i < bDid.length - 7; i++) {
            uint8 c = uint8(bDid[i]);
            if (((c < 48) || (c > 122)) || ((c > 57) && (c < 97))) {
                return false;
            }
        }

        // must ends with ".eth.qp"
        if (
            (uint8(bDid[bDid.length - 7]) != 46) ||
            (uint8(bDid[bDid.length - 6]) != 101) ||
            (uint8(bDid[bDid.length - 5]) != 116) ||
            (uint8(bDid[bDid.length - 4]) != 104) ||
            (uint8(bDid[bDid.length - 3]) != 46) ||
            (uint8(bDid[bDid.length - 2]) != 113) ||
            (uint8(bDid[bDid.length - 1]) != 112)
        ) {
            return false;
        }

        return true;
    }

    /// @dev did add address authorization
    /// @param did did
    /// @param addr address to add authorization
    function addAuth(string memory did, address addr) public {
        bytes32 didHash = keccak256(bytes(did));
        require(msg.sender == addrs[didHash], "operation forbidden");
        require(!auths[didHash].contains(addr), "already added");
        auths[didHash].add(addr);
        emit AddAuth(did, addr, addrs[didHash]);
    }

    /// @dev did cancel address authorization
    /// @param did did
    /// @param addr address to cancel authorization
    function removeAuth(string memory did, address addr) public {
        bytes32 didHash = keccak256(bytes(did));
        require(msg.sender == addrs[didHash], "operation forbidden");
        require(auths[didHash].contains(addr), "already removed");
        auths[didHash].remove(addr);
        emit RemoveAuth(did, addr, addrs[didHash]);
    }

    /// @dev get all authorized addresses of did
    /// @param did did
    /// @return all authorized addresses of did
    function getAuthorizedAddrs(string memory did) public view returns (address[] memory) {
        bytes32 didHash = keccak256(bytes(did));
        EnumerableSetUpgradeable.AddressSet storage auths = auths[didHash];

        address[] memory addrs = new address[](auths.length());
        for (uint i = 0; i < auths.length(); i++) {
            addrs[i] = auths.at(i);
        }
        return addrs;
    }

    /// @dev get the address is authorized
    /// @param did did
    /// @param addr address to check
    /// @return if address is authorized
    function isAddrAuthorized(string memory did, address addr) public view returns (bool) {
        bytes32 didHash = keccak256(bytes(did));
        return auths[didHash].contains(addr);
    }

    /// @dev disable NFT token transfer
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 tokenId
    ) 
        internal 
        override 
    {
        to;
        tokenId;
        require(from == address(0), "cannot transfer");
    }

    /// @dev bind addr and did
    function _bindAddrDid(address addr, string memory did) private {
        bytes32 didHash = keccak256(bytes(did));
        didHashes[addr] = didHash;
        didName[didHash] = did;
        addrs[didHash] = addr;
    }
}