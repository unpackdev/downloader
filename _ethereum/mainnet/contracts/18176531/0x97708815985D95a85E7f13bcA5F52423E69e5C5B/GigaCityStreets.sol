// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

// A lot of stuff in web3 is build on top of foundations of others.
// Yet this information is hidden as a single line somewhere in the
// source code. Appreciate your work Chiru Labs, OpenZeppelin, OpenSea.

import "./ERC721A.sol";
import "./UpdatableOperatorFilterer.sol";
import "./Ownable.sol";
import "./ReentrancyGuard.sol";

// =============================================================
//
//   ▄████  ██▓  ▄████  ▄▄▄       ▄████▄   ██▓▄▄▄█████▓▓██   ██▓
//  ██▒ ▀█▒▓██▒ ██▒ ▀█▒▒████▄    ▒██▀ ▀█  ▓██▒▓  ██▒ ▓▒ ▒██  ██▒
// ▒██░▄▄▄░▒██▒▒██░▄▄▄░▒██  ▀█▄  ▒▓█    ▄ ▒██▒▒ ▓██░ ▒░  ▒██ ██░
// ░▓█  ██▓░██░░▓█  ██▓░██▄▄▄▄██ ▒▓▓▄ ▄██▒░██░░ ▓██▓ ░   ░ ▐██▓░
// ░▒▓███▀▒░██░░▒▓███▀▒ ▓█   ▓██▒▒ ▓███▀ ░░██░  ▒██▒ ░   ░ ██▒▓░
//  ░▒   ▒ ░▓   ░▒   ▒  ▒▒   ▓▒█░░ ░▒ ▒  ░░▓    ▒ ░░      ██▒▒▒ 
//   ░   ░  ▒ ░  ░   ░   ▒   ▒▒ ░  ░  ▒    ▒ ░    ░     ▓██ ░▒░ 
// ░ ░   ░  ▒ ░░ ░   ░   ░   ▒   ░         ▒ ░  ░       ▒ ▒ ░░  
//       ░  ░        ░       ░  ░░ ░       ░            ░ ░     
//                              ░                      ░ ░     
//
// We'll see where it takes us. It started as a fun little idea
// to share my GEN art with others in my small FT group. Holders
// can request a character in Giga City universe, or get one
// generated by me. Follow the rabbit @0x50b

// =============================================================
//                             ERRORS
// =============================================================

error TokenDoesNotExist();
error TransferFailed();
error TotalSupplyExceeded();
error PublicMintOff();
error TxQuantityExceeded();
error AddressQuantityExceeded();
error NoCashForMint();
error NoWhitelistSpot();

// =============================================================
//                       GIGA CITY STREETS
// =============================================================

contract GigaCityStreets is ERC721A, UpdatableOperatorFilterer, ReentrancyGuard, Ownable {
    // Not mintable for public, most likely. I might open it up eventually,
    // if there will be demand. But keeping it closed for the foreseeable future.
    bool public mintOpen;
    
    // Sets the price for public mints, at zero for private mints.
    // But private mints have option to tip.
    uint256 public mintPrice;

    // Limit will be 100, but added a setter that can change
    // this value at any time.
    uint256 public supplyCap;

    // Where is the metadata hosted
    string private _URIPrefix;

    // Suffix for token URI. Set as ".json" during deployment.
    // This gives me the ability to have the data stored as json on S3,
    // and eventually migrate it to server with URL https://example.com/1
    // without the .json suffix
    string private _URISuffix;

    // Minting is limited to X per Tx. 
    uint256 public maxMintPerTx;

    // Minting is limited to X per addy.
    uint256 public maxMintPerAddress;

    // Mapping whitelist addresses to private mint allocation.
    mapping(address => uint256) public _mintAllocation;

    // =============================================================
    //                           CONSTRUCTOR
    // =============================================================

    constructor(address operatorFilterRegistry_, uint256 supplyCap_)
        ERC721A("Giga City Streets", "GCS")
        UpdatableOperatorFilterer(
            operatorFilterRegistry_,
            0x0000000000000000000000000000000000000000,
            false
        ) {
            mintOpen = false;
            mintPrice = 0 ether;
            supplyCap = supplyCap_;

            maxMintPerTx = 1;
            maxMintPerAddress = 1;

            _URISuffix = '.json';
    }

    // =============================================================
    //                             MINT
    // =============================================================


    /**
     * @dev Checks common requirements for minting: 
     *
     * - Total supply,
     * - Tx mint limit
     * - Account mint limit.
     */
    modifier mintable(uint256 quantity_) {
        // Are we exceeding the supply cap? If yeah revert.
        if (totalSupply() + quantity_ > supplyCap) revert TotalSupplyExceeded();
        // Are we minting above transaction limit? If yeah revert.
        if (quantity_ < 0 || quantity_ > maxMintPerTx) revert TxQuantityExceeded();
        // We proceed ...
        _;
    }

    /**
     * @dev Available for public minting. Required payment if set.
     */
    function mintPublic(uint256 quantity_) external payable mintable(quantity_) {
        // Is public minting open? If nah, revert.
        if (!mintOpen) revert PublicMintOff();

        // Are we minting more than what is the maximum mint per address? If yeah revert.
        if (_numberMinted(msg.sender) == maxMintPerAddress || _numberMinted(msg.sender) + quantity_ > maxMintPerAddress ) revert AddressQuantityExceeded();

        // If not enough eth was provided, we are not minting.
        if (msg.value < mintPrice * quantity_) revert NoCashForMint();

        _safeMint(msg.sender, quantity_);
    }

    /**
     * @dev Available for private minting for addresses set in _mintAllocation
     * Not requiring payment, but tipping available.
     */
    function mintPrivate(uint256 quantity_) external payable mintable(quantity_) {
        // Is the address whitelisted?
        if (_mintAllocation[msg.sender] == 0) revert NoWhitelistSpot();

        // Did one minted beyond allocation?
        if (_numberMinted(msg.sender) + quantity_ > _mintAllocation[msg.sender]) revert AddressQuantityExceeded();

        _safeMint(msg.sender, quantity_);
    }

    // =============================================================
    //                            WHITELIST
    // =============================================================
    
    /**
     * @dev Set whitelist allocation. As "address / # of spots" pairs.
     */
    function setWhitelist(address wlAddress_, uint256 wlAllocation_) external onlyOwner {
        _mintAllocation[wlAddress_] = wlAllocation_;
    }

    // =============================================================
    //                           MANAGEMENT
    // =============================================================

    function setMintOpen(bool mintOpen_) external onlyOwner {
        mintOpen = mintOpen_;
    }

    function setURIPrefix(string calldata uriPrefix_) external onlyOwner {
        _URIPrefix = uriPrefix_;
    }

    function setURISuffix(string calldata uriSuffix_) external onlyOwner {
        _URISuffix = uriSuffix_;
    }

    function setMintPrice(uint256 mintPrice_) external onlyOwner {
        mintPrice = mintPrice_;
    }

    function setSupplyCap(uint256 supplyCap_) external onlyOwner {
        supplyCap = supplyCap_;
    }

    function setMaxMintPerTx(uint256 maxMintPerTx_) external onlyOwner {
        maxMintPerTx = maxMintPerTx_;
    }

    function setMaxMintPerAddress(uint256 maxMintPerAddress_) external onlyOwner {
        maxMintPerAddress = maxMintPerAddress_;
    }

    // =============================================================
    //                           METADATA
    // =============================================================

    /**
     * @dev Returns where we store our metadata.
     */
    function _baseURI() internal view virtual override returns (string memory) {
        return _URIPrefix;
    }

    /**
     * @dev Returns complete url for a single token.
     */
    function tokenURI(uint256 _tokenId) public view virtual override(ERC721A) returns (string memory) {
        if (!_exists(_tokenId)) revert TokenDoesNotExist();

        string memory currentBaseURI = _baseURI();
        return bytes(currentBaseURI).length > 0
            ? string(abi.encodePacked(currentBaseURI, _toString(_tokenId), _URISuffix))
            : '';
    }

    // =============================================================
    //                           OWNABLE
    // =============================================================

    /**
     * @dev Override needed due to fonflict. Super.owner() returns
     * direct parent, which in this case is Ownable contract.
     */
    function owner() public view virtual override(UpdatableOperatorFilterer, Ownable) returns (address) {
        return super.owner();
    }

    // =============================================================
    //                 Operator Filterer Overrides
    // =============================================================

    function setApprovalForAll(address operator, bool approved) public override onlyAllowedOperatorApproval(operator) {
        super.setApprovalForAll(operator, approved);
    }

    function approve(address operator, uint256 tokenId) public payable override onlyAllowedOperatorApproval(operator) {
        super.approve(operator, tokenId);
    }

    function transferFrom(address from, address to, uint256 tokenId) public payable override onlyAllowedOperator(from) {
        super.transferFrom(from, to, tokenId);
    }

    function safeTransferFrom(address from, address to, uint256 tokenId) public payable override onlyAllowedOperator(from) {
        super.safeTransferFrom(from, to, tokenId);
    }

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public payable override onlyAllowedOperator(from) {
        super.safeTransferFrom(from, to, tokenId, data);
    }

    // =============================================================
    //                           WITHDRAW
    // =============================================================

    /**
     * @dev Option to withdraw ETH.
     */
    function withdraw() external onlyOwner nonReentrant() {
        (bool success, ) = msg.sender.call{value: address(this).balance}("");
        if (!success) revert TransferFailed();
    }
}