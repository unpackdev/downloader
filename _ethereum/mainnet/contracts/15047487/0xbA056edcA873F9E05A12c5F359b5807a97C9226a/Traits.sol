// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import "./Ownable.sol";


contract Traits is Ownable {
    string private constant randomTrait = "?";

    struct Spec {
        bool exists;
        string[] itemsList;
        mapping(string => Spec) items;
        mapping(string => bool) compatsEnabled;
        mapping(string => mapping(string => mapping(string => bool))) compats;
    }

    struct Trait {
        string trait;
        string value;
        string variation;
    }

    struct _NFT {
        Trait[] traits;
        mapping(string => string) values;
    }

    Spec spec;
    _NFT[] internal _nfts;
    uint256 internal _seed;

    string[] public traits;
    string[] public values;
    string[] public variations;
    uint256 public traitsCount;
    uint256[] public hueBg;
    uint256[] public hue;

    mapping(string => mapping(string => uint256)) public rarity;

    constructor() {
        _seed = block.timestamp;
    }

    function _requireNotEmpty(string memory arg) internal virtual {
        require(bytes(arg).length > 0, 'T7');
    }

    function _ensureVariation(
        string storage trait,
        string storage value,
        string storage variation
    ) internal virtual {
        _requireNotEmpty(trait);
        _requireNotEmpty(value);
        _requireNotEmpty(variation);

        Spec storage t = spec.items[trait];
        if (!t.exists) {
            t.exists = true;
            spec.itemsList.push(trait);
        }

        Spec storage v = t.items[value];
        if (!v.exists) {
            v.exists = true;
            t.itemsList.push(value);
        }

        Spec storage vr = v.items[variation];
        if (!vr.exists) {
            vr.exists = true;
            v.itemsList.push(variation);

            traits.push(trait);
            values.push(value);
            variations.push(variation);
            traitsCount++;
        }
    }

    function _randint(uint256 range) internal virtual returns (uint256) {
        // I have to make it predictable T_T
        // If it depended on block.timestamp or block.difficulty,
        // then we would constantly experience difficulties with
        // correct gas estimation.

        // In fact, true randomness persists in the long run
        // due to the unpredictability of traits generated by DAO.

        _seed = uint256(keccak256(abi.encodePacked(_seed, range)));
        return _seed % range;
    }

    struct _GenTrait {
        string trait;
        bool genMode;
        string value1;
        string value2;
        uint256 targetIdx;
    }

    function equals(string memory a, string memory b) internal pure returns (bool) {
        if(bytes(a).length != bytes(b).length) {
            return false;
        } else {
            return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));
        }
    }

    function _genTrait(_GenTrait memory gt) internal virtual returns (uint256, Trait memory) {
        Trait memory compatibleTrait;
        _NFT storage nft = _nfts[_nfts.length - 1];
        uint256 compatibleTraitsCount;
        Spec storage _trait = spec.items[gt.trait];

        for (uint256 j = 0; j < _trait.itemsList.length; j++) {
            string storage value = _trait.itemsList[j];
            Spec storage v = _trait.items[value];

            if (!gt.genMode && !equals(gt.value1, randomTrait) && !equals(gt.value2, randomTrait) && !equals(value, gt.value1) && !equals(value, gt.value2)) {
                continue;
            }

            for (uint256 k = 0; k < v.itemsList.length; k++) {
                string storage variation = v.itemsList[k];
                Spec storage vr = v.items[variation];

                bool compat = true;
                for (uint256 m = 0; m < nft.traits.length; m++) {
                    Trait storage t = nft.traits[m];
                    if (vr.compatsEnabled[t.trait] && !vr.compats[t.trait][t.value][t.variation]) {
                        compat = false;
                        break;
                    }
                }
                if (compat) {
                    if (compatibleTraitsCount == gt.targetIdx) {
                        compatibleTrait = Trait(gt.trait, value, variation);
                    }
                    compatibleTraitsCount++;
                }
            }
        }
        return (compatibleTraitsCount, compatibleTrait);
    }

    function _genTraitApply(_GenTrait memory gt) internal virtual {
        (uint256 compatibleTraitsCount,) = _genTrait(gt);

        if (compatibleTraitsCount == 0) {
            return;
        }

        gt.targetIdx = _randint(compatibleTraitsCount);
        (, Trait memory compatibleTrait) = _genTrait(gt);

        _NFT storage nft = _nfts[_nfts.length - 1];
        nft.traits.push(compatibleTrait);
        nft.values[compatibleTrait.trait] = compatibleTrait.value;

        rarity[compatibleTrait.trait][compatibleTrait.value]++;
    }

    function _genHue() internal virtual {
        hueBg.push(_randint(360));
        hue.push(_randint(360));
    }

    function _genMutagen() internal virtual {
        _nfts.push();
        _NFT storage nft = _nfts[_nfts.length - 1];
        string storage trait = spec.itemsList[_randint(spec.itemsList.length)];
        Trait[] storage _traits = nft.traits;
        _traits.push();
        _traits[0].trait = trait;
        nft.values[trait] = randomTrait;
        _genHue();
    }

    function _genTraits(bool genMode, uint256 nftID1, uint256 nftID2) internal virtual {
        _nfts.push();
        for (uint256 i = 0; i < spec.itemsList.length; i++) {
            string storage trait = spec.itemsList[i];
            _GenTrait memory gt;

            gt.trait = trait;
            gt.genMode = genMode;

            if (!gt.genMode) {
                gt.value1 = _nfts[nftID1].values[trait];
                gt.value2 = _nfts[nftID2].values[trait];

                if (bytes(gt.value1).length == 0 && bytes(gt.value2).length == 0) {
                    continue;
                }
            }

            _genTraitApply(gt);
        }
        _genHue();
    }

    function _setCompatibility(
        string storage trait,
        string storage value,
        string storage variation,
        string storage baseTrait,
        string storage baseValue,
        string storage baseVariation,
        bool compatsEnabled,
        bool compatible
    ) internal virtual {
        Spec storage vr = spec.items[trait].items[value].items[variation];
        vr.compatsEnabled[baseTrait] = compatsEnabled;
        if (compatsEnabled && bytes(baseValue).length > 0 && bytes(baseVariation).length > 0) {
            vr.compats[baseTrait][baseValue][baseVariation] = compatible;
        }
    }

    function getCompat(
        string memory trait,
        string memory value,
        string memory variation,
        string memory baseTrait,
        string memory baseValue,
        string memory baseVariation
    ) external view virtual returns (bool, bool) {
        Spec storage vr = spec.items[trait].items[value].items[variation];
        return (vr.compatsEnabled[baseTrait], vr.compats[baseTrait][baseValue][baseVariation]);
    }

    function getTraits(uint256 idx) external view virtual returns (Trait[] memory) {
        return _nfts[idx].traits;
    }
}
