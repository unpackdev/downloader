//SPDX-License-Identifier: MIT-BROUGKR
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
/**
 * @dev: @brougkr
 */
pragma solidity 0.8.17;
import "./Ownable.sol";
import "./ReentrancyGuard.sol";
import "./MerkleProof.sol";
import "./IERC721.sol";
import "./IERC20.sol";
import "./IMPO.sol";
import "./ERC721MP.sol";
contract MPMX is ERC721MP, Ownable, ReentrancyGuard
{    
    struct MintPass
    {
        uint _PriceStart;                       // [0] -> _PriceStart
        uint _PriceEnd;                         // [1] -> _PriceEnd
        uint _MaximumAvailableForSale;          // [2] -> _MaximumAvailableForSale
        uint _StartingBlockUnixTimestamp;       // [3] -> _StartingBlockUnixTimestamp
        uint _SecondsBetweenPriceDecay;         // [4] -> _SecondsBetweenPriceDecay
        bool _ActivePublic;                     // [5] -> _ActivePublic
        bool _ActiveBrightList;                 // [6] -> _ActiveBrightList
        bytes32 _Root;                          // [7] -> _Root
    }
    struct MintPack
    {
        uint _PriceStart;                       // [0] => _PriceStart 
        uint _PriceEnd;                         // [1] => _PriceEnd
        uint _MaximumAvailableForSale;          // [2] => _MaximumAvailableForSale
        uint _StartingBlockUnixTimestamp;       // [3] => _StartingBlockUnixTimestamp
        uint _SecondsBetweenPriceDecay;         // [4] => _SecondsBetweenPriceDecay
        bool _ActivePublic;                     // [5] => _ActivePublic
        bool _ActiveBrightList;                 // [6] => _ActiveBrightList
        bytes32 _Root;                          // [7] => _Root
    }
    struct InternalSale
    {
        uint _AmountSold;         // [0] -> _AmountSold
        uint _FinalClearingPrice; // [1] -> _FinalClearingPrice
        uint _UniqueSales;        // [2] -> _UniqueSales
    }
    struct InternalSaleMintPack
    {
        uint _AmountSold;         // [0] -> _AmountSold
        uint _FinalClearingPrice; // [1] -> _FinalClearingPrice
    }
    struct UserSaleInformation
    {
        // Mint Pass Information
        uint _MintPassCurrentPrice;    // [0] -> _MintPassCurrentPrice
        uint _MintPassAmountPurchased; // [1] -> _MintPassAmountPurchased
        uint _MintPassAllocation;      // [2] -> _MintPassAllocation
        uint _MintPassAmountRemaining; // [3] -> _MintPassAmountRemaining
        bool _MintPassEligible;        // [4] -> _MintPassEligible
        bool _MintPassSalePaused;      // [5] -> _MintPassSalePaused

        // Mint Pack Information
        uint _MintPackCurrentPrice;    // [6] -> _MintPackCurrentPrice
        uint _MintPackAmountPurchased; // [7] -> _MintPackAmountPurchased
        uint _MintPackAllocation;      // [8] -> _MintPackAllocation
        uint _MintPackAmountRemaining; // [9] -> _MintPackAmountRemaining
        bool _MintPackEligible;        // [10] -> _MintPackEligible
        bool _MintPackSalePaused;      // [11] -> _MintPackSalePaused
    }
    struct SaleInformation
    {
        // Mint Pass Information
        uint _MintPassCurrentPrice;  // [0] -> _MintPassCurrentPrice
        uint _MintPassRemaining;     // [1] -> _MintPassRemaining
        uint _MintPassSaleStartTime; // [2] -> _MintPassSaleStartTime
        uint _MintPassStartingPrice; // [3] -> _MintPassStartingPrice
        uint _MintPassEndingPrice;   // [4] -> _MintPassEndingPrice

        // Mint Pack Information 
        uint _MintPackCurrentPrice;  // [6] -> _MintPackCurrentPrice
        uint _MintPackRemaining;     // [7] -> _MintPackRemaining
        uint _MintPackSaleStartTime; // [8] -> _MintPackSaleStartTime
        uint _MintPackStartingPrice; // [9] -> _MintPackStartingPrice
        uint _MintPackEndingPrice;   // [10] -> _MintPackEndingPrice
    }
    struct UserHoldings
    {
        uint[] _TokenIDs;         // [0] -> _TokenIDs
        uint[] _ArtistIDs;        // [1] -> _ArtistIDs
        uint _FinalClearingPrice; // [2] -> _FinalClearingPrice
    }
    struct MPMXHoldings
    {
        uint[] _TokenIDs; 
        uint[] _ArtistIDs;
        bool _ArtistRevealedIDs;
        bool _ArtistRevealedNames;
    }
    MintPass public MintPassSale = MintPass(
        20 ether,   // [0] -> _PriceStart    
        0.5 ether,  // [1] -> _PriceEnd   
        417,        // [2] -> _MaximumAvailableForSale
        1663347600, // [3] -> _StartingBlockUnixTimestamp
        677,        // [4] -> _SecondsBetweenPriceDecay
        false,      // [5] -> _ActivePublic
        true,       // [6] -> _ActiveBrightList
        0x0         // [7] -> _Root
    ); 
    MintPack public MintPackSale = MintPack(
        200 ether,  // [0] -> _PriceStart     
        5 ether,    // [1] -> _PriceEnd     
        10,         // [2] -> _MaximumAvailableForSale
        1663347600, // [3] -> _StartingBlockUnixTimestamp
        677,        // [4] -> _SecondsBetweenPriceDecay
        false,      // [5] -> _ActivePublic
        true,       // [6] -> _ActiveBrightList
        0x0         // [7] -> _Root
    );
    InternalSale public MintPassInternalSale = InternalSale(
        0,   // [0] -> _AmountSold
        0,   // [1] -> _FinalClearingPrice
        0    // [2] -> _UniqueSales
    );
    InternalSaleMintPack public MintPackInternalSale = InternalSaleMintPack(
        0,   // [0] -> _AmountSold
        0    // [1] -> _FinalClearingPrice
    );

    mapping(uint=>string) public ArtistNames;                  // `ArtistID` => `Artist Name` (Post-Randomized)
    mapping(uint=>uint) public ArtistID;                       // `TokenID` => `ArtistID` (Post-Randomized)
    mapping(uint=>address) public UniqueSaleIndexToAddress;    // `OrderID` => `Recipient`
    mapping(uint=>uint) public UniqueSalePurchaseAmount;       // `OrderID` => `Order Amount`
    mapping(uint=>uint) public UniqueSaleToOrderValue;         // `OrderID` => `Order Value`
    mapping(address=>uint) public _MintPassPurchasedAmt;       // `Wallet` => `Total Purchased Amount`
    mapping(address=>uint) public _MintPackPurchasedAmt;       // `Wallet` => `Total Purchased Amount`
    mapping(address=>uint) public _WalletAllocationsMintPass;  // `Wallet` => `Amount To Purchase`
    mapping(address=>uint) public _WalletAllocationsMintPack;  // `Wallet` => `Allocation`

    string public baseURI = "ipfs://QmUZ9CRbFLtDa8wmCLU3TXUt5WrJM32M9w6RLF717yyeNM/";
    uint[] public MintPackStartingIndexes;
    bool public OptionsActive;
    address public Option = 0x08ebADbc44F0f76CAFC6FD49e53247Cc9798eddD;
    address public _LiveMint = 0x7603C5eed8e57Ad795ec5F0081eFB21d1eEBf937;   
    address public _BRT_MULTISIG = 0xB96E81f80b3AEEf65CB6d0E280b15FD5DBE71937;
    
    event MerkleRootsChanged(bytes32 OldRootMintPass, bytes32 OldRootMintPack, bytes32 NewRootMintPass, bytes32 NewRootMintPack);
    event PurchasedMintPack(address Recipient, uint Amount, uint MessageValue, uint PurchaseValue, uint AmountSold);
    event Purchased(address Recipient, uint Amount, uint MessageValue, uint PurchaseValue, uint AmountSold);
    event RandomArtistIDsSeeded(string URL, uint[] NewArtistIDs);
    event MerkleRootChanged(bytes32 OldRoot, bytes32 NewRoot);
    event OptionRedeemed(uint[] TokenIDs, address Recipient);
    event ArtistNamesSeeded(string URL, string[] Names);
    event NewStartingTimestamp(uint Timestamp);
    event ClaimStateSwitched(bool State);
    event Refunded(uint RefundAmount);

    constructor() ERC721MP("Mint Pass Mexico City | MPMX", "MPMX")
    { 
        // Transfers Ownership 
        _transferOwnership(0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700); // operator.brightmoments.eth
        _WhitelistedSender[0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700] = true;

        // Reserves Mint Passes - TokenIDs Are Irrelevant - The Randomized ArtistIDs Will Be Mapped After The Sale Concludes
        _mint(address(this), 333);  // GTMX Holder Option Reserve:  [TokenIDs: 000 - 332] (333)                            
        _mint(_BRT_MULTISIG, 150);  // Artist Reservation & BM Dao: [TokenIDs: 333 - 482] (150)
                                    // Mint Packs:                                        (100)
                                    // Remaining For Sale:                                (417)
    } 

    /*---------------------
     * EXTERNAL FUNCTIONS *
    ----------------------*/

    /**
     * @dev Purchases NFTs
     */
    function PurchasePass(uint Amount, bytes32[] calldata Proof) external payable nonReentrant
    { 
        require(block.timestamp >= MintPassSale._StartingBlockUnixTimestamp, "MPMX: Sale Not Started Yet");
        require(MintPassSale._ActivePublic || MintPassSale._ActiveBrightList, "MPMX: Sale Not Active");
        if(MintPassInternalSale._AmountSold + Amount > MintPassSale._MaximumAvailableForSale)
        {
            Amount = MintPassSale._MaximumAvailableForSale - MintPassInternalSale._AmountSold;
        }
        uint NewAmountSold = MintPassInternalSale._AmountSold + Amount;
        require(NewAmountSold <= MintPassSale._MaximumAvailableForSale, "MPMX: Sold Out");
        uint NewUserPurchasedAmount = _MintPassPurchasedAmt[msg.sender] + Amount;
        require(Amount > 0, "MPMX: Incorrect Amount");
        if(MintPassSale._ActiveBrightList) 
        { 
            require(VerifyBrightList(msg.sender, Proof, MintPassSale._Root), "MPMX: Merkle: User Is Not On BrightList"); 
            require(
                NewUserPurchasedAmount <= _WalletAllocationsMintPass[msg.sender],
                "MPMX: Allocation Overflow"
            );
        }
        uint CurrentPrice = ViewCurrentPriceMintPass();
        uint CurrentPurchaseValue = CurrentPrice * Amount;
        require(msg.value >= CurrentPurchaseValue, "MPMX: Incorrect ETH Amount Sent");
        if(msg.value > CurrentPurchaseValue) { __Refund(msg.sender, (msg.value - CurrentPurchaseValue)); }
        UniqueSaleToOrderValue[MintPassInternalSale._UniqueSales] = CurrentPurchaseValue;
        UniqueSaleIndexToAddress[MintPassInternalSale._UniqueSales] = msg.sender; 
        UniqueSalePurchaseAmount[MintPassInternalSale._UniqueSales] = Amount;
        MintPassInternalSale._UniqueSales = MintPassInternalSale._UniqueSales + 1;
        MintPassInternalSale._AmountSold = NewAmountSold;
        _MintPassPurchasedAmt[msg.sender] = NewUserPurchasedAmount;
        require(MintPassInternalSale._AmountSold <= MintPassSale._MaximumAvailableForSale, "MPMX: Overflow");
        if(MintPassInternalSale._AmountSold == MintPassSale._MaximumAvailableForSale) // End Sales
        { 
            MintPassInternalSale._FinalClearingPrice = CurrentPrice; 
            ___EndMintPassSale();
        }
        _mint(msg.sender, Amount);
        emit Purchased(msg.sender, Amount, msg.value, CurrentPurchaseValue, NewAmountSold);
    }

    /**
     * @dev Purchases Mint Pass
     */
    function PurchasePack(uint Amount, bytes32[] calldata Proof) external payable nonReentrant
    {
        require(block.timestamp >= MintPackSale._StartingBlockUnixTimestamp, "MPMX: Sale Has Not Started");
        require(MintPackSale._ActiveBrightList || MintPackSale._ActivePublic, "MPMX: Sale Not Active");
        if(MintPackInternalSale._AmountSold + Amount > MintPackSale._MaximumAvailableForSale)
        {
            Amount = MintPackSale._MaximumAvailableForSale - MintPackInternalSale._AmountSold;
        }
        uint NewAmountSold = MintPackInternalSale._AmountSold + Amount;
        require(NewAmountSold <= MintPackSale._MaximumAvailableForSale, "MPMX: Sold Out");
        uint NewUserPurchasedAmount = _MintPackPurchasedAmt[msg.sender] + Amount;
        require(Amount > 0, "MPMX: Incorrect Amount");
        if(MintPackSale._ActiveBrightList) 
        { 
            require(VerifyBrightList(msg.sender, Proof, MintPackSale._Root), "Merkle: User Is Not On BrightList"); 
            require(
                NewUserPurchasedAmount <= _WalletAllocationsMintPack[msg.sender],
                "MPMX: User Has Used Up All Allocation For This Sale Index"
            );
        }
        uint CurrentPrice = ViewCurrentPriceMintPack();
        uint CurrentPurchaseValue = CurrentPrice * Amount;
        if(NewAmountSold == MintPackSale._MaximumAvailableForSale) 
        { 
            MintPackInternalSale._FinalClearingPrice = CurrentPrice; 
            __EndMintPackSale();
        }
        require(msg.value >= CurrentPurchaseValue, "MPMX: Invalid `msg.value`");
        if(msg.value > CurrentPurchaseValue) { __Refund(msg.sender, (msg.value - CurrentPurchaseValue)); }
        uint AmountToMint = (10 * Amount);
        uint TotalMinted = _totalMinted();
        for(uint x; x < Amount; x++) { MintPackStartingIndexes.push(TotalMinted + (x*10)); }
        _mint(msg.sender, AmountToMint);
        MintPackInternalSale._AmountSold = NewAmountSold;
        _MintPackPurchasedAmt[msg.sender] = NewUserPurchasedAmount;
        emit PurchasedMintPack(msg.sender, Amount, msg.value, CurrentPurchaseValue, NewAmountSold);
    }

    /**
     * @dev Redeems Option
     */
    function RedeemOption(uint[] calldata TokenIDs) external payable nonReentrant
    {
        require(MintPassInternalSale._FinalClearingPrice > 0, "MPMX: Final Dutch Clearing Price Not Seeded");
        require(OptionsActive, "MPMX: Option Claims Not Active");
        require(msg.value == MintPassInternalSale._FinalClearingPrice * TokenIDs.length, "MPMX: Invalid Message Value");
        for(uint TokenID; TokenID < TokenIDs.length; TokenID++)
        {
            require(IERC721(Option).ownerOf(TokenIDs[TokenID]) == msg.sender, "ERC721: User Does Not Own Option TokenID");
            IMPO(Option)._RedeemOption(TokenIDs[TokenID]); 
            IERC721(address(this)).transferFrom(address(this), msg.sender, TokenIDs[TokenID]);
        }
        emit OptionRedeemed(TokenIDs, msg.sender);
    }
    
    /*------------------
     * ADMIN FUNCTIONS *
    -------------------*/
    
    /**
     * @dev Toggles Active Public Sale State For Mint Pass
     */
    function __ToggleActivePublicMintPass() external onlyOwner { MintPassSale._ActivePublic = !MintPassSale._ActivePublic; }
    
    /**
     * @dev Toggles Active Public Sale State For Mint Pass
     */
    function __ToggleActivePublicMintPack() external onlyOwner { MintPackSale._ActivePublic = !MintPackSale._ActivePublic; }

    /**
     * @dev Toggles Active Public Sale State For Mint Pass
     */
    function __ToggleActiveBrightListMintPass() external onlyOwner { MintPassSale._ActiveBrightList = !MintPassSale._ActiveBrightList; }

    /**
     * @dev Toggles Active Public Sale State For Mint Pass
     */
    function __ToggleActiveBrightListMintPack() external onlyOwner { MintPackSale._ActiveBrightList = !MintPackSale._ActiveBrightList; }

    /**
     * @dev Enables Or Disables Option Claims
     */
    function __ToggleOptionClaims() external onlyOwner { OptionsActive = !OptionsActive; }

    /**
     * @dev Initiates Refunds For Sale
     */
    function __InitiateRefunds() external onlyOwner
    {
        require(MintPassInternalSale._FinalClearingPrice > 0, "Final Clearing Price Not Seeded");
        for(uint OrderIndex; OrderIndex < MintPassInternalSale._UniqueSales; OrderIndex++)
        {
            (bool Confirmed,) = UniqueSaleIndexToAddress[OrderIndex].call{
                value: UniqueSaleToOrderValue[OrderIndex] - (MintPassInternalSale._FinalClearingPrice * UniqueSalePurchaseAmount[OrderIndex])
            } (""); 
            require(Confirmed, "MPMX: Refund failed");
        }
    }

    /**
     * @dev Initiates Withdraw Of Refunds & Sale Proceeds
     */
    function __InitiateRefundsAndProceeds() external onlyOwner
    {
        require(MintPassInternalSale._FinalClearingPrice > 0, "Final Clearing Price Not Seeded");
        for(uint OrderIndex; OrderIndex < MintPassInternalSale._UniqueSales; OrderIndex++)
        {
            (bool ConfirmedRefund,) = UniqueSaleIndexToAddress[OrderIndex].call{
                value: UniqueSaleToOrderValue[OrderIndex] - (MintPassInternalSale._FinalClearingPrice * UniqueSalePurchaseAmount[OrderIndex])
            } (""); 
            require(ConfirmedRefund, "MPMX: Refund failed");
        }
        (bool ConfirmedWithdraw,) = msg.sender.call{ value: address(this).balance } (""); 
        require(ConfirmedWithdraw, "MPMX: Refund failed");
    }

    /**
     * @dev Seeds Wallet Allocations For Mint Passes
     */
    function __SeedWalletAllocationsMintPass(address[] calldata Wallets, uint[] calldata Allocations) external onlyOwner
    {
        for(uint x; x < Wallets.length; x++) { _WalletAllocationsMintPass[Wallets[x]] = Allocations[x]; }
    }

    /**
     * @dev Seeds Wallet Allocations For Mint Packs
     */
    function __SeedWalletAllocationsMintPack(address[] calldata Wallets, uint[] calldata Allocations) external onlyOwner
    {
        for(uint x; x < Wallets.length; x++) { _WalletAllocationsMintPack[Wallets[x]] = Allocations[x]; }
    }

    /**
     * @dev Overrides Approval Index For MPMX 
     */
    function __NewSetApprovalsArtistIDs() external onlyOwner 
    { 
        require(!_ArtistsRevealedIDs, "MPMX: Cannot Instantiate New SetApprovals Twice");
        _ArtistsRevealedIDs = true; 
    }

    /**
     * @dev Overrides Approval Index For MPMX
     */
    function __NewSetApprovalsArtistNames() external onlyOwner
    {
        require(!_ArtistRevealedNames, "MPMX: Cannot Instantiate New SetApprovals Twice");
        _ArtistRevealedNames = true;
    }

    /**
     * @dev Seeds Random ArtistIDs For A Sale
     */
    function __SeedRandomArtistIDs(string calldata URL, uint[] calldata NewArtistIDs) external onlyOwner
    {
        unchecked
        {
            for(uint x; x < NewArtistIDs.length; x++) 
            { 
                ArtistID[x] = NewArtistIDs[x]; 
            }
            _ArtistsRevealedIDs = true;
            emit RandomArtistIDsSeeded(URL, NewArtistIDs);
        }
    }

    /**
     * @dev Seeds Random Artist Names Into Contract
     */
    function __SeedRandomArtistNames(string calldata URL, string[] calldata Names) external onlyOwner
    {
        unchecked
        {
            for(uint x; x < Names.length; x++) { ArtistNames[x] = Names[x]; }
            _ArtistRevealedNames = true;
            emit ArtistNamesSeeded(URL, Names);
        }
    }

    /**
     * @dev Changes Starting Block Timestamps
     */
    function __NewBlockTimestamps(uint Timestamp) external onlyOwner
    {
        MintPackSale._StartingBlockUnixTimestamp = Timestamp;
        MintPassSale._StartingBlockUnixTimestamp = Timestamp;
        emit NewStartingTimestamp(Timestamp);
    }

    /**
     * @dev Changes Ending Price For Mint Pass *** DENOTED IN WEI ***
     */
    function __NewEndingPrice(uint PriceEnd) external onlyOwner 
    { 
        MintPassSale._PriceEnd = PriceEnd; 
    }

    /**
     * @dev Changes Ending Price For Mint Pack *** DENOTED IN WEI ***
     */
    function __NewEndingPriceMintPack(uint PriceEnd) external onlyOwner
    {
        MintPackSale._PriceEnd = PriceEnd;
    }

    /**
     * @dev Changes Merkle Root
     */
    function __NewRootMintPass(bytes32 NewRoot) external onlyOwner
    {
        bytes32 OldRoot = MintPassSale._Root;
        MintPassSale._Root = NewRoot;
        emit MerkleRootChanged(OldRoot, NewRoot);
    }

    /**
     * @dev Changes Merkle Root Mint Pack
     */
    function __NewRootMintPack(bytes32 NewRoot) external onlyOwner
    {
        bytes32 OldRoot = MintPackSale._Root;
        MintPackSale._Root = NewRoot;
        emit MerkleRootChanged(OldRoot, NewRoot);
    }

    /**
     * @dev Instantiates New Merkle Roots
     */
    function __NewRoots(bytes32 NewMintPassRoot, bytes32 NewMintPackRoot) external onlyOwner
    {
        bytes32 OldRootMintPass = MintPassSale._Root;
        bytes32 OldRootMintPack = MintPackSale._Root;
        MintPassSale._Root = NewMintPassRoot;
        MintPackSale._Root = NewMintPackRoot;
        emit MerkleRootsChanged(OldRootMintPass, OldRootMintPack, NewMintPassRoot, NewMintPackRoot);
    }

    /**
     * @dev Changes Final Settlement Price For A Sale *** DENOTED IN WEI ***
     */
    function __NewClearingPrice(uint FinalClearingPrice) external onlyOwner 
    { 
        MintPassInternalSale._FinalClearingPrice = FinalClearingPrice;
    }

    /**
     * @dev Instantiates New Multisig Address
     */
    function __NewMultisigAddress(address NewAddress) external onlyOwner 
    { 
        _BRT_MULTISIG = NewAddress; 
    }

    /**
     * @dev Instantiates New LiveMint Address
     */
    function __NewLiveMintAddress(address NewAddress) external onlyOwner 
    { 
        _LiveMint = NewAddress; 
    }

    /**
     * @dev Instantiates New LiveMint Contract Address
     */
    function __NewWhitelistedSenderAddress(address NewAddress) external onlyOwner 
    { 
        _WhitelistedSender[NewAddress] = !_WhitelistedSender[NewAddress]; 
        // emit WhitelistedSender(_WhitelistedSender[NewAddress]);
    }

    /**
     * @dev Instantiates New Golden Token Address
     */
    function __NewOptionAddress(address NewAddress) external onlyOwner 
    { 
        Option = NewAddress;
    }

    /**
     * @dev Changes The BaseURI For JSON Metadata 
     */
    function __NewBaseURI(string calldata NewURI) external onlyOwner 
    { 
        baseURI = NewURI; 
    }

    /**
     * @dev Ends All Sales
     */
    function __EndAllSales() external onlyOwner 
    {
        MintPackSale._ActiveBrightList = false;
        MintPackSale._ActivePublic = false;
        MintPassSale._ActiveBrightList = false;
        MintPassSale._ActivePublic = false;
    }

    /**
     * @dev Withdraws All Ether From The Contract
     */
    function ___WithdrawEther() external onlyOwner { payable(msg.sender).transfer(address(this).balance); }

    /**
     * @dev Withdraws Ether From Contract To Address With An Amount
     */
    function ___WithdrawEtherToAddress(address payable Recipient, uint Amount) external onlyOwner
    {
        require(Amount > 0 && Amount <= address(this).balance, "Invalid Amount");
        (bool Success, ) = Recipient.call{value: Amount}("");
        require(Success, "Unable to Withdraw, Recipient May Have Reverted");
    }

    /**
     * @dev Withdraws ERC721s From Contract
     */
    function ___WithdrawERC721(address Contract, address Recipient, uint[] calldata TokenIDs) external onlyOwner 
    { 
        for(uint TokenID; TokenID < TokenIDs.length;)
        {
            IERC721(Contract).transferFrom(address(this), Recipient, TokenIDs[TokenID]);
            unchecked { TokenID++; }
        }
    }

    /*-----------------
     * VIEW FUNCTIONS *
    ------------------*/

    /**
     * @dev Returns An Array Of ArtistIDs Corresponding To Input TokenIDs 
     */
    function ViewArtistIDsByTokenIDs(uint[] calldata TokenIDs) public view returns(uint[] memory)
    {   
        uint[] memory _ArtistIDs = new uint[](TokenIDs.length);
        for(uint TokenID; TokenID < TokenIDs.length; TokenID++)
        {
            _ArtistIDs[TokenID] = ArtistID[TokenIDs[TokenID]];
        }
        return _ArtistIDs;
    }

    /**
     * @dev Returns An Array Of ArtistIDs Corresponding To TokenIDs 0-999
     */
    function ViewAllArtistIDs() public view returns(uint[] memory)
    {
        uint[] memory __ArtistIDs = new uint[](1000);
        for(uint TokenID; TokenID < 1000; TokenID++)
        {
            __ArtistIDs[TokenID] = ArtistID[TokenID];
        }
        return __ArtistIDs;
    }

    /**
     * @dev Returns A Singular ArtistID
     */
    function ViewArtistID(uint TokenID) public view returns(uint) { return ArtistID[TokenID]; }

    /**
     * @dev Returns MintPassPrice & MintPackPrice
     */
    function ViewBothDutchPrices() public view returns(uint MintPassPrice, uint MintPackPrice)
    {
        return(ViewCurrentPriceMintPass(), ViewCurrentPriceMintPack());
    }

    /**
     * @dev Returns Address & Corresponding Refund Amount At `OrderIndex`
     */
    function ViewOrderRefund(uint OrderIndex) public view returns(address Wallet, uint RefundAmount)
    {
        return(
            UniqueSaleIndexToAddress[OrderIndex], 
            UniqueSaleToOrderValue[OrderIndex] - (ViewCurrentPriceMintPass() * UniqueSalePurchaseAmount[OrderIndex])
        );
    }

    /**
     * @dev Returns All Order Information Including Addresses And Corresponding Refund Amounts
     */
    function ViewAllOrderRefunds() public view returns (address[] memory, uint[] memory)
    {
        address[] memory Addresses = new address[](MintPassInternalSale._UniqueSales);
        uint[] memory Refunds = new uint[](MintPassInternalSale._UniqueSales);
        uint CurrentPrice = ViewCurrentPriceMintPass();
        for(uint OrderIndex; OrderIndex < MintPassInternalSale._UniqueSales;)
        {
            Addresses[OrderIndex] = UniqueSaleIndexToAddress[OrderIndex];
            Refunds[OrderIndex] = UniqueSaleToOrderValue[OrderIndex] - (CurrentPrice * UniqueSalePurchaseAmount[OrderIndex]);
            unchecked { OrderIndex++; }
        }
        return(Addresses, Refunds);
    }

    /**
     * @dev Returns Total Refund Amount & Sale Purchase Value
     */
    function ViewTotalRefundAmountAndSaleProceeds() public view returns (uint Refund, uint SaleProceeds)
    {
        unchecked
        {
            uint TotalRefundAmount;
            uint CurrentPrice = ViewCurrentPriceMintPass();
            for(uint OrderIndex; OrderIndex < MintPassInternalSale._UniqueSales; OrderIndex++)
            {
                TotalRefundAmount += UniqueSaleToOrderValue[OrderIndex] - (CurrentPrice * UniqueSalePurchaseAmount[OrderIndex]);
            }
            uint TotalSaleProceeds = address(this).balance - TotalRefundAmount;
            return (TotalRefundAmount, TotalSaleProceeds);
        }
    }

    /**
     * @dev Returns A Wallet's Owned `TokenIDs` & Corresponding `ArtistIDs`
     */
    function ViewWalletMPMXHoldings(address Wallet) public view returns (MPMXHoldings memory _Holdings)
    {
        unchecked
        {
            uint[] memory __TokenIDsOwned = new uint[](1000);
            uint NumOwned;
            for(uint x; x < 1000; x++)
            {
                if(_exists(x))
                {
                    if(IERC721(address(this)).ownerOf(x) == Wallet)
                    {
                        __TokenIDsOwned[NumOwned] = x;
                        NumOwned++;
                    }
                }
            }
            uint[] memory _ArtistIDsOwned = new uint[](NumOwned);
            uint[] memory _TokenIDsOwned = new uint[](NumOwned);
            for(uint x; x < NumOwned; x++)
            {
                _ArtistIDsOwned[x] = ArtistID[__TokenIDsOwned[x]];
                _TokenIDsOwned[x] = __TokenIDsOwned[x];
            }
            return MPMXHoldings(
                _TokenIDsOwned, 
                _ArtistIDsOwned, 
                _ArtistsRevealedIDs, 
                _ArtistRevealedNames
            );
        }
    }

    /**
     * @dev Returns A Wallet's Owned `TokenIDs` & Corresponding `ArtistIDs`
     */
    function ViewWalletOptionHoldings(address Wallet) public view returns (UserHoldings memory _Holdings)
    {
        unchecked
        {
            uint[] memory __TokenIDsOwned = new uint[](333);
            uint NumOwned;
            for(uint x; x < 333; x++)
            {
                try IERC721(Option).ownerOf(x)
                {
                    if(IERC721(Option).ownerOf(x) == Wallet)
                    {
                        __TokenIDsOwned[NumOwned] = x;
                        NumOwned++;
                    }
                } catch { }
            }
            uint[] memory _ArtistIDsOwned = new uint[](NumOwned);
            uint[] memory _TokenIDsOwned = new uint[](NumOwned);
            for(uint x; x < NumOwned; x++)
            {
                _ArtistIDsOwned[x] = ArtistID[__TokenIDsOwned[x]];
                _TokenIDsOwned[x] = __TokenIDsOwned[x];
            }
            return UserHoldings(_TokenIDsOwned, _ArtistIDsOwned, MintPassInternalSale._FinalClearingPrice);
        }
    }

    /**
     * @dev Returns MPMX Sale Information
     */
    function ViewAllMPMXSaleInformation() public view returns (MintPass memory, MintPack memory, SaleInformation memory) 
    {
        return(
            MintPassSale,
            MintPackSale, 
            SaleInformation(
                ViewCurrentPriceMintPass(),
                MintPassSale._MaximumAvailableForSale - MintPassInternalSale._AmountSold,
                MintPassSale._StartingBlockUnixTimestamp,
                MintPassSale._PriceStart,
                MintPassSale._PriceEnd,
                ViewCurrentPriceMintPack(),
                MintPackSale._MaximumAvailableForSale - MintPackInternalSale._AmountSold,
                MintPackSale._StartingBlockUnixTimestamp,
                MintPackSale._PriceStart,
                MintPackSale._PriceEnd
            )
        );
    }

    /**
     * @dev Returns MPMX Sale Information For A Given Wallet
     */
    function ViewWalletSaleInformation(
        address Wallet,
        bytes32[] calldata MintPassProof,
        bytes32[] calldata MintPackProof
    ) external view returns (UserSaleInformation memory) {
        bool MintPassSalePaused;
        bool MintPackSalePaused;
        if(
            !(MintPassSale._ActiveBrightList || MintPassSale._ActivePublic)
            &&
            (MintPassSale._MaximumAvailableForSale - MintPassInternalSale._AmountSold > 0)
        ) { MintPassSalePaused = true; }
        if(
            !(MintPackSale._ActiveBrightList || MintPackSale._ActivePublic)
            &&
            (MintPackSale._MaximumAvailableForSale - MintPackInternalSale._AmountSold > 0)
        ) { MintPackSalePaused = true; }        
        return(
            UserSaleInformation(
                ViewCurrentPriceMintPass(),
                _MintPassPurchasedAmt[Wallet],
                _WalletAllocationsMintPass[Wallet], 
                MintPassSale._MaximumAvailableForSale - MintPassInternalSale._AmountSold,
                VerifyBrightList(Wallet, MintPassProof, MintPassSale._Root),
                MintPassSalePaused,
                ViewCurrentPriceMintPack(),
                _MintPackPurchasedAmt[Wallet],
                _WalletAllocationsMintPack[Wallet],
                MintPackSale._MaximumAvailableForSale - MintPackInternalSale._AmountSold,
                VerifyBrightList(Wallet, MintPackProof, MintPackSale._Root),
                MintPackSalePaused
            )
        );
    }

    /**
     * @dev Returns Mint Pack Starting Indexes
     */
    function ViewMintPackStartingIndexes() public view returns (uint[] memory)
    {
        uint[] memory _MintPackIndexes = new uint[](MintPackStartingIndexes.length);
        for(uint x; x < MintPackStartingIndexes.length; x++)
        {
            _MintPackIndexes[x] = MintPackStartingIndexes[x];
        }
        return _MintPackIndexes;
    }

    /*---------------------
     * INTERNAL FUNCTIONS *
    ----------------------*/

    /**
     * @dev Returns Current Dutch Price For Mint Pass
     */
    function ViewCurrentPriceMintPass() internal view returns (uint Price) 
    {
        if(block.timestamp <= MintPackSale._StartingBlockUnixTimestamp) { return MintPassSale._PriceStart; }  // Sale Not Started
        if(MintPassInternalSale._FinalClearingPrice > 0) { return MintPassInternalSale._FinalClearingPrice; } // Sale Finished
        uint CurrentPrice = MintPassSale._PriceStart;
        uint SecondsElapsed = block.timestamp - MintPassSale._StartingBlockUnixTimestamp;
        CurrentPrice >>= SecondsElapsed / MintPassSale._SecondsBetweenPriceDecay; // Div/2 For Each Half Life Iterated Upon
        CurrentPrice -= (CurrentPrice * (SecondsElapsed % MintPassSale._SecondsBetweenPriceDecay)) / MintPassSale._SecondsBetweenPriceDecay / 2;
        if(CurrentPrice <= MintPassSale._PriceEnd) { return MintPassSale._PriceEnd; } // Sale Ended At Resting Band
        return CurrentPrice; // Sale Currently Active
    }

    /**
     * @dev Returns Current Dutch Price For Mint Pack
     */
    function ViewCurrentPriceMintPack() internal view returns (uint Price) 
    {
        if(block.timestamp <= MintPackSale._StartingBlockUnixTimestamp) { return MintPackSale._PriceStart; }  // Sale Not Started
        if(MintPackInternalSale._FinalClearingPrice > 0) { return MintPackInternalSale._FinalClearingPrice; } // Sale Finished
        uint CurrentPrice = MintPackSale._PriceStart;
        uint SecondsElapsed = block.timestamp - MintPackSale._StartingBlockUnixTimestamp;
        CurrentPrice >>= SecondsElapsed / MintPackSale._SecondsBetweenPriceDecay; // Div/2 For Each Half Life Iterated Upon
        CurrentPrice -= (CurrentPrice * (SecondsElapsed % MintPackSale._SecondsBetweenPriceDecay)) / MintPackSale._SecondsBetweenPriceDecay / 2; 
        if(CurrentPrice <= MintPackSale._PriceEnd) { return MintPackSale._PriceEnd; } // Sale Ended At Resting Band
        return CurrentPrice; // Sale Currently Active
    }

    /**
     * @dev Returns Base URI
     */
    function _baseURI() internal view virtual override returns (string memory) { return baseURI; }

    /**
     * @dev Returns If User Is On BrightList
     */
    function VerifyBrightList(address Recipient, bytes32[] calldata Proof, bytes32 Root) internal pure returns (bool)
    {
        bytes32 Leaf = keccak256(abi.encodePacked(Recipient));
        return MerkleProof.verify(Proof, Root, Leaf);
    }

    /**
     * @dev Ends Mint Pass Sale On Sellout
     */
    function ___EndMintPassSale() internal
    {
        MintPassSale._ActiveBrightList = false;
        MintPassSale._ActivePublic = false;
    }

    /**
     * @dev Ends Mint Pack Sale On Sellout
     */
    function __EndMintPackSale() internal
    {
        MintPackSale._ActivePublic = false;
        MintPackSale._ActiveBrightList = false;
    }

    /**
     * @dev Refunds `Recipient` ETH Amount `Value`
     */
    function __Refund(address Recipient, uint Value) internal
    {
        (bool Confirmed,) = Recipient.call{value: Value}(""); 
        require(Confirmed, "MPMX: Refund failed");
        emit Refunded(Value);
    }

    /*--------------------
     * LIVEMINT FUNCTION *
    ---------------------*/

    /**
     * @dev LiveMint Redeems Mint Pass If Not Already Burned & Sends Minted Work To Owner's Wallet
     */
    function _LiveMintBurn(uint TokenID) external returns (address _Recipient, uint _ArtistID)
    {
        require(msg.sender == _LiveMint, "MPMX: Sender Is Not Live Mint");
        address Recipient = IERC721(address(this)).ownerOf(TokenID);
        require(Recipient != address(0), "MPMX: Invalid Recipient");
        _burn(TokenID, false);
        return (Recipient, ArtistID[TokenID]);
    }
}