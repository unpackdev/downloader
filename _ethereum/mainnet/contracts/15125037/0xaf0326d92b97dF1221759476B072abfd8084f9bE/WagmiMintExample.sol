// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.11;

import "./ERC721.sol";
import "./Base64.sol";

contract WagmiMintExample is ERC721 {
  uint256 public totalSupply;

  constructor() ERC721('wagmi', 'WAGMI') {}

  function mint() external {
    _safeMint(msg.sender, ++totalSupply);
  }

  function tokenURI(uint256 tokenId)
    public
    pure
    override
    returns (string memory)
  {
    string memory json = Base64.encode(
      bytes(
        string(
          abi.encodePacked(
            '{"name": "wagmi #', toString(tokenId), '", "image": "data:image/svg+xml;base64,',
            Base64.encode(
              bytes(
                '<svg width="1024" height="1024" viewBox="0 0 1024 1024" fill="none" xmlns="http://www.w3.org/2000/svg" style="background-color: black;"><path d="M869 401.5C869 410.613 861.612 418 852.5 418C843.388 418 836 410.613 836 401.5C836 392.387 843.388 385 852.5 385C861.612 385 869 392.387 869 401.5Z" fill="white"/><path d="M663.529 531C670.45 531 676.059 525.404 676.059 518.5V468.5C676.059 461.596 681.668 456 688.588 456H713.647C720.567 456 726.176 461.596 726.176 468.5V518.5C726.176 525.404 731.785 531 738.706 531C745.626 531 751.235 525.404 751.235 518.5V468.5C751.235 461.596 756.844 456 763.765 456H788.824C795.744 456 801.353 461.596 801.353 468.5V518.5C801.353 525.404 806.962 531 813.882 531H851.471C858.391 531 864 525.404 864 518.5V443.5C864 436.596 858.391 431 851.471 431C844.55 431 838.941 436.596 838.941 443.5V499.75C838.941 503.202 836.136 506 832.676 506C829.217 506 826.412 503.202 826.412 499.75V443.5C826.412 436.596 820.803 431 813.882 431H663.529C656.609 431 651 436.596 651 443.5V518.5C651 525.404 656.609 531 663.529 531Z" fill="white"/><path fill-rule="evenodd" clip-rule="evenodd" d="M122.655 506C115.723 506 110.103 500.404 110.103 493.5V443.5C110.103 436.596 104.484 431 97.5517 431C90.6196 431 85 436.596 85 443.5V518.5C85 525.404 90.6196 531 97.5517 531H248.172C255.105 531 260.724 525.404 260.724 518.5V468.5C260.724 461.596 266.343 456 273.276 456H417.621C421.086 456 423.897 458.798 423.897 462.25C423.897 465.702 421.086 468.5 417.621 468.5H285.828C278.895 468.5 273.276 474.096 273.276 481V518.5C273.276 525.404 278.895 531 285.828 531H436.448C443.381 531 449 525.404 449 518.5V443.5C449 436.596 443.381 431 436.448 431H248.172C241.24 431 235.621 436.596 235.621 443.5V493.5C235.621 500.404 230.002 506 223.069 506H197.966C191.033 506 185.414 500.404 185.414 493.5V443.5C185.414 436.596 179.794 431 172.862 431C165.93 431 160.31 436.596 160.31 443.5V493.5C160.31 500.404 154.691 506 147.759 506H122.655ZM423.897 499.75C423.897 503.202 421.086 506 417.621 506H304.655C301.19 506 298.379 503.202 298.379 499.75C298.379 496.298 301.19 493.5 304.655 493.5H417.621C421.086 493.5 423.897 496.298 423.897 499.75Z" fill="white"/><path fill-rule="evenodd" clip-rule="evenodd" d="M462 518.818C462 525.747 467.628 531.364 474.571 531.364H606.571C610.043 531.364 612.857 534.172 612.857 537.636C612.857 541.1 610.043 543.909 606.571 543.909H474.571C467.628 543.909 462 549.525 462 556.455C462 563.384 467.628 569 474.571 569H625.429C632.372 569 638 563.384 638 556.455V443.545C638 436.617 632.372 431 625.429 431H474.571C467.628 431 462 436.617 462 443.545V518.818ZM499.714 456.091C492.771 456.091 487.143 461.708 487.143 468.636V493.727C487.143 500.656 492.771 506.273 499.714 506.273H600.286C607.229 506.273 612.857 500.656 612.857 493.727V468.636C612.857 461.708 607.229 456.091 600.286 456.091H499.714Z" fill="white"/></svg>'
              )
            ),
            '"}'
          )
        )
      )
    );
    string memory output = string(
      abi.encodePacked('data:application/json;base64,', json)
    );
    return output;
  }

  function toString(uint256 value) internal pure returns (string memory) {
    // Inspired by OraclizeAPI's implementation - MIT licence
    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol

    if (value == 0) {
      return '0';
    }
    uint256 temp = value;
    uint256 digits;
    while (temp != 0) {
      digits++;
      temp /= 10;
    }
    bytes memory buffer = new bytes(digits);
    while (value != 0) {
      digits -= 1;
      buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
      value /= 10;
    }
    return string(buffer);
  }
}
