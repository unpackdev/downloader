// SPDX-License-Identifier: WAGDIE
//
//    ℑ𝔫 𝔉𝔬𝔯𝔰𝔞𝔨𝔢𝔫 𝔏𝔞𝔫𝔡𝔰, 𝔴𝔥𝔢𝔯𝔢 𝔰𝔥𝔞𝔡𝔬𝔴𝔰 𝔩𝔦𝔢,
//    𝔗𝔥𝔢 𝔱𝔞𝔩𝔢 𝔬𝔣 𝔄𝔰𝔱𝔞𝔯𝔬𝔱𝔥 𝔭𝔦𝔢𝔯𝔠𝔢𝔰 𝔰𝔨𝔶.
//    𝔅𝔬𝔫𝔢𝔰 𝔬𝔣 𝔯𝔢𝔡, 𝔞𝔫𝔡 𝔥𝔢𝔞𝔯𝔱 𝔞𝔟𝔩𝔞𝔷𝔢,
//    ℌ𝔦𝔰 𝔮𝔲𝔢𝔰𝔱, 𝔞 𝔯𝔢𝔩𝔢𝔫𝔱𝔩𝔢𝔰𝔰, 𝔟𝔲𝔯𝔫𝔦𝔫𝔤 𝔯𝔞𝔤𝔢.
//
//
//    𝔄𝔤𝔞𝔦𝔫𝔰𝔱 𝔗𝔥𝔢 𝔊𝔩𝔲𝔱𝔱𝔬𝔫, 𝔞 𝔟𝔢𝔞𝔰𝔱𝔩𝔶 𝔪𝔦𝔤𝔥𝔱,
//    𝔉𝔢𝔞𝔱𝔥𝔢𝔯𝔰 𝔞𝔫𝔤𝔢𝔩𝔦𝔠, 𝔟𝔲𝔱 𝔣𝔞𝔩𝔰𝔢 𝔦𝔫 𝔩𝔦𝔤𝔥𝔱.
//    𝔗𝔥𝔯𝔬𝔲𝔤𝔥 𝔟𝔞𝔱𝔱𝔩𝔢, 𝔱𝔥𝔢𝔦𝔯 𝔣𝔲𝔯𝔶 𝔯𝔬𝔞𝔯𝔢𝔡,
//    𝔖𝔱𝔢𝔢𝔩 𝔞𝔫𝔡 𝔥𝔦𝔡𝔢, 𝔞 𝔗𝔲𝔯𝔩𝔬 𝔰𝔠𝔬𝔯𝔫𝔢𝔡.
//
//
//    𝔖𝔴𝔞𝔩𝔩𝔬𝔴𝔢𝔡 𝔴𝔥𝔬𝔩𝔢 𝔟𝔶 𝔊𝔩𝔲𝔱𝔱𝔬𝔫'𝔰 𝔪𝔞𝔴,
//    𝔗𝔥𝔢 𝔡𝔢𝔪𝔬𝔫'𝔰 𝔭𝔩𝔞𝔫 𝔱𝔬 𝔣𝔞𝔱𝔞𝔩 𝔣𝔩𝔞𝔴.
//    𝔄𝔠𝔬𝔩𝔶𝔱𝔢𝔰 𝔴𝔥𝔦𝔰𝔭𝔢𝔯 𝔦𝔫 𝔫𝔦𝔤𝔥𝔱'𝔰 𝔢𝔪𝔟𝔯𝔞𝔠𝔢,
//    ℭ𝔞𝔯𝔯𝔶𝔦𝔫𝔤 𝔣𝔬𝔯𝔱𝔥 𝔥𝔦𝔰 𝔲𝔫𝔣𝔲𝔩𝔣𝔦𝔩𝔩𝔢𝔡 𝔠𝔥𝔞𝔰𝔢.
//
//
//    ℑ𝔫 𝔱𝔥𝔢𝔦𝔯 𝔥𝔢𝔞𝔯𝔱𝔰, 𝔥𝔦𝔰 𝔣𝔲𝔯𝔶 𝔡𝔬𝔱𝔥 𝔟𝔲𝔯𝔫,
//    𝔄𝔰𝔱𝔞𝔯𝔬𝔱𝔥'𝔰 𝔳𝔢𝔫𝔤𝔢𝔞𝔫𝔠𝔢, 𝔱𝔥𝔢𝔶 𝔰𝔢𝔢𝔨 𝔱𝔬 𝔢𝔞𝔯𝔫.
//    ℑ𝔫 𝔴𝔥𝔦𝔰𝔭𝔢𝔯𝔰, 𝔦𝔫 𝔰𝔥𝔞𝔡𝔬𝔴𝔰, 𝔦𝔫 𝔮𝔲𝔦𝔢𝔱 𝔬𝔣 𝔫𝔦𝔤𝔥𝔱,
//    ℌ𝔦𝔰 𝔰𝔭𝔦𝔯𝔦𝔱 𝔢𝔫𝔡𝔲𝔯𝔢𝔰, 𝔦𝔫 𝔱𝔥𝔢𝔦𝔯 𝔴𝔦𝔩𝔩 𝔱𝔬 𝔣𝔦𝔤𝔥𝔱.
//
//

pragma solidity ^0.8.0;

interface IERC721 {
    function transferFrom(address from, address to, uint256 tokenId) external;

    function transfer(address to, uint256 tokenId) external;
}

interface IConcord {
    function bestowTokensMany(
        address[] calldata _to,
        uint256[] calldata _tokens,
        uint256[] calldata _amounts
    ) external;
}

contract AstarothsVengeance {
    address constant burnAddress =
        address(0x000000000000000000000000000000000000dEaD);
    address constant wagdieAuthor =
        address(0x8d2Eb1c6Ab5D87C5091f09fFE4a5ed31B1D9CF71);

    bool public vengeanceAchieved = false;

    struct Acolytes {
        uint256 wagdieTokenId;
        uint256 acolyteTokenId;
        bool vengeanceAgreed;
    }

    mapping(address => Acolytes) private submissions;
    address[] private acolyteAddresses;

    IERC721 public wagdieContract;
    IERC721 public acolyteContract;
    IConcord public concordContract;

    constructor() {
        wagdieContract = IERC721(
            address(0x659A4BdaAaCc62d2bd9Cb18225D9C89b5B697A5A)
        );
        acolyteContract = IERC721(
            address(0xE7061488cE937012dadee6F82608cB5becaFF8D9)
        );
        concordContract = IConcord(
            address(0x1d38150f1Fd989Fb89Ab19518A9C4E93C5554634)
        );
    }

    // Acolytes arrive to demand vengeance for Astaroth
    function sendAcolyte(uint256 wagdieTokenId, uint256 acolyteTokenId) public {
        require( submissions[msg.sender].wagdieTokenId == 0 && submissions[msg.sender].acolyteTokenId == 0, "This address has already sent an Acolyte." );
        require(acolyteTokenId >= 31 && acolyteTokenId <= 43,"This AKIB Hero is not an Acolyte of Astaroth.");
        require(!vengeanceAchieved, "Cannot join the pact, after vengeance has been achieved.");

        wagdieContract.transferFrom(msg.sender, address(this), wagdieTokenId);
        acolyteContract.transferFrom(msg.sender, address(this), acolyteTokenId);

        // Upon entry, arrive with a sense of unfulfilled vengeance
        acolyteAddresses.push(msg.sender);
        submissions[msg.sender] = Acolytes(
            wagdieTokenId,
            acolyteTokenId,
            false
        );
    }

    // Once Vengeance has been granted and agreed, Acolytes may return
    function returnAcolyte() public {
        require(vengeanceAchieved, "Vengeance has not yet been achieved.");

        for (uint i = 0; i < acolyteAddresses.length; i++) {
            require(submissions[acolyteAddresses[i]].vengeanceAgreed, "Not all Acolytes have agreed to vengeance.");
        }

        Acolytes storage submission = submissions[msg.sender];

        require(submission.wagdieTokenId > 0 && submission.acolyteTokenId > 0, "No Acolyte from this address is present.");

        // Transfer the tokens back to the sender
        wagdieContract.transfer(msg.sender, submission.wagdieTokenId);
        acolyteContract.transfer(msg.sender, submission.acolyteTokenId);

        // Remove the user's address from acolyteAddresses
        _removeAddressFromSubmitters(_findAddressIndex(msg.sender));
    }

    // The Two may slay random Acolytes
    function slayAcolyte() public {
        require(
            msg.sender == wagdieAuthor,
            "Fates can only be controlled by The Two."
        );
        require(acolyteAddresses.length > 0, "No acolytes to slay.");

        // Select Random Acolyte
        uint256 rng = _getPseudoRandomNumber();
        uint256 submitterCount = acolyteAddresses.length;
        uint256 selectedAddressIndex = rng % submitterCount;
        address selectedAddress = acolyteAddresses[selectedAddressIndex];

        // Burn Acolyte Token Pair
        wagdieContract.transferFrom(
            address(this),
            burnAddress,
            submissions[selectedAddress].wagdieTokenId
        );
        acolyteContract.transferFrom(
            address(this),
            burnAddress,
            submissions[selectedAddress].acolyteTokenId
        );

        // Remove Acolyte From Set
        _removeAddressFromSubmitters(selectedAddressIndex);
    }

    // The Two grant an opportunity at vengeance
    function grantVengeance() public {
        require(
            msg.sender == wagdieAuthor,
            "Vengeance can only be granted by The Two."
        );

        vengeanceAchieved = true;

    }

    // Individual Acolyte agrees to vengeance
    function agreeVengeance() public {
        require(
            submissions[msg.sender].wagdieTokenId != 0,
            "No Acolyte from this address is present."
        );

        submissions[msg.sender].vengeanceAgreed = true;

    }

    // Random number generator
    function _getPseudoRandomNumber() private view returns (uint256) {
        return
            uint256(
                keccak256(
                    abi.encodePacked(
                        blockhash(block.number - 1),
                        block.timestamp
                    )
                )
            );
    }

    // Locate address index within array (for removals)
    function _findAddressIndex(address addr) private view returns (uint256) {
        for (uint256 i = 0; i < acolyteAddresses.length; i++) {
            if (acolyteAddresses[i] == addr) {
                return i;
            }
        }
        revert("Address not found in acolyteAddresses.");
    }

    // Remove address from array by index (does not affect memory)
    function _removeAddressFromSubmitters(uint256 index) private {
        uint256 lastAddressIndex = acolyteAddresses.length - 1;
        acolyteAddresses[index] = acolyteAddresses[lastAddressIndex];
        acolyteAddresses.pop();
    }
}