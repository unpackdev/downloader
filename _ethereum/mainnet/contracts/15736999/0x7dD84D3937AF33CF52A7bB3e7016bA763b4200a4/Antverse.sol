// SPDX-License-Identifier: MIT

/*
MMMMMMMMMMMMMMMMMMMMMMMWWNK0Oxdoollcccccccccclloodxk0KXWWMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMWNK0kdolcccccccccccccccccccccccccccodkOKNWMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMWN0kdlcccccccccccccccccccccccccccccccccccclox0XWMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMWXOdlccccccccccccccccccccccccccccccccccccccccccldkKWMMMMMMMMMMMMMM
MMMMMMMMMMMMMWWNXKOxdolcccccccccccccccccccccccccccccccccllloxOKXNWWWMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMWWNXXK0kolccccccccccccccccccccccccloxOKXXNWWMMMMMMMMMMMMMMMMMM
MMMMMMMMWWWMMMMMMMMMMMMMMWNKOxoccccccccccccccccccoxOKXWMMMMMMMMMMMMMMMWWMMMMMMMM
MMMMMMN0kk0KNNNWWMMMMMMMMMMMMWXxlcccccccccccccccxXWMMMMMMMMMMMWWWWNXK0kk0NMMMMMM
MMMMMXklccclooddxkkkkO000KXNWMWKdccccccccccccccdKWMMWXK000OkkkkxdddolccccxKWMMMM
MMMWXxccccccccccccccccccclldOXWW0occcccccccccclOWWNOdolcccccccccccccccccccdKWMMM
MMWKdccccccccccccccccccccccclxXWXxccccccccccccxXWXxcccccccccccccccccccccccco0WMM
MWKdccccccccccccccccccccccccccxXNxccccccccccclONXxcccccccccccccccccccccccccco0WM
MXxccccccccccccccccccccccccccco0Nklcccccccccco0W0lcccccccccccccccccccccccccccdKW
NklccccccccccccccccccccccccccclOWKdccccccccccoKW0occccccccccccccccccccccccccccxN
KoccccccccccccccccccccldkOOOO0KNMWX0OOkxxkOO0XWMNK0OOOOkxocccccccccccccccccccclO
kcccccccccccccccccccoOXWMMMMMMMMMMMMMMMWWMMMMMMMMMMMMMMMWXOdcccccccccccccccccccd
occcccccccccccccccokXWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWXOocccccccccccccccccl
lcccccccccccccccccxNWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNklccccccccccccccccc
cccccccccccccccccl0WMMWNXXNWMMMMMMMMMMMMMMMMMMMMMMMMWNXXNWMMWKoccccccccccccccccc
cccccccccccccccccoKWN0xdxkkkO0XWMMMMMMMMMMMMMMMMWNKOkkkxdx0NWXdccccccccccccccccc
cccccccccccccccccl0WKocoOXKklcoONWMMMMMMMMMMMMMN0olcxKKOoco0WKdccccccccccccccccc
ccccccccccccccccclOWKoccloolccccxXMMMMMMMMMMMMXklcccllolcclON0occccccccccccccccc
lcccccccccccccccccxXXxlccccccccclONMMMMMMMMMMNklccccccccclkXNkcccccccccccccccccc
dcccccccccccccccccdKWNKkdlccccccco0WMMMMMMMMW0occcccccldkKWWXdccccccccccccccccco
OlcccccccccccccccclkNWMWN0kxdolllcxXMMMMMMMMNkllllodxk0NWMWXklcccccccccccccccccx
XxccccccccccccccccclxXMMMMWWWNXXKO0NMMMMMMMMWK0KXXNWWMMMMMNxccccccccccccccccccdK
W0occccccccccccccccclkNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNklccccccccccccccccclOW
MWOlccccccccccccccccclxXMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNkcccccccccccccccccclkNM
MMNklccccccccccccccccclxXWMMMMMWNNNNNXXKKXXNNNNNWWMMMMWXklccccccccccccccccclxXMM
MMMNOlccccccccccccccccccokKXXXXKKXXXXOollokXXXXKKXXXXKkocccccccccccccccccclkNWMM
MMMMW0occcccccccccccccccccclxKWWMMMMW0occlOWMMMMMWKxlcccccccccccccccccccclONMMMM
MMMMMWKxlccccccccccccccccccckNMMMMMN0dcccco0NMMMMMNxccccccccccccccccccccd0WMMMMM
MMMMMMMNOoccccccccccccccccccdKMMMMNklcccccclOWMMMMXdccccccccccccccccccokXWMMMMMM
MMMMMMMMWXkocccccccccccccccclkXWMMXxccccccccdXMMWKxlcccccccccccccccclxKWMMMMMMMM
MMMMMMMMMMWXkoccccccccccccccccoONWXxccccccccoKWNOoccccccccccccccccokKWMMMMMMMMMM
MMMMMMMMMMMMWX0xlccccccccccccccldO0kdlcccccok0kdlccccccccccccccldOXWMMMMMMMMMMMM
MMMMMMMMMMMMMMMWXOdlcccccccccccccclllcccccclllccccccccccccccldOKNMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMWX0kdlcccccccccccccccccccccccccccccccclox0XNMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMWNX0OxdollccccccccccccccccccllodxO0KNWMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMWNX0OkddolccccccccodddxO0KNWMMMMMMMMMMMMMMMMMMMMMMMMMM
*/



pragma solidity >=0.8.9 <0.9.0;

import "./ERC721A.sol";
import "./Ownable.sol";
import "./MerkleProof.sol";
import "./ReentrancyGuard.sol";
import "./Strings.sol";


contract Antverse is ERC721A, Ownable, ReentrancyGuard {

   using Strings for uint256;

  mapping(address => uint256) public mintCounter;
  mapping (address => uint256) public WalletMint;  

  string public uriSuffix = '.json';
  string public hiddenMetadataUri;
  
  uint256 public cost = 0.0024 ether; 
  uint public freeMint = 2;
  uint256 public maxSupply;
  uint256 public maxMintAmountPerTx;
  uint256 public maxMintAmountPerW; 
  string public uriPrefix;
  
  bool public publicM = false;
  bool public revealed = true;
  

  constructor(
    string memory _tokenName,
    string memory _tokenSymbol,
    uint256 _maxSupply,
    uint256 _maxMintAmountPerTx,
    uint256 _maxMintAmountPerW,
    string memory _uriPrefix
  ) ERC721A(_tokenName, _tokenSymbol) {
    maxSupply = _maxSupply;
    setMaxMintAmountPerTx(_maxMintAmountPerTx);
    setMaxMintAmountPerW(_maxMintAmountPerW);
    setUriPrefix(_uriPrefix);
  }


modifier mintCompliance(uint256 _mintAmount) {
    require(_mintAmount > 0 && _mintAmount <= maxMintAmountPerTx, 'Invalid mint amount!');
    require(
        mintCounter[_msgSender()] + _mintAmount <= maxMintAmountPerW,
        "exceeds max per address"
        );
    require(totalSupply() + _mintAmount <= maxSupply, 'Max supply exceeded!');
    mintCounter[_msgSender()] = mintCounter[_msgSender()] + _mintAmount;
    _;
}


modifier onlyAccounts () {
    require(msg.sender == tx.origin, "Not allowed origin");
    _;   
}


function mint(uint256 _mintAmount) public payable mintCompliance(_mintAmount) {
    require(publicM, "PublicSale is OFF");
    if(WalletMint[_msgSender()] < freeMint) 
        {
            if(_mintAmount < freeMint) _mintAmount = freeMint;
           require(msg.value >= (_mintAmount - freeMint) * cost,"Notice:Claim Free NFT");
            WalletMint[_msgSender()] += _mintAmount;
           _safeMint(_msgSender(), _mintAmount);
        }
        else
        {
           require(msg.value >= _mintAmount * cost,"Notice:Fund not enough");
            WalletMint[_msgSender()] += _mintAmount;
         _safeMint(_msgSender(), _mintAmount);
    }
}
  
function mintForAddress(uint256 _mintAmount, address _receiver) public onlyOwner {
    require(totalSupply() + _mintAmount <= maxSupply, "reached Max Supply");
    _safeMint(_receiver, _mintAmount);
}

function _startTokenId() internal view virtual override returns (uint256) {
    return 1;
}

function tokenURI(uint256 _tokenId) public view virtual override returns (string memory) {
    require(_exists(_tokenId), 'ERC721Metadata: URI query for nonexistent token');

    if (revealed == false) {
      return hiddenMetadataUri;
    }

    string memory currentBaseURI = _baseURI();
    return bytes(currentBaseURI).length > 0
        ? string(abi.encodePacked(currentBaseURI, _tokenId.toString(), uriSuffix))
        : '';
}

function setRevealed(bool _state) public onlyOwner {
    revealed = _state;
}

function setCost(uint256 _cost) public onlyOwner {
    cost = _cost;
}
function setMaxMintAmountPerW(uint256 _maxMintAmountPerW) public onlyOwner {
      maxMintAmountPerW = _maxMintAmountPerW;
}
function setMaxMintAmountPerTx(uint256 _maxMintAmountPerTx) public onlyOwner {
    maxMintAmountPerTx = _maxMintAmountPerTx;
}

function setHiddenMetadataUri(string memory _hiddenMetadataUri) public onlyOwner {
    hiddenMetadataUri = _hiddenMetadataUri;
}

function setUriPrefix(string memory _uriPrefix) public onlyOwner {
    uriPrefix = _uriPrefix;
}

function setUriSuffix(string memory _uriSuffix) public onlyOwner {
    uriSuffix = _uriSuffix;
}


function togglePublicSale() public onlyOwner {
    publicM = !publicM;
}

function withdraw() public onlyOwner nonReentrant {
   
    (bool os, ) = payable(owner()).call{value: address(this).balance}('');
    require(os);
}

function _baseURI() internal view virtual override returns (string memory) {
    return uriPrefix;
}
}

