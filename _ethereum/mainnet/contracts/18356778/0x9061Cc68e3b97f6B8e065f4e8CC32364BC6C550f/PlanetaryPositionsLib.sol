// SPDX-License-Identifier: MIT
pragma solidity ^0.8.16;

import "./IPlanetaryPositions.sol";
import "./Trigonometry.sol";
import "./Math.sol";
// import "./console.sol";

/**
 * @notice This library compute the planetary positions of the moon, the sun, and the 7 others planet of 
 *         the solarsystem.
 *         Planetary positions can be computed in ecliptic longitude/latitude, in 
 *         right ascension/declination, both geocentric and topocentric, and in azimuth/altitude.
 *         The algorithms are from Paul Schlyter, who published them at 
 *         https://stjarnhimlen.se/comp/tutorial.html, 
 *         as well as examples at https://stjarnhimlen.se/comp/ppcomp.html.
 *         Some comments from his website were copied into here for better clarity.
 *         All numbers are scaled by 1e18.
 */
library PlanetaryPositionsLib {


  /**
   * @notice Since solidity doesn't support constant arrays.... Here are the constants to compute the orbital 
   *         elements of the 10 bodies!
   *         For Sun and Moon, Earth is the origin, otherwise Sun is the origin.
   *         Each orbital elements (N, i, w, a, e, M) for a body each need 2 constants to be computed.
   *         So we have 12 constants per body, and 120 total.
   *         These constants are in radians, encoded as int64, and their value are scaled by 1e18, with the 
   *         exception of a1 (the seventh value) which is scaled by 1e16.
   *         These values were fetched, as all the algorithms, from Paul Schlyter website, and the below 
   *         bytes array was generated by generateOrbitalElementsBytesArray.js.
   */
  bytes constant orbitalElementsConstantsTable = hex"00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_44_88_28_8a_8a_b9_90_7b_00_00_00_bf_5f_3d_ad_f7_00_23_86_f2_6f_c1_00_00_00_00_00_00_00_00_00_00_00_3b_5c_bf_39_8d_50_00_ff_ff_ff_ff_bb_65_22_40_56_3d_3f_1a_06_48_3f_2d_00_3d_1d_19_a8_98_ec_83_0b_b4_db_72_e6_be_aa_f2_00_00_00_83_e6_b2_af_fd_01_b2_56_58_86_ff_cd_ca_00_00_00_00_34_03_ce_31_07_0d_e2_8e_fa_95_ac_75_00_00_00_29_39_31_22_df_00_0d_c0_a2_c3_d5_28_00_00_00_00_00_00_00_00_00_02_da_8f_f1_68_63_30_00_00_00_00_00_21_51_a9_c0_28_d9_ca_0e_39_3e_32_e0_00_fd_c0_65_34_9f_b5_92_12_92_a7_f8_84_8c_b2_4f_00_00_00_64_34_b0_ee_99_00_d2_7c_c8_c1_56_4c_53_00_00_00_00_1c_9b_b1_68_0d_4b_9a_02_22_e1_f2_0f_00_00_00_38_3b_02_86_db_00_19_b2_a5_e5_0d_c8_00_00_00_00_00_00_00_00_00_00_18_10_01_f3_10_50_00_ff_ff_ff_ff_b2_65_0e_80_0b_a0_a3_0a_f0_f3_2f_0e_00_63_57_b2_a3_fe_33_27_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_18_ee_fa_aa_e8_87_47_93_00_00_00_bf_5f_3d_ad_f7_00_23_86_f2_6f_c1_00_00_00_00_00_00_00_00_00_00_00_3b_5c_bf_39_8d_50_00_ff_ff_ff_ff_bb_65_22_40_56_3d_3f_1a_06_48_3f_2d_00_3d_1d_19_a8_98_ec_83_1e_4e_6e_ec_06_10_a6_0a_ff_fc_b7_6d_a8_28_64_7b_01_3f_0c_6b_03_99_5f_03_00_00_00_00_00_00_00_00_4d_0a_03_b3_7b_26_df_46_00_0a_30_f4_7e_c1_e5_b3_08_5d_19_88_b0_34_a0_00_00_00_00_00_00_00_00_00_00_c3_0b_42_56_2b_40_00_00_00_00_00_00_00_00_00_1b_f1_69_1a_f3_1e_bb_9c_03_2a_1d_7a_a5_f3_a3_f7_0c_00_e2_2a_0f_45_48_7c_00_00_00_55_c6_b3_0f_80_00_72_b1_8a_5d_4f_f4_e7_ff_ff_ff_ff_ed_7b_92_c2_45_64_f9_e1_46_60_95_27_00_00_00_77_0c_a7_5c_71_00_36_21_dc_93_e2_a0_00_00_00_00_00_00_00_00_00_01_4b_d7_5a_45_3e_d0_00_00_00_00_00_95_f7_1d_00_04_81_73_ba_73_70_4c_a5_00_20_7e_22_f7_77_6c_28_18_54_d1_88_1b_3f_c7_88_00_00_00_70_81_0c_01_1b_00_50_cb_66_b6_f5_53_20_ff_ff_ff_ff_5e_06_94_f3_42_56_36_2a_fe_a7_74_0c_00_00_00_42_d9_69_26_b7_00_b8_d5_01_ef_3a_00_00_00_00_00_00_00_00_00_00_00_ac_4c_ac_8e_51_20_00_00_00_00_01_0a_5f_87_40_04_d1_9e_ce_2f_a8_a4_e2_00_05_26_de_85_6e_63_3d_1b_87_e0_1b_5d_23_3f_1d_00_00_00_61_1d_06_5f_81_00_9a_4f_3b_96_cd_1e_82_ff_ff_ff_ff_8f_8b_3a_87_52_34_a5_2b_82_20_64_10_00_00_00_78_f5_97_ee_ad_01_53_73_f1_ec_ad_38_00_00_00_00_00_00_00_00_00_00_c5_56_ca_ee_b1_a0_00_ff_ff_ff_fd_c9_d0_c3_40_4c_c6_07_cd_32_8a_95_a2_00_02_12_e2_04_52_ff_40_11_ec_84_0a_58_c0_dd_90_00_00_00_38_cd_46_92_5b_00_2f_f3_1d_4e_b7_d3_d5_00_00_00_00_13_c4_01_8d_17_69_a0_ac_ad_44_b9_74_00_00_00_7c_34_af_df_30_02_a9_78_a2_db_58_78_00_ff_ff_ff_fc_64_20_c5_00_00_a8_1b_78_65_7b_60_00_00_00_00_01_bc_0d_fa_80_22_89_8b_8d_0f_76_5b_f6_00_00_ba_21_b4_54_e6_da_1f_eb_42_b0_6f_69_9a_8b_00_00_00_7a_9c_e3_f5_04_00_6d_c0_68_8e_70_06_6f_ff_ff_ff_fe_f6_b9_64_68_42_16_3e_e1_f7_22_e1_0e_ff_ff_ff_e7_82_20_cf_9f_04_2b_e2_48_3a_a9_d0_00_00_00_00_07_b6_b3_ae_80_00_1e_93_1c_84_ef_e0_00_00_00_00_00_80_26_65_80_3f_09_06_6c_da_34_0c_0f_00_00_5f_2a_3f_3d_f8_74";


  // The value for Earth
  int constant EarthAxialTiltValue = 0.409093 * 1e18;
  int constant EarthAxialTiltDeltaValue = - 0.000000006217 * 1e18;




  /**
   * @notice All the algorithms are using a specific time scale that can be computed using either:
   *         - getDayNumberFromTimestamp()
   *         - getDayNumberFromGregorianCalendar()
   *         - getDayNumberFromGregorianCalendar1900to2100() (only valid from year 1900 to 2100)
   *         We will call these dates a "day number".
   *
   *         Informations about this time scale : 
   *         The time scale in these formulae are counted in days. Hours, minutes, seconds are 
   *         expressed as fractions of a day. Day 0.0 occurs at 2000 Jan 0.0 UT (or 1999 Dec 31, 
   *         0:00 UT). This "day number" d is computed as follows (y=year, m=month, D=date, UT=UT
   *         in hours+decimals):
   *
   *         d = 367*y - 7 * ( y + (m+9)/12 ) / 4 + 275*m/9 + D - 730530
   *
   *         Note that the formula above is only valid from March 1900 to February 2100.
   *         Below is another formula, which is valid over the entire Gregorian Calendar:
   *
   *         d = 367*y - 7 * ( y + (m+9)/12 ) / 4 - 3 * ( ( y + (m-9)/7 ) / 100 + 1 ) / 4 + 275*m/9 + D - 730515
   *
   *         Note that ALL divisions here should be INTEGER divisions (get the floor of the division).
   *         Finally, include the time of the day, by adding:
   *
   *         d = d + UT/24.0        (this is a floating-point division)
   */

  /**
   * @notice Generate a "day number" time from a given unix timestamp.
   * @param timestamp An unix timestamp
   * @return A "day number" to be used in the various functions as time input. (scaled by 1e18)
   */
  function getDayNumberFromTimestamp(uint timestamp) internal pure returns (int) {
    return (int(timestamp) - 946598400) * 1e18 / (3600 * 24);
  }

  /**
   * @notice Generate a "day number" time from a given date.
   * @param year The year
   * @param month The month, in the 1-12 range
   * @param day The day, in the 1-31 range
   * @param hour The hour, in the 1-23 range
   * @param min The minute, in the 0-59 range
   * @return A "day number" to be used in the various functions as time input. (scaled by 1e18)
   */
  function getDayNumberFromGregorianCalendar(uint year, uint month, uint day, uint hour, uint min) internal pure returns (int) {
    int d = 367 * int(year) - 7 * (int(year) + (int(month) + 9) / 12) / 4 - 3 * ((int(year) + (int(month) - 9) / 7) / 100 + 1) / 4 + 275 * int(month) / 9 + int(day) - 730515;

    return d * 1e18 + int(hour * 1e18 / 24) + int(min * 1e18 / (24*60));
  }

  /**
   * @notice Generate a "day number" time from a given date. Only valid from mars 1900 to feb 2100.
   * @param year The year
   * @param month The month, in the 1-12 range
   * @param day The day, in the 1-31 range
   * @param hour The hour, in the 1-23 range
   * @param min The minute, in the 0-59 range
   * @return A "day number" to be used in the various functions as time input. (scaled by 1e18)
   */
  function getDayNumberFromGregorianCalendar1900to2100(uint year, uint month, uint day, uint hour, uint min) internal pure returns (int) {
    int d = int(367 * year - 7 * (year + (month + 9) / 12) / 4 + 275 * month / 9 + day) - 730530;

    return d * 1e18 + int(hour * 1e18 / 24) + int(min * 1e18 / (24*60));
  }



  /**
   * @notice For a given observer positioned on earth, returns the azimuth and altitude of a specific 
   *         celestial body.
   * @param observerLongitude The longitude of the observer on earth. In degrees, scaled by 1e18.
   * @param observerLatitude The latitude of the observer on earth. In degrees, scaled by 1e18.
   * @param body The celestial body to look for
   * @param dayNumber The time of the observation, in the custom "day number" format (see above; scaled by 1e18)
   * @return azimuth The azimuth where the body is, in degrees, in the range 0:360, scaled by 1e18
   * @return altitude The altitude where the body is, in degrees, in the range -90:90, scaled by 1e18.
   * @return distance The distance to the body, in astronomical units (AU), or earth radii for the moon,
   *                 scaled by 1e18.
   */
  function getBodyAzimuthAltitude(int observerLongitude, int observerLatitude, IPP.CelestialBody body, int dayNumber) internal pure returns (int azimuth, int altitude, uint distance) {

    // Convert args to radians
    observerLongitude = observerLongitude * (int(Trigo.PI) / 180) / 1e18;
    observerLatitude = observerLatitude * (int(Trigo.PI) / 180) / 1e18;

    (azimuth, altitude, distance) = getBodyAzimuthAltitudeInRadians(observerLongitude, observerLatitude, body, dayNumber);

    // Convert result to degrees
    azimuth = azimuth * 1e18 / int(Trigo.PI / 180);
    altitude = altitude * 1e18 / int(Trigo.PI / 180);
  }

  /**
   * @notice For a given observer positioned on earth, returns the azimuth and altitude of a specific 
   *         celestial body. Version with everything in radians.
   * @param observerLongitude The longitude of the observer on earth. In radians, scaled by 1e18.
   * @param observerLatitude The latitude of the observer on earth. In radians, scaled by 1e18.
   * @param body The celestial body to look for
   * @param dayNumber The time of the observation, in the custom "day number" format (see above; scaled by 1e18)
   * @return azimuth The azimuth where the body is, in radians, in the range 0:2pi, scaled by 1e18
   * @return altitude The altitude where the body is, in radians, in the range -pi/2:pi/2, scaled by 1e18.
   * @return distance The distance to the body, in astronomical units (AU), or earth radii for the moon,
   *                 scaled by 1e18.
   */
  function getBodyAzimuthAltitudeInRadians(int observerLongitude, int observerLatitude, IPP.CelestialBody body, int dayNumber) internal pure returns (int azimuth, int altitude, uint distance) {

    IPP.OrbitalElements memory orbitalElements = getOrbitalElements(body, dayNumber);
    
    // Origin will be the earth
    IPP.OrbitalElements memory newOriginOrbitalElements;
    if(orbitalElements.origin == IPP.CelestialBody.EARTH) {
      // No need to specify a new origin
    } else if(orbitalElements.origin == IPP.CelestialBody.SUN) {
      newOriginOrbitalElements = getOrbitalElements(IPP.CelestialBody.EARTH, dayNumber);
    } else {
      revert("Origin must be sun or earth");
    }

    // Earth axias tilt
    IPP.AxialTilt memory earthAxialTilt = IPP.AxialTilt({
      at: EarthAxialTiltValue,
      dat: EarthAxialTiltDeltaValue
    });

    // Get the local sideral time at the observer location
    int sidTime = getLocalSiderealTimeInRadians(observerLongitude, dayNumber);

    (azimuth, altitude, distance) = getBodyBodyAzimuthAltitudeInRadians(orbitalElements, earthAxialTilt, newOriginOrbitalElements, observerLongitude, observerLatitude, sidTime);
  }

  /**
   * @notice For a given observer positioned on a celestial body, returns the azimuth and altitude of another
   *         specific celestial body.
   * @param orbitalElements The orbital elements of the body we look at.
   * @param originAxialTilt The axial tilt of the body where we are looking from
   * @param newOriginOrbitalElements By default, the body we are looking from is the body at the center
   *                                 of the orbit. You can override this (e.g. look at mars from venus)
   *                                 Note: This is likely buggy for planets != earth due to different
   *                                 axial tilt orientation, not tested
   * @param observerLongitude The longitude of the observer on earth. In radians, scaled by 1e18.
   * @param observerLatitude The latitude of the observer on earth. In radians, scaled by 1e18.
   * @return azimuth The azimuth where the body is, in radians, in the range 0:2pi, scaled by 1e18
   * @return altitude The altitude where the body is, in radians, in the range -pi/2:pi/2, scaled by 1e18.
   * @return distance The distance to the body, in astronomical units (AU), or earth radii for the moon,
   *                 scaled by 1e18.
   */
  function getBodyBodyAzimuthAltitudeInRadians(IPP.OrbitalElements memory orbitalElements, IPP.AxialTilt memory originAxialTilt, IPP.OrbitalElements memory newOriginOrbitalElements, int observerLongitude, int observerLatitude, int localSiderealTime) internal pure returns (int azimuth, int altitude, uint distance) {

    int x;
    int y;
    int z;

    { // Stack too deeep

      // Get the body topocentric right ascension / declination
      int rightAscension; 
      int declination;
      (rightAscension, declination, distance) = getBodyBodyTopocentricRADeclInRadians(orbitalElements, originAxialTilt, newOriginOrbitalElements, observerLongitude, observerLatitude);

      // Determine the hour angle
      int ha = localSiderealTime - rightAscension;

      // Convert the HA and declination to a rectangular coordinate system where the X axis points to 
      // the celestial equator in the south, the Y axis to the horizon in the west, and the Z axis to 
      // the north celestial pole
      x = Trigo.cos(ha) * Trigo.cos(declination) / 1e18;
      y = Trigo.sin(ha) * Trigo.cos(declination) / 1e18;
      z = Trigo.sin(declination);
    }

    // Now we'll rotate this x,y,z system along an axis going east-west, i.e. the Y axis, in such a way 
    // that the Z axis will point to the zenith. At the North Pole the angle of rotation will be zero 
    // since there the north celestial pole already is in the zenith. At other latitudes the angle of 
    // rotation becomes 90_deg - latitude. 
    int xhor = x * Trigo.sin(observerLatitude) / 1e18 - z * Trigo.cos(observerLatitude) / 1e18;
    int yhor = y;
    int zhor = x * Trigo.cos(observerLatitude) / 1e18 + z * Trigo.sin(observerLatitude) / 1e18;

    // Compute azimuth and altitude
    azimuth = Trigo.wrapAngleZeroToTwoPi(Trigo.atan2(yhor, xhor) + int(Trigo.PI));
    altitude = Trigo.wrapAngleMinusPiToPi(Trigo.atan2(zhor, int(Math.sqrt(uint(xhor * xhor / 1e18 + yhor * yhor / 1e18)))));
  }




  /**
   * @notice For a given observer positioned on earth, returns the right ascension and declination 
   *         of a specific celestial body. This is different from the geocentric RA/Decl only for 
   *         the moon.
   * @param observerLongitude The longitude of the observer on earth. In degrees, scaled by 1e18.
   * @param observerLatitude The latitude of the observer on earth. In degrees, scaled by 1e18.
   * @param body The celestial body to look for
   * @param dayNumber The time of the observation, in the custom "day number" format (see above; scaled by 1e18)
   * @return rightAscension The right ascension where the body is, in degrees, in the range 0:360, 
   *                        scaled by 1e18
   * @return declination The declination where the body is, in degrees, in the range -90:90, scaled by 1e18.
   * @return distance The distance to the body, in astronomical units (AU), or earth radii for the moon,
   *                 scaled by 1e18.
   */
  function getBodyTopocentricRADecl(int observerLongitude, int observerLatitude, IPP.CelestialBody body, int dayNumber) internal pure returns (int rightAscension, int declination, uint distance) {

    // Convert args to radians
    observerLongitude = observerLongitude * (int(Trigo.PI) / 180) / 1e18;
    observerLatitude = observerLatitude * (int(Trigo.PI) / 180) / 1e18;

    (rightAscension, declination, distance) = getBodyTopocentricRADeclInRadians(observerLongitude, observerLatitude, body, dayNumber);

    // Convert result to degrees
    rightAscension = rightAscension * 1e18 / int(Trigo.PI / 180);
    declination = declination * 1e18 / int(Trigo.PI / 180);
  }

  /**
   * @notice For a given observer positioned on earth, returns the right ascension and declination 
   *         of a specific celestial body. This is different from the geocentric RA/Decl only for 
   *         the moon. Version with everything in radians.
   * @param observerLongitude The longitude of the observer on earth. In radians, scaled by 1e18.
   * @param observerLatitude The latitude of the observer on earth. In radians, scaled by 1e18.
   * @param body The celestial body to look for
   * @param dayNumber The time of the observation, in the custom "day number" format (see above; scaled by 1e18)
   * @return rightAscension The right ascension where the body is, in radians, in the range 0:2pi, 
   *                        scaled by 1e18
   * @return declination The declination where the body is, in radians, in the range -pi/2:pi/2, scaled by 1e18.
   * @return distance The distance to the body, in astronomical units (AU), or earth radii for the moon,
   *                 scaled by 1e18.
   */
  function getBodyTopocentricRADeclInRadians(int observerLongitude, int observerLatitude, IPP.CelestialBody body, int dayNumber) internal pure returns (int rightAscension, int declination, uint distance) {

    IPP.OrbitalElements memory orbitalElements = getOrbitalElements(body, dayNumber);
    
    // Origin will be the earth
    IPP.OrbitalElements memory newOriginOrbitalElements;
    if(orbitalElements.origin == IPP.CelestialBody.EARTH) {
      // No need to specify a new origin
    } else if(orbitalElements.origin == IPP.CelestialBody.SUN) {
      newOriginOrbitalElements = getOrbitalElements(IPP.CelestialBody.EARTH, dayNumber);
    } else {
      revert("Origin must be sun or earth");
    }

    // Earth axias tilt
    IPP.AxialTilt memory earthAxialTilt = IPP.AxialTilt({
      at: EarthAxialTiltValue,
      dat: EarthAxialTiltDeltaValue
    });

    (rightAscension, declination, distance) = getBodyBodyTopocentricRADeclInRadians(orbitalElements, earthAxialTilt, newOriginOrbitalElements, observerLongitude, observerLatitude);
  }

  /**
   * @notice For a given observer positioned on a celestial body, returns the right ascension and declination 
   *         of another specific celestial body. This is different from the bodycentric RA/Decl only for 
   *         the moon viewed from earth.
   * @param orbitalElements The orbital elements of the body we look at.
   * @param originAxialTilt The axial tilt of the body where we are looking from
   * @param newOriginOrbitalElements By default, the body we are looking from is the body at the center
   *                                 of the orbit. You can override this (e.g. look at mars from venus)
   *                                 Note: This is likely buggy for planets != earth due to different
   *                                 axial tilt orientation, not tested
   * @param observerLongitude The longitude of the observer on earth. In radians, scaled by 1e18.
   * @param observerLatitude The latitude of the observer on earth. In radians, scaled by 1e18.
   * @return rightAscension The right ascension where the body is, in radians, in the range 0:2pi, 
   *                        scaled by 1e18
   * @return declination The declination where the body is, in radians, in the range -pi/2:pi/2, scaled by 1e18.
   * @return distance The distance to the body, in astronomical units (AU), or earth radii for the moon,
   *                 scaled by 1e18.
   */
  function getBodyBodyTopocentricRADeclInRadians(IPP.OrbitalElements memory orbitalElements, IPP.AxialTilt memory originAxialTilt, IPP.OrbitalElements memory newOriginOrbitalElements, int observerLongitude, int observerLatitude)  internal pure returns (int rightAscension, int declination, uint distance) {
    // For most bodies, topocentric and geocentric difference is extremely small
    // We only recompute for the moon
    if(orbitalElements.body != IPP.CelestialBody.MOON) {
      return getBodyBodycentricRADeclInRadians(orbitalElements, originAxialTilt, newOriginOrbitalElements);
    }

    // Get the geocentric right ascension/declination
    (int geoRightAscension, int geoDeclination, uint geoDistance) = getBodyBodycentricRADeclInRadians(orbitalElements, originAxialTilt, newOriginOrbitalElements);
    // Get the local sideral time at the observer location
    int sidTime = getLocalSiderealTimeInRadians(observerLongitude, orbitalElements.dayNumber);

    // Computing the Moon's parallax, i.e. the apparent size of the (equatorial) radius of the Earth, 
    // as seen from the Moon
    uint geoDistanceInv = 1e18 * 1e18 / geoDistance;
    int mpar = Trigo.atan2(int(geoDistanceInv), int(Math.sqrt(1e18 - geoDistanceInv * geoDistanceInv / 1e18)));

    // Our astronomical latitude (observerLatitude) must first be converted to a 
    // geocentric latitude (gclat) and  distance from the center of the Earth (rho) in Earth equatorial radii.
    int gclat = observerLatitude - (0.1924 * 1e18 * (int(Trigo.PI) / 180) / 1e18) * Trigo.sin(2 * observerLatitude) / 1e18;
    int rho = (0.99833 * 1e18) + (0.00167 * 1e18) * Trigo.cos(2 * observerLatitude) / 1e18;

    // We compute the Moon's geocentric Hour Angle (HA)
    int ha = Trigo.wrapAngleZeroToTwoPi(sidTime - geoRightAscension);

    // Compute an auxiliary angle
    int g = Trigo.atan2(Trigo.tan(gclat), Trigo.cos(ha));

    // Final computation
    rightAscension = geoRightAscension - mpar * rho / 1e18 * Trigo.cos(gclat) / 1e18 * Trigo.sin(ha) / 1e18 * 1e18 / Trigo.cos(geoDeclination);
    declination = geoDeclination - mpar * rho / 1e18 * Trigo.sin(gclat) / 1e18 * Trigo.sin(g - geoDeclination) / 1e18 * 1e18 / Trigo.sin(g);
    distance = geoDistance; // Not updated
  }




  /**
   * @notice Returns the right ascension and declination of a specific celestial body. 
   * @param body The celestial body to look for
   * @param dayNumber The time of the observation, in the custom "day number" format (see above; scaled by 1e18)
   * @return rightAscension The right ascension where the body is, in degrees, in the range 0:360, 
   *                        scaled by 1e18
   * @return declination The declination where the body is, in degrees, in the range -90:90, scaled by 1e18.
   * @return distance The distance to the body, in astronomical units (AU), or earth radii for the moon,
   *                 scaled by 1e18.
   */
  function getBodyGeocentricRADecl(IPP.CelestialBody body, int dayNumber) internal pure returns (int rightAscension, int declination, uint distance) {

    (rightAscension, declination, distance) = getBodyGeocentricRADeclInRadians(body, dayNumber);

    // Convert result to degrees
    rightAscension = rightAscension * 1e18 / int(Trigo.PI / 180);
    declination = declination * 1e18 / int(Trigo.PI / 180);
  }

  /**
   * @notice Returns the right ascension and declination of a specific celestial body. 
   *         Version with everything in radians.
   * @param body The celestial body to look for
   * @param dayNumber The time of the observation, in the custom "day number" format (see above; scaled by 1e18)
   * @return rightAscension The right ascension where the body is, in radians, in the range 0:2pi, 
   *                        scaled by 1e18
   * @return declination The declination where the body is, in radians, in the range -pi/2:pi/2, scaled by 1e18.
   * @return distance The distance to the body, in astronomical units (AU), or earth radii for the moon,
   *                 scaled by 1e18.
   */
  function getBodyGeocentricRADeclInRadians(IPP.CelestialBody body, int dayNumber) internal pure returns (int rightAscension, int declination, uint distance) {

    IPP.OrbitalElements memory orbitalElements = getOrbitalElements(body, dayNumber);

    // Origin will be the earth
    IPP.OrbitalElements memory newOriginOrbitalElements;
    if(orbitalElements.origin == IPP.CelestialBody.EARTH) {
      // No need to specify a new origin
    } else if(orbitalElements.origin == IPP.CelestialBody.SUN) {
      newOriginOrbitalElements = getOrbitalElements(IPP.CelestialBody.EARTH, dayNumber);
    } else {
      revert("Origin must be sun or earth");
    }

    // Earth axias tilt
    IPP.AxialTilt memory earthAxialTilt = IPP.AxialTilt({
      at: EarthAxialTiltValue,
      dat: EarthAxialTiltDeltaValue
    });

    (rightAscension, declination, distance) = getBodyBodycentricRADeclInRadians(orbitalElements, earthAxialTilt, newOriginOrbitalElements);
  }

  /**
   * @notice From a specific celestial body, returns the right ascension and declination of another
   * specific celestial body. 
   * @param orbitalElements The orbital elements of the body we look at.
   * @param originAxialTilt The axial tilt of the body where we are looking from
   * @param newOriginOrbitalElements By default, the body we are looking from is the body at the center
   *                                 of the orbit. You can override this (e.g. look at mars from venus)
   *                                 Note: This is likely buggy for planets != earth due to different
   *                                 axial tilt orientation, not tested
   * @return rightAscension The right ascension where the body is, in radians, in the range 0:2pi, 
   *                        scaled by 1e18
   * @return declination The declination where the body is, in radians, in the range -pi/2:pi/2, scaled by 1e18.
   * @return distance The distance to the body, in astronomical units (AU), or earth radii for the moon,
   *                 scaled by 1e18.
   */
  function getBodyBodycentricRADeclInRadians(IPP.OrbitalElements memory orbitalElements, IPP.AxialTilt memory originAxialTilt, IPP.OrbitalElements memory newOriginOrbitalElements) internal pure returns (int rightAscension, int declination, uint distance) {

    (int longitude, int latitude, uint d) = getBodyEclipticLonLatInRadians(orbitalElements);
    distance = d;

    // Next, we compute the body rectangular ecliptic coordinates and rotate them to get rectangular 
    // equatorial coordinates and then RA and Decl
    int xg = int(distance) * Trigo.cos(longitude) / 1e18 * Trigo.cos(latitude) / 1e18;
    int yg = int(distance) * Trigo.sin(longitude) / 1e18 * Trigo.cos(latitude) / 1e18;
    int zg = int(distance) * Trigo.sin(latitude) / 1e18;

    // If we want RADecl not from the elliptic center, but from another body
    // Not a clean way to check for a non-null originOrbitalElements
    if(newOriginOrbitalElements.N != 0 || newOriginOrbitalElements.i != 0 || newOriginOrbitalElements.w != 0 || newOriginOrbitalElements.a != 0 || newOriginOrbitalElements.e != 0 || newOriginOrbitalElements.M != 0) {
      // Must share the same origin
      require(orbitalElements.origin == newOriginOrbitalElements.origin, "Must share origin");

      (int newOriginLongitude, int newOriginLatitude, uint newOriginDistance) = getBodyEclipticLonLatInRadians(newOriginOrbitalElements);

      xg = xg - int(newOriginDistance) * Trigo.cos(newOriginLongitude) / 1e18 * Trigo.cos(newOriginLatitude) / 1e18;
      yg = yg - int(newOriginDistance) * Trigo.sin(newOriginLongitude) / 1e18 * Trigo.cos(newOriginLatitude) / 1e18;
      zg = zg - int(newOriginDistance) * Trigo.sin(newOriginLatitude) / 1e18;
    }

    // We compute the obliquity of the ecliptic of the origin
    int ecl = (originAxialTilt.at + originAxialTilt.dat * orbitalElements.dayNumber / 1e18);

    int xe = xg;
    int ye = yg * Trigo.cos(ecl) / 1e18 - zg * Trigo.sin(ecl) / 1e18;
    int ze = yg * Trigo.sin(ecl) / 1e18 + zg * Trigo.cos(ecl) / 1e18;

    // Finally, compute RA, Decl, distance (not changed for the moon):
    rightAscension = Trigo.wrapAngleZeroToTwoPi(Trigo.atan2(ye, xe));
    declination = Trigo.wrapAngleMinusPiToPi(Trigo.atan2(ze, int(Math.sqrt(uint(xe * xe / 1e18 + ye * ye / 1e18)))));
    distance = Math.sqrt(uint(xe * xe / 1e18 + ye * ye / 1e18 + ze * ze / 1e18));
  }



  /**
   * @notice Returns the ecliptic longitude and latitude of a specific celestial body. 
   * @param body The celestial body to look for
   * @param dayNumber The time of the observation, in the custom "day number" format (see above; scaled by 1e18)
   * @return longitude The ecliptic longitude where the body is, in degrees, in the range 0:360, 
   *                        scaled by 1e18
   * @return latitude The ecliptic latitude where the body is, in degrees, in the range -90:90, scaled by 1e18.
   * @return distance The distance to the body, in astronomical units (AU), or earth radii for the moon,
   *                 scaled by 1e18.
   */
  function getBodyEclipticLonLat(IPP.CelestialBody body, int dayNumber) internal pure returns (int longitude, int latitude, uint distance) {
   
    (longitude, latitude, distance) = getBodyEclipticLonLatInRadians(body, dayNumber);

    // Convert result to degrees
    longitude = longitude * 1e18 / int(Trigo.PI / 180);
    latitude = latitude * 1e18 / int(Trigo.PI / 180);
  }

  /**
   * From a "day number" as defined above, return the ecliptic lon/lat of a planet.
   * longitude and latitude are in radians, scaled by 1e18
   * distance is in astronomical units (AU) (or earth radii if Moon), scaled by 1e18
   */
  
  function getBodyEclipticLonLatInRadians(IPP.CelestialBody body, int dayNumber) internal pure returns (int longitude, int latitude, uint distance) {
    
    IPP.OrbitalElements memory orbitalElements = getOrbitalElements(body, dayNumber);
    (longitude, latitude, distance) = getBodyEclipticLonLatInRadians(orbitalElements);
  } 

  /**
   * @notice Returns the ecliptic longitude and latitude of a specific celestial body. 
   *         Version using orbitalElements and with everything in radians.
   * @param orbitalElements The orbital elements of the celestial body to look for
   * @return longitude The ecliptic longitude where the body is, in degrees, in the range 0:360, 
   *                        scaled by 1e18
   * @return latitude The ecliptic latitude where the body is, in degrees, in the range -90:90, scaled by 1e18.
   * @return distance The distance to the body, in astronomical units (AU), or earth radii for the moon,
   *                 scaled by 1e18.
   */
  function getBodyEclipticLonLatInRadians(IPP.OrbitalElements memory orbitalElements) internal pure returns (int longitude, int latitude, uint distance) {
    
    { // Stack too deeep

      // We compute the excentric anomaly
      int em = orbitalElements.M + orbitalElements.e * Trigo.sin(orbitalElements.M) / 1e18 * (1e18 + orbitalElements.e * Trigo.cos(orbitalElements.M) / 1e18) / 1e18;
      // We do 1 iteration to refine the result, should be enough
      em = em - (em - orbitalElements.e * Trigo.sin(em) / 1e18 - orbitalElements.M) * 1e18 / (1e18 - orbitalElements.e * Trigo.cos(em) / 1e18);
      
      // Compute the rectangular (x,y) coordinates in the plane of the body orbit
      int xv = orbitalElements.a * (Trigo.cos(em) - orbitalElements.e) / 1e18;
      int yv = orbitalElements.a * int(Math.sqrt(uint(1e18 - orbitalElements.e * orbitalElements.e / 1e18))) / 1e18 * Trigo.sin(em) / 1e18;
      
      // Convert this to distance and true anomaly
      int vm = Trigo.wrapAngleZeroToTwoPi(Trigo.atan2(yv, xv));
      distance = Math.sqrt(uint(xv * xv / 1e18 + yv * yv / 1e18));
      
      // Now we know the body's position in the plane of the body orbit. 
      // Compute the body position in ecliptic coordinates
      int xh = int(distance) * (Trigo.cos(orbitalElements.N) * Trigo.cos(vm + orbitalElements.w) / 1e18 - Trigo.sin(orbitalElements.N) * Trigo.sin(vm + orbitalElements.w) / 1e18 * Trigo.cos(orbitalElements.i) / 1e18) / 1e18;
      int yh = int(distance) * (Trigo.sin(orbitalElements.N) * Trigo.cos(vm + orbitalElements.w) / 1e18 + Trigo.cos(orbitalElements.N) * Trigo.sin(vm + orbitalElements.w) / 1e18 * Trigo.cos(orbitalElements.i) / 1e18) / 1e18;
      int zh = int(distance) * (Trigo.sin(vm + orbitalElements.w) * Trigo.sin(orbitalElements.i) / 1e18) / 1e18;

      // Convert to ecliptic longitude, latitude and distance
      longitude = Trigo.wrapAngleZeroToTwoPi(Trigo.atan2(yh, xh));
      latitude = Trigo.wrapAngleMinusPiToPi(Trigo.atan2(zh, int(Math.sqrt(uint(xh * xh / 1e18 + yh * yh / 1e18)))));
      distance = Math.sqrt(uint(xh * xh / 1e18 + yh * yh / 1e18 + zh * zh / 1e18));
    }


    //
    // Below we'll compute the most important perturbation terms, and then add these as corrections
    // to our previous figures.
    //

    if(orbitalElements.body == IPP.CelestialBody.MOON) {
      IPP.OrbitalElements memory sunElements = getOrbitalElements(IPP.CelestialBody.SUN, orbitalElements.dayNumber);

      // Sun mean longitutde
      int ls = sunElements.M + sunElements.w + sunElements.N;
      // Moon mean longitude
      int lm = orbitalElements.M + orbitalElements.w + orbitalElements.N;
      // Moon mean elongation
      int dm = lm - ls;
      // Moon argument of latitude
      int f = lm - orbitalElements.N;

      // Compute and add up the 12 largest pertirbation terms in longitude
      // Evection
      int dlon = - (1.274 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(orbitalElements.M - 2 * dm) / 1e18;
      // Variation
      dlon = dlon + (0.658 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(2 * dm) / 1e18;
      // yearly equation
      dlon = dlon - (0.186 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(sunElements.M) / 1e18;
      dlon = dlon - (0.059 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(2 * orbitalElements.M - 2 * dm) / 1e18;
      dlon = dlon - (0.057 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(orbitalElements.M - 2 * dm + sunElements.M) / 1e18;
      dlon = dlon + (0.053 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(orbitalElements.M + 2 * dm) / 1e18;
      dlon = dlon + (0.046 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(2 * dm - sunElements.M) / 1e18;
      dlon = dlon + (0.041 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(orbitalElements.M - sunElements.M) / 1e18;
      // the Parallactic Equation
      dlon = dlon - (0.035 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(dm) / 1e18;
      dlon = dlon - (0.031 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(orbitalElements.M + sunElements.M) / 1e18;
      dlon = dlon - (0.015 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(2 * f - 2 * dm) / 1e18;
      dlon = dlon + (0.011 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(orbitalElements.M - 4 * dm) / 1e18;
      longitude = longitude + dlon;

      // Compute and add up the 5 largest pertirbation terms in latitude
      int dlat = (-0.173 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(f - 2 * dm) / 1e18;
      dlat = dlat - (0.055 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(orbitalElements.M - f - 2 * dm) / 1e18;
      dlat = dlat - (0.046 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(orbitalElements.M + f - 2 * dm) / 1e18;
      dlat = dlat + (0.033 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(f + 2 * dm) / 1e18;
      dlat = dlat + (0.017 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(2 * orbitalElements.M + f) / 1e18;
      latitude = latitude + dlat;

      // Compute and add up the 2 largest pertirbation terms in distance
      int ddistance = (-0.58 * 1e18) * Trigo.cos(orbitalElements.M - 2 * dm) / 1e18;
      ddistance = ddistance - (0.46 * 1e18) * Trigo.cos(2 * dm) / 1e18;
      distance = uint(int(distance) + ddistance);
    }
    else if(orbitalElements.body == IPP.CelestialBody.JUPITER) {
      IPP.OrbitalElements memory saturnElements = getOrbitalElements(IPP.CelestialBody.SATURN, orbitalElements.dayNumber);

      int dlon = - (0.332 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(2 * orbitalElements.M - 5 * saturnElements.M - 67.6 * 1e18 * int(Trigo.PI) / 1e18 / 180) / 1e18;
      dlon = dlon - (0.056 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(2 * orbitalElements.M - 2 * saturnElements.M + 21 * 1e18 * int(Trigo.PI) / 1e18 / 180) / 1e18;
      dlon = dlon + (0.042 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(3 * orbitalElements.M - 5 * saturnElements.M + 21 * 1e18 * int(Trigo.PI) / 1e18 / 180) / 1e18;
      dlon = dlon - (0.036 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(1 * orbitalElements.M - 2 * saturnElements.M) / 1e18;
      dlon = dlon + (0.022 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.cos(1 * orbitalElements.M - 1 * saturnElements.M) / 1e18;
      dlon = dlon + (0.023 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(2 * orbitalElements.M - 3 * saturnElements.M + 52 * 1e18 * int(Trigo.PI) / 1e18 / 180) / 1e18;
      dlon = dlon - (0.016 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(1 * orbitalElements.M - 5 * saturnElements.M - 69 * 1e18 * int(Trigo.PI) / 1e18 / 180) / 1e18;
      longitude = longitude + dlon;
    }
    else if(orbitalElements.body == IPP.CelestialBody.SATURN) {
      IPP.OrbitalElements memory jupiterElements = getOrbitalElements(IPP.CelestialBody.JUPITER, orbitalElements.dayNumber);

      int dlon = (0.812 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(2 * jupiterElements.M - 5 * orbitalElements.M - 67.6 * 1e18 * int(Trigo.PI) / 1e18 / 180) / 1e18;
      dlon = dlon - (0.229 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.cos(2 * jupiterElements.M - 4 * orbitalElements.M - 2 * 1e18 * int(Trigo.PI) / 1e18 / 180) / 1e18;
      dlon = dlon + (0.119 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(1 * jupiterElements.M - 2 * orbitalElements.M - 3 * 1e18 * int(Trigo.PI) / 1e18 / 180) / 1e18;
      dlon = dlon + (0.046 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(2 * jupiterElements.M - 6 * orbitalElements.M - 69 * 1e18 * int(Trigo.PI) / 1e18 / 180) / 1e18;
      dlon = dlon + (0.014 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(1 * jupiterElements.M - 3 * orbitalElements.M + 32 * 1e18 * int(Trigo.PI) / 1e18 / 180) / 1e18;
      longitude = longitude + dlon;

      int dlat = - (0.020 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.cos(2 * jupiterElements.M - 4 * orbitalElements.M - 2 * 1e18 * int(Trigo.PI) / 1e18 / 180) / 1e18;
      dlat = dlat + (0.018 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(2 * jupiterElements.M - 6 * orbitalElements.M - 49 * 1e18 * int(Trigo.PI) / 1e18 / 180) / 1e18;
      latitude = latitude + dlat;
    }
    else if(orbitalElements.body == IPP.CelestialBody.URANUS) {
      IPP.OrbitalElements memory jupiterElements = getOrbitalElements(IPP.CelestialBody.JUPITER, orbitalElements.dayNumber);
      IPP.OrbitalElements memory saturnElements = getOrbitalElements(IPP.CelestialBody.SATURN, orbitalElements.dayNumber);

      int dlon = (0.040 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(1 * saturnElements.M - 2 * orbitalElements.M + 6 * 1e18 * int(Trigo.PI) / 1e18 / 180) / 1e18;
      dlon = dlon + (0.035 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(1 * saturnElements.M - 3 * orbitalElements.M + 33 * 1e18 * int(Trigo.PI) / 1e18 / 180) / 1e18;
      dlon = dlon - (0.015 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(1 * jupiterElements.M - 1 * orbitalElements.M + 20 * 1e18 * int(Trigo.PI) / 1e18 / 180) / 1e18;
      longitude = longitude + dlon;
    }
  }



  /**
   * @notice For a given longitude on earth at a given time, return the local sidereal time.
   * @param longitude The longitude for which to get the local sideral time, in degrees scaled by 1e18.
   * @param dayNumber The time of the observation, in the custom "day number" format (see above; scaled by 1e18)
   * @return siderealTime The local sidereal time, in hours (range 0:24) scaled by 1e18.
   */
  function getLocalSiderealTime(int longitude, int dayNumber) internal pure returns (int siderealTime) {
    
    // Convert args to radians
    longitude = longitude * (int(Trigo.PI) / 180) / 1e18;

    siderealTime = getLocalSiderealTimeInRadians(longitude, dayNumber);

    // Convert result to hours
    siderealTime = siderealTime * 1e18 / (int(Trigo.PI) / 180) / 15;
  }

  /**
   * @notice For a given longitude on earth at a given time, return the local sidereal time.
   *         Version with everything in radians.
   * @param longitude The longitude for which to get the local sideral time, in radians scaled by 1e18.
   * @param dayNumber The time of the observation, in the custom "day number" format (see above; scaled by 1e18)
   * @return siderealTime The local sidereal time, in radians (range 0:2pi) scaled by 1e18.
   */
  function getLocalSiderealTimeInRadians(int longitude, int dayNumber) internal pure returns (int siderealTime) {
    // Compute the sun median longitude
    IPP.OrbitalElements memory sunElements = getOrbitalElements(IPP.CelestialBody.SUN, dayNumber);
    int L = Trigo.wrapAngleZeroToTwoPi(sunElements.w + sunElements.M);

    // Compute GMST0 : The Sidereal Time at the Greenwich meridian at 00:00 right now
    int gmst0 = (L + int(Trigo.PI));

    // Compute local Sidereal Time at the longitude of the observer : GMST0 + UT + LON
    siderealTime = gmst0 + (dayNumber % 1e18) * int(Trigo.TWO_PI) / 1e18 + longitude;
  }



  /**
   * @notice Get orbital elements for a given celestial body at a given time.
   *         WARN: For the moon and sun, the origin is the earth, otherwise the origin is the sun.
   * @param body The celestial body to do the computation for
   * @param dayNumber The time of the observation, in the custom "day number" format (see above; scaled by 1e18)
   * @return elements The orbital elements, in radians when applicable (N, i, w, M), scaled by 1e18.
   */
  function getOrbitalElements(IPP.CelestialBody body, int dayNumber) internal pure returns (IPP.OrbitalElements memory elements) {

    IPP.OrbitalElementsParameters memory elementsParameters = getOrbitalElementsParameters(body);

    elements = getOrbitalElements(elementsParameters, dayNumber);
  }

  /**
   * @notice For a given set of orbital elements parameters, and a time of observation, return orbital
   *         elements.
   * @param elementsParameters The orbital elements parameters of the celestial body.
   * @param dayNumber The time of the observation, in the custom "day number" format (see above; scaled by 1e18)
   * @return elements The orbital elements, in radians when applicable (N, i, w, M), scaled by 1e18.
   */
  function getOrbitalElements(IPP.OrbitalElementsParameters memory elementsParameters, int dayNumber) internal pure returns (IPP.OrbitalElements memory elements) {

    elements.body = elementsParameters.body;
    elements.origin = elementsParameters.origin;

    elements.N = Trigo.wrapAngleZeroToTwoPi(elementsParameters.N + elementsParameters.dN * dayNumber / 1e18);
    elements.i = Trigo.wrapAngleZeroToTwoPi(elementsParameters.i + elementsParameters.di * dayNumber / 1e18);
    elements.w = Trigo.wrapAngleZeroToTwoPi(elementsParameters.w + elementsParameters.dw * dayNumber / 1e18);
    elements.a = elementsParameters.a + elementsParameters.da * dayNumber / 1e18;
    elements.e = elementsParameters.e + elementsParameters.de * dayNumber / 1e18;
    elements.M = Trigo.wrapAngleZeroToTwoPi(elementsParameters.M + elementsParameters.dM * dayNumber / 1e18);

    elements.dayNumber = dayNumber;
  }

  /**
   * @notice For a given body, returns the orbital element parameters necessary to compute the orbital
   *         elements at a given time.
   */
  function getOrbitalElementsParameters(IPP.CelestialBody body) internal pure returns (IPP.OrbitalElementsParameters memory elementsParameters) {
    
    elementsParameters.body = body;
    if(body == IPP.CelestialBody.SUN || body == IPP.CelestialBody.MOON) {
        elementsParameters.origin = IPP.CelestialBody.EARTH;
    }
    else {
        elementsParameters.origin = IPP.CelestialBody.SUN;
    }

    // Fetching constants from the table, see doc of orbitalElementsConstantsTable
    bytes memory table = orbitalElementsConstantsTable;
    uint bodyTableOffset = uint(body) * 0x60;
    int Ni; 
    int wa;
    int eM;
    assembly {
      Ni := mload(add(add(add(table, 0x20), bodyTableOffset), 0x00)) // Contains N1, N2, i1, i2
      wa := mload(add(add(add(table, 0x20), bodyTableOffset), 0x20)) // Contains w1, w2, a1, a2
      eM := mload(add(add(add(table, 0x20), bodyTableOffset), 0x40)) // Contains e1, e1, M1, M2
    }

    elementsParameters.N = (Ni >> 24 * 8);
    elementsParameters.dN = (Ni << 8 * 8 >> 24 * 8);
    elementsParameters.i = (Ni << 16 * 8 >> 24 * 8);
    elementsParameters.di = (Ni << 24 * 8 >> 24 * 8);
    elementsParameters.w = (wa >> 24 * 8);
    elementsParameters.dw = (wa << 8 * 8 >> 24 * 8);
    elementsParameters.a = (wa << 16 * 8 >> 24 * 8 /** scaled by 1e16 */) * 1e2;
    elementsParameters.da = (wa << 24 * 8 >> 24 * 8);
    elementsParameters.e = (eM >> 24 * 8);
    elementsParameters.de = (eM << 8 * 8 >> 24 * 8);
    elementsParameters.M = (eM << 16 * 8 >> 24 * 8);
    elementsParameters.dM = (eM << 24 * 8 >> 24 * 8);
  }
}