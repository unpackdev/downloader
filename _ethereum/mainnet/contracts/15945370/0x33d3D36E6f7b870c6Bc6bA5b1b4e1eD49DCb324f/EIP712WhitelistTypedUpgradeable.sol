// SPDX-License-Identifier: MIT

/**                                                                 
 *******************************************************************************
 * EIP 712 whitelist with qty parameter
 *******************************************************************************
 * Author: Jason Hoi
 *
 */

pragma solidity ^0.8.7;

import "./Initializable.sol";
import "./ECDSAUpgradeable.sol";
import "./AdminableUpgradeable.sol";

contract EIP712WhitelistTypedUpgradeable is Initializable, AdminableUpgradeable {
    event SetSigner(address indexed sender, address indexed signer);
    
    using ECDSAUpgradeable for bytes32;

    // Verify signature with this signer address
    address public eip712Signer;

    // Domain separator is EIP-712 defined struct to make sure 
    // signature is coming from the this contract in same ETH newtork.
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md#definition-of-domainseparator
    // @MATCHING cliend-side code
    bytes32 public DOMAIN_SEPARATOR;

    // HASH_STRUCT should not contain unnecessary whitespace between each parameters
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md#definition-of-encodetype
    // @MATCHING cliend-side code
    bytes32 public constant HASH_STRUCT = keccak256("Minter(address wallet,bytes32 type)");

    function __EIP712WhitelistTyped_init() internal onlyInitializing {
        __EIP712WhitelistTyped_init_unchained();
    }

    function __EIP712WhitelistTyped_init_unchained() internal onlyInitializing {
        // @MATCHING cliend-side code
        DOMAIN_SEPARATOR = keccak256(
            abi.encode(
                keccak256(
                    "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"
                ),
                // @MATCHING cliend-side code
                keccak256(bytes("WhitelistToken")),
                keccak256(bytes("1")),
                block.chainid,
                address(this)
            )
        );

        // initial signer is contract creator
        setSigner(_msgSenderEIP712());
    }

    function setSigner(address _addr) public onlyAdmin {
        eip712Signer = _addr;

        emit SetSigner(_msgSenderEIP712(), _addr);
    }

    modifier checkWhitelist(bytes calldata _signature, string memory _type) {
        require(eip712Signer == _recoverSigner(_signature, _type), "EIP712: Invalid Signature");
        _;
    }

    function verifySignature(bytes calldata _signature, string memory _type) public view returns (bool) {
        return eip712Signer == _recoverSigner(_signature, _type);
    }

    // Recover the signer address
    function _recoverSigner(bytes calldata _signature, string memory _type) internal view returns (address) {
        require(eip712Signer != address(0), "EIP712: Whitelist not enabled");

        // Verify EIP-712 signature by recreating the data structure
        // that we signed on the client side, and then using that to recover
        // the address that signed the signature for this data.
        bytes32 digest = keccak256(
            abi.encodePacked(
                "\x19\x01",
                DOMAIN_SEPARATOR,
                keccak256(abi.encode(HASH_STRUCT, _msgSenderEIP712(), bytes32(bytes(_type))))
            )
        );
        return digest.recover(_signature);
    }

    /**
     * @dev Returns the message sender (defaults to `msg.sender`).
     *
     * For GSN compatible contracts, you need to override this function.
     */
    function _msgSenderEIP712() internal view virtual returns (address) {
        return msg.sender;
    }

    /**
     * @dev This empty reserved space is put in place to allow future versions to add new
     * variables without shifting down storage in the inheritance chain.
     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
     */
    uint256[48] private __gap;
}