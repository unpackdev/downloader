// SPDX-License-Identifier: GPL-3.0-only
pragma solidity ^0.8.13;

import "./Initializable.sol";
import "./AccessControlEnumerable.sol";
import "./ECDSA.sol";
import "./Strings.sol";
import "./EnumerableSet.sol";
import "./SignatureChecker.sol";
import "./IPaymentSplitterFactory.sol";
import "./IAlbaDelegate.sol";
import "./IAlbaHTMLBuilder.sol";

/**
 * @title AlbaDelegate
 * @dev This contract is used to share common functionality across all Alba collections.
 * For example, it allows for the management of mint signers and can construct the baseURI.
 * Deployed collection contracts 'delegate' some of their functionality to this contract.
 */
contract AlbaDelegate is IAlbaDelegate, Initializable, AccessControlEnumerable {
    using EnumerableSet for EnumerableSet.AddressSet;
    using SignatureChecker for EnumerableSet.AddressSet;

    event ProtocolChanged(string eventName, bytes data);

    EnumerableSet.AddressSet private mintSigners;
    bytes32 public constant MANAGER_ROLE = keccak256("MANAGER_ROLE");
    string public commonBaseTokenURI;
    IAlbaHTMLBuilder internal builder;
    IPaymentSplitterFactory internal splitterFactory;
    address internal operatorRegistrant;
    address internal albaFeeReceiver;
    uint256 internal minSaleStartBuffer;

    function initialize(
        string memory baseTokenURI,
        IAlbaHTMLBuilder _builder,
        IPaymentSplitterFactory _splitterFactory,
        address _operatorRegistrant,
        address _feeReceiver,
        address _manager
    ) external initializer {
        _setupRole(DEFAULT_ADMIN_ROLE, _manager);
        _setupRole(MANAGER_ROLE, _manager);

        commonBaseTokenURI = baseTokenURI;
        builder = _builder;
        splitterFactory = _splitterFactory;
        operatorRegistrant = _operatorRegistrant;
        albaFeeReceiver = _feeReceiver;
    }

    // Setup functions

    function getAlbaFeeReceiver() public view returns (address) {
        return albaFeeReceiver;
    }

    function paymentSplitterFactory() public view returns (IPaymentSplitterFactory) {
        return splitterFactory;
    }

    function operatorFilterSubscription() public view returns (address) {
        return operatorRegistrant;
    }

    function getMinSaleStartBuffer() public view returns (uint256) {
        return minSaleStartBuffer;
    }

    // Contract functions

    /**
     * @notice Returns the token URI for a given token ID.
     * @dev The token URI includes the chainID as we can have multiple chains with the same collection
     * (i.e. testnet and mainnet).
     */
    function tokenURI(uint256 tokenId, string memory slug) public view returns (string memory) {
        return string(
            abi.encodePacked(
                commonBaseTokenURI,
                "/collections/",
                slug,
                "/chain/",
                Strings.toString(block.chainid),
                "/token/",
                Strings.toString(tokenId),
                ".json"
            )
        );
    }

    function verifyMint(bytes16 collectionId, address user, uint16 num, uint32 nonce, bytes calldata signature)
        external
        view
    {
        bytes32 message =
            ECDSA.toEthSignedMessageHash(keccak256(abi.encodePacked(collectionId, user, num, nonce, block.chainid)));
        mintSigners.requireValidSignature(message, signature);
    }

    /**
     * @notice Verifies a message signed by a mint signer for reserved mints.
     * @dev We pass message becasue we use that in the collection contract as a key to the
     * reserved mints mapping.
     */
    function verifyMintReserve(bytes32 message, bytes calldata signature) external view {
        mintSigners.requireValidSignature(message, signature);
    }

    /**
     * @notice Returns the HTML needed to render a token.
     * @dev The HTML is generated by the AlbaHTMLBuilder contract.
     */
    function tokenHTML(bytes16 uuid, uint256 tokenId, bytes32 seed, bytes16[] memory deps)
        public
        view
        returns (bytes memory)
    {
        return builder.tokenHTML(uuid, tokenId, seed, deps);
    }

    // Admin functions

    /**
     * @notice Removes and adds addresses to the set of allowed signers.
     * @dev Removal is performed before addition.
     */
    function changeMintSigners(address[] calldata delSigners, address[] calldata addSigners)
        external
        onlyRole(MANAGER_ROLE)
    {
        for (uint256 idx; idx < delSigners.length; ++idx) {
            mintSigners.remove(delSigners[idx]);
        }
        for (uint256 idx; idx < addSigners.length; ++idx) {
            mintSigners.add(addSigners[idx]);
        }
        emit ProtocolChanged("MintSignersChanged", abi.encode(delSigners, addSigners));
    }

    function setAlbaFeeReceiver(address _feeReceiver) external onlyRole(MANAGER_ROLE) {
        albaFeeReceiver = _feeReceiver;
        emit ProtocolChanged("AlbaFeeReceiverChanged", abi.encode(_feeReceiver));
    }

    function setHTMLBuilder(IAlbaHTMLBuilder _builder) external onlyRole(MANAGER_ROLE) {
        builder = _builder;
        emit ProtocolChanged("HTMLBuilderChanged", abi.encode(address(_builder)));
    }

    function setPaymentSplitterFactory(IPaymentSplitterFactory _splitterFactory) external onlyRole(MANAGER_ROLE) {
        splitterFactory = _splitterFactory;
        emit ProtocolChanged("PaymentSplitterFactoryChanged", abi.encode(address(_splitterFactory)));
    }

    function setOperatorFilterSubscription(address _subscription) external onlyRole(MANAGER_ROLE) {
        operatorRegistrant = _subscription;
        emit ProtocolChanged("OperatorFilterSubscriptionChanged", abi.encode(_subscription));
    }

    function setCommonBaseURI(string calldata _baseURI) external onlyRole(MANAGER_ROLE) {
        commonBaseTokenURI = _baseURI;
        emit ProtocolChanged("CommonBaseURIChanged", abi.encode(_baseURI));
    }

    function setMinSaleStartBuffer(uint256 _buffer) external onlyRole(MANAGER_ROLE) {
        minSaleStartBuffer = _buffer;
        emit ProtocolChanged("<inSaleStartBufferChanged", abi.encode(_buffer));
    }
}
