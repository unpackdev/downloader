// SPDX-License-Identifier: MIT

/*
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#PB@@@@@@@@@@@@@@
@@@@@@@@@@QaTr~:":!*xk9#@@@@@@@@@@@@@@@@@@@$#@@@@@@@@@@@@@#gEE$#@@@@@@@@@QDE08@@@@@@@@@@@@@@@@@@@@@$RQ#@@@@@@@@@@@@@@@@@@B$EDg#@@@@@@@@@@@@@@@@@@@@@@@@@@#B@@@@@@@@#=`E@@@@@@@@@@@@@
@@@@@@@QY-              <I#@@@@@@@@@@@@@@E*)-5@@@@@@@@@@O*YmOdPY*O@@@@@T)yZ6ZI??#@@@@@@@@@@QEEQ@@@@e}*=:~xkE#@@@@@@@@@@G*T3Odax*g@@@@@@##s*#@@@@@ZR@@@@@g,0@@@@@@QTcu~`^m#@y*@@@@@@@
@@@@@Q=      `_~^<!-      `c#@@@@@@@@@@#)u@@Q)i@@@@@@@@R,Q@@@@@@#.O@@@?}@@@@@@@P=@@@@@@@@@BP5Ki_rQ@@@@#`zgPx__}Q@@@@@@P=#@@@@@@B.8@@8i]Tx` ;@@@@@?!@@@@3!#@@@@@@Q`8@@@: r`c? @@@@@@@
@@@@h`    .cD@@@@@@@Bd)`    _B@@@@@@@@Q^g@@@@@@@@@@@@@Q-g@@@@@@@@Lr@@l:@@@@@@@@@`#@@@@@@@@@@@@@#r.#@@@U.#@@@@8x'vB@@@E.B@@@@@@@@*T@0-0@@@B_ y@@@@M $@@v<#@@@@@@@Q`c@@@d mg-` Z@@@@@@
@@@6     y#@@@@@@@@@@@@#r    _B@@@@@@#!8@@@@@@@@@@@@@@=T@@@@@@@@@$`#g-Q@@@@@@@@@vy@@B@@@@@@@@@@@@=u@@@o Q@@@@@@B='Q@#,e@@@@@@@@@M-@!u@@@@@0 !@@@@@`v#*vPwwPB@@@@@$,:d@@==@#* X@@@@@@
@@#_    P@@@@@@@@@@@@@@@@k    ^@@@@@#:D@@@@@@#*~rzB@@~k@@@@@@@@@@@^)_Q@@@@@@@@@@0:@b Q@@@@@@@@@@@X!@@@Q }@@@@@@@@~!#:M@@@@@@@@@@@_P G@@@@@@Q#@@@@@Y`_`x3d3x`:$@@@@@9^-x* $@@#@@@@@@@
@@O    -@@@@@@@@@@@@@@@@@@`    @@@@@M.@@@@@@@Q Qg}.E@_KB@@@@@@@@@#:<!0@@@@@@@@@@P<@Z r@@@@@@@@@@@o!@@@@*`#@@@@@@@y`Q_M#@@@@@@@@@B.$-L@@@@@@@@@@@@@Q`^#@@@@@Bx`z@@@Gu##5i ,vv)xM@@@@@
@@G    ~@@@@$xxxx0@@@@@@@@_    #@@@@Z`Q@@@@@@#l@@@w^@#5Yv?B@@@@kx)j@Bwvve@@@@#Y|xB@Z `V@@@@@@@@@@rY@@@@B-*@@@@@@@)*@#3]v\#@@@@uv?P@K`e@@@@@@@@@@@@@T.B@@@@@@@V O@@g-,D@@_"@@@Y g@@@@
@@$    .@@@@a    I@@@@@@@#    '@@@@@@q.rO#@@@@@@@@}Y@@@@#.$@@@#_G@@@@@@I*@@@@Z"@@@@Z G`H@@@@@@@@$`B@@@@@8 v@@@@@G-B@@@@Q`#@@@#'$@@@@M_^0@@@@@@@@#@@#.=@@@@@@@@i_#@@m  o@c Q@@I`#@@@@
@@@!    X$$$T    I@@@@@@@c    Y@@@@@@@#Hr,~iIMOO5xx@@@@6rxR~:xz:#@@@@#k*Ih,_g:j@@@@BI@R`}@@@@@@@=k@@@@@@@k K@BMLxQ@@@@MriO,:yL^@@@@@@@X!,]38#@@P`8@@G a@@@@@@@$ $@@V,H-!T ]BX=0@@@@@
@@@d             I@@@@@@M`   :#@@@@@@@@@@@B6myVkq#@@@@Z,vxLK$:j^!@@@@r:ixuQu^m-s@@@@@@@Q>:O@@@B|U@@@@@Q**r_=xuZ#@@@@@z_xxY5d"s!*@@@@@@@@#byv**rxU@@@@M0@@@@@@@#:B@#xQ@@EV! k0@@@@@@@
@@@@x            I@@@@@d````-#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@8O8@@@@@@@@@@@#E6#@@@@@@@@@0x^?xzB@@@@@@@@@@@@@@@@@@@@@@@@@@@@@$OQ@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@$ $@@@@@@@@
@@@k}!:::::::::::|ccccc}}}}}TcK@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@z#@@@@@@@@
@@#.                          :@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@#.    ``````````````````    :@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@#.   `@@@@@@@@@@@@@@@@@#    :@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@dxB@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@#.   `@@@@@@@BdMQ@@@@@@#    :@@@@@@@@@@@@@@@@@@@@@@@@@@#M@@@@@@@@@@@@@@@@@@@@@@@@@#@@@@@@BDMIirksGdB@@@@@@Q#@@@@Mw@@@@BM0#@@@@@@@@@@@@@@@@B8@@@@de,_3#@8Z@@@@@@@@@@@@@@@@@@@@@@@@@
@@#.   `@@@@@@O    I@@@@@#    !@@@@@@@@@@@@@@@@@@@@GY@@@B:*"#@@@@yrr*_!^*v@@@@@@@@#Xo}<T#Z}I9QB^PBQDb0@@@@@@*x@@@Vu@@@@@B_xkixLoEB@@@@\@@@@@x 3@#"D@@x`~vL_@@@@@@@@@@@@@@@@@@@@@@@@@
@@@:    B@@@@R`     Q@@@@E    *@@@@@@@@@@@@@@@@@@@@B-M@@q:@x*@@@@BQQ8 W#@@@@@@@@@@@@@@@v<@@@@@@]V@@@@@@@@@@@3.@#re@@@@@@@$_#@@#8qz$@@@.@@@@@W P@#~i#@# dV` #@@@@@@@@@@@@@@@@@@@@@@@@
@@@V    |@@@@@Qv  }8@@@@#~    m@@@@@@@@@@@@@@@@@@@@@V`8@6'@@.K@@@@@@@.T@@@@@@PB@@@@@@@@@,B@@@@@0-#@@@@@@@@@@#_I!^xr^}B@@@@yV@@@@@@@@@@!g@@@@M 0@@@V:yQ~\@Ev#@@@@@@@@@@@@@@@@@@@@@@@@
@@@@"    *Q@@@@@QQ@@@@@Q:    r@@@@@@@@@@@@@@@@@@@@@@0`_Lg @@z_@@@@@@@u.@@@@@@~x@@@@@@@@@^D@@@@@@^v@@@@@@@@@@@I`w#@@@G-Y@BlL-VyVVVm@@@@$,uMaTGX:@@@$$O}:`cyo6@@@@@@@@@@@@@@@@@@@@@@@@
@@@@B^     *I8#@@@@#gm;     <@@@@@@@@@@@@@@@@@@@@@@@B_#}-,@@@:O@@@@@@B`d@@@@@~`K@@@@@@@#-#@@@@@@B-g@@@@@@@@@@#'P@@@@@B!z@@@_B@@@@@@@@@@#RO8@@@*W@@q`o@B`D#Q:x@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@z-       .__.       -P@@@@@@@@@@@@@@@@@@@@@@@@#_@@##@@@Z:@@@@@@@vr@@@@@~I_0@@@@@@zr@@@@@@@@6"@@@@@@@@@@@z.#@@@@@Q`B@@~M@@#0HXwVe@@@@@@@@B_@@@r *#)L@@=K@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@O)-            .vb@@@@@@@@@@@@@@@@@@@@@@@@@@@e@@@@@@@@^Y@Br<^^!!<<~=\Q@#=y#@@@8?#@@@@@@@@@Yy@@@@@@@@@@@LI@@@@@@-d@@6:Iy3Q@@@@@@@@@@@@@@uu@B:QM*~`hVg@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@8MVi)**(iyMQ@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#:r@#@@@@@@@@@@@@@@w^iywX@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Q@@@@8#@@@@@@@@@@@@@@@@@#a@@@@@@@-d@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Q@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@G8@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
*/

pragma solidity >=0.8.0 <0.9.0;

import "./AccessControl.sol";
import "./ERC1155.sol";
import "./IERC20.sol";
import "./MerkleProof.sol";
import "./Strings.sol";
import "./Counters.sol";
import "./AbstractMintPassFactory.sol";

contract GoondocksMintKeyFactory is AbstractMintPassFactory {
    using Counters for Counters.Counter;

    Counters.Counter private mpCounter; 

    bytes32 public constant GOON_OPERATOR_ROLE = keccak256("GOON_OPERATOR_ROLE");
  
    mapping(uint256 => MintPass) public mintPasses;
    
    event Claimed(uint index, address indexed account, uint amount);

    struct MintPass {
        bytes32 merkleRoot;
        bool saleIsOpen;
        uint256 windowOpens;
        uint256 windowCloses;
        uint256 mintPrice;
        uint256 maxSupply;
        uint256 maxPerWallet;
        uint256 maxMintPerTxn;
        string ipfsMetadataHash;
        address redeemableContract;
        mapping(address => uint256) claimedMPs;
    }
   
    constructor(
        string memory _name, 
        string memory _symbol
    ) ERC1155("ipfs://ipfs/") {
        name_ = _name;
        symbol_ = _symbol;
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        grantRole(GOON_OPERATOR_ROLE, msg.sender);
    }

    function addMintPass(
        bytes32 _merkleRoot, 
        uint256 _windowOpens, 
        uint256 _windowCloses, 
        uint256 _mintPrice, 
        uint256 _maxSupply,
        uint256 _maxMintPerTxn,
        string memory _ipfsMetadataHash,
        address _redeemableContract,
        uint256 _maxPerWallet
    ) external onlyOwner {
        require(_windowOpens < _windowCloses, "addMintPass: open window must be before close window");
        require(_windowOpens > 0 && _windowCloses > 0, "addMintPass: window cannot be 0");

        MintPass storage mp = mintPasses[mpCounter.current()];
        mp.saleIsOpen = false;
        mp.merkleRoot = _merkleRoot;
        mp.windowOpens = _windowOpens;
        mp.windowCloses = _windowCloses;
        mp.mintPrice = _mintPrice;
        mp.maxSupply = _maxSupply;
        mp.maxMintPerTxn = _maxMintPerTxn;
        mp.maxPerWallet = _maxPerWallet;
        mp.ipfsMetadataHash = _ipfsMetadataHash;
        mp.redeemableContract = _redeemableContract;
        mpCounter.increment();
    }

    function editMintPass(
        bytes32 _merkleRoot, 
        uint256 _windowOpens, 
        uint256 _windowCloses, 
        uint256 _mintPrice, 
        uint256 _maxSupply,
        uint256 _maxMintPerTxn,
        string memory _ipfsMetadataHash,        
        address _redeemableContract, 
        uint256 _mpIndex,
        bool _saleIsOpen,
        uint256 _maxPerWallet
    ) external onlyOwner {
        require(_windowOpens < _windowCloses, "editMintPass: open window must be before close window");
        require(_windowOpens > 0 && _windowCloses > 0, "editMintPass: window cannot be 0");

        mintPasses[_mpIndex].merkleRoot = _merkleRoot;
        mintPasses[_mpIndex].windowOpens = _windowOpens;
        mintPasses[_mpIndex].windowCloses = _windowCloses;
        mintPasses[_mpIndex].mintPrice = _mintPrice;  
        mintPasses[_mpIndex].maxSupply = _maxSupply;    
        mintPasses[_mpIndex].maxMintPerTxn = _maxMintPerTxn; 
        mintPasses[_mpIndex].ipfsMetadataHash = _ipfsMetadataHash;    
        mintPasses[_mpIndex].redeemableContract = _redeemableContract;
        mintPasses[_mpIndex].saleIsOpen = _saleIsOpen; 
        mintPasses[_mpIndex].maxPerWallet = _maxPerWallet; 
    }       

    function burnFromRedeem(
        address account, 
        uint256 mpIndex, 
        uint256 amount
    ) external {
        require(mintPasses[mpIndex].redeemableContract == msg.sender, "Burnable: Only allowed from redeemable contract");
        _burn(account, mpIndex, amount);
    }  

    function claim(
        uint256 numPasses,
        uint256 amount,
        uint256 mpIndex,
        bytes32[] calldata merkleProof
    ) external payable {
        require(isValidClaim(numPasses, amount, mpIndex, merkleProof));
        
        // return any excess funds to sender if overpaid
        uint256 excessPayment = msg.value - (numPasses * mintPasses[mpIndex].mintPrice);
        if (excessPayment > 0) {
            (bool returnExcessStatus, ) = _msgSender().call{value: excessPayment}("");
            require(returnExcessStatus, "Error returning excess payment");
        }
        
        mintPasses[mpIndex].claimedMPs[msg.sender] = mintPasses[mpIndex].claimedMPs[msg.sender] + numPasses;
        _mint(msg.sender, mpIndex, numPasses, "");
        emit Claimed(mpIndex, msg.sender, numPasses);
    }

    function mint(address to, uint256 numPasses, uint256 mpIndex) public onlyOwner
    {
        _mint(to, mpIndex, numPasses, "");
    }

    function mintBatch(
        address to,
        uint256[] calldata numPasses,
        uint256[] calldata mpIndexes
    ) public onlyOwner {
        _mintBatch(to, mpIndexes, numPasses, "");
    }

    function isValidClaim(
        uint256 numPasses,
        uint256 amount,
        uint256 mpIndex,
        bytes32[] calldata merkleProof
    ) internal view returns (bool) {
        require(mintPasses[mpIndex].saleIsOpen, "Claim: Sale is paused");
        require(!paused(), "Claim: claiming is paused");
        require (block.timestamp > mintPasses[mpIndex].windowOpens && block.timestamp < mintPasses[mpIndex].windowCloses, "Claim: time window closed");
        require(msg.value >= numPasses * mintPasses[mpIndex].mintPrice, "Claim: Ether value incorrect");
        require(mintPasses[mpIndex].claimedMPs[msg.sender] + numPasses <= amount, "Claim: Not allowed to claim given amount");
        require(mintPasses[mpIndex].claimedMPs[msg.sender] + numPasses <= mintPasses[mpIndex].maxPerWallet, "Claim: Not allowed to claim that many from one wallet");
        require(numPasses <= mintPasses[mpIndex].maxMintPerTxn, "Claim: Max quantity per transaction exceeded");
        require(totalSupply(mpIndex) + numPasses <= mintPasses[mpIndex].maxSupply, "Claim: Purchase would exceed max supply");
        
        bool isValid = verifyMerkleProof(merkleProof, mpIndex, amount);
        require(isValid, "MerkleDistributor: Invalid proof.");  
        return isValid;
    }

    function isSaleOpen(uint256 mpIndex) public view returns (bool) {
        return mintPasses[mpIndex].saleIsOpen;
    }

    function turnSaleOn(uint256 mpIndex) external {
        require(isTeamMember(msg.sender), "Caller does not have required role");
        mintPasses[mpIndex].saleIsOpen = true;
    }

    function turnSaleOff(uint256 mpIndex) external {
        require(isTeamMember(msg.sender), "Caller does not have required role");
        mintPasses[mpIndex].saleIsOpen = false;
    }

    function promoteTeamMember(address addr) public {
        grantRole(GOON_OPERATOR_ROLE, addr);
    }

    function demoteTeamMember(address addr) public {
        revokeRole(GOON_OPERATOR_ROLE, addr);
    }

    function isTeamMember(address addr) internal view returns (bool) {
        return hasRole(GOON_OPERATOR_ROLE, addr) || hasRole(DEFAULT_ADMIN_ROLE, addr);
    }

    function makeLeaf(address addr, uint amount) public pure returns (string memory) {
        return string(abi.encodePacked(toAsciiString(addr), "_", Strings.toString(amount)));
    }

    function verifyMerkleProof(bytes32[] calldata merkleProof, uint256 mpIndex, uint amount) public view returns (bool) {
        if(mintPasses[mpIndex].merkleRoot ==
        0x60017d0cc560017d0cc560017d0cc560017d0cc560017d0cc560017d0cc55555){
            return true;
        }
        string memory leaf = makeLeaf(msg.sender, amount);
        bytes32 node = keccak256(abi.encode(leaf));
        return MerkleProof.verify(merkleProof, mintPasses[mpIndex].merkleRoot, node);
    }

    function getClaimedMps(uint256 poolId, address userAddress) public view returns (uint256) {
        return mintPasses[poolId].claimedMPs[userAddress];
    }

    function uri(uint256 id) public view override returns (string memory) {
            require(totalSupply(id) > 0, "URI: nonexistent token");
            
            return string(abi.encodePacked(super.uri(id), mintPasses[id].ipfsMetadataHash));
    } 

    function toAsciiString(address x) internal pure returns (string memory) {
        bytes memory s = new bytes(40);
        for (uint i = 0; i < 20; i++) {
            bytes1 b = bytes1(uint8(uint(uint160(x)) / (2**(8*(19 - i)))));
            bytes1 hi = bytes1(uint8(b) / 16);
            bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));
            s[2*i] = char(hi);
            s[2*i+1] = char(lo);            
        }
        return string(s);
    }

    function char(bytes1 b) internal pure returns (bytes1 c) {
        if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);
        else return bytes1(uint8(b) + 0x57);
    }

    function getAddress() public view returns (address) { 
        return address(this);
    }

    function withdrawEth() external onlyOwner {
        (bool success, ) = payable(msg.sender).call{value: address(this).balance}("");
        require(success, "Transfer failed");
    }

	function reclaimToken(IERC20 token) public onlyOwner {
		token.transfer(msg.sender, token.balanceOf(address(this)));
	}

    receive() external payable {}
}