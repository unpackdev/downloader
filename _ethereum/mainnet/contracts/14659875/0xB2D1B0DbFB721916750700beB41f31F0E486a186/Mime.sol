// SPDX-License-Identifier: MIT

pragma solidity ^0.8.12;

import "./ERC721.sol";
import "./Ownable.sol";
import "./Strings.sol";
import "./Base64.sol";

contract Mime is ERC721, Ownable {
  using Strings for uint256;

  error WrongPrice();
  error OutOfStock();

  uint256 public constant MAX_SUPPLY = 7210;
  uint256 public constant GIVEAWAY_SUPPLY = 100;
  uint256 public constant PRICE = 0.15 ether;
  address public constant OWNER_ADDRESS =
    0x3f9Dd52F5c4A1BBd06e9E08FAfD90669809f0A45;
  uint256 private tokenCounter;
  uint256 private giveawayTokenCounter;

  mapping(uint256 => uint8[173]) private faces;

  constructor() ERC721('Mime', 'MIME') {}

  function mint(uint8[172] calldata _face) external payable {
    uint256 currentPrice = price();
    if (msg.value < currentPrice) {
      revert WrongPrice();
    }

    if (tokenCounter - giveawayTokenCounter > MAX_SUPPLY) {
      revert OutOfStock();
    }
    tokenCounter += 1;
    assignFace(_face, tokenCounter);
    _safeMint(msg.sender, tokenCounter);
  }

  function devMint(uint8[172] calldata _face, address _to) external onlyOwner {
    if (giveawayTokenCounter > GIVEAWAY_SUPPLY) {
      revert OutOfStock();
    }
    tokenCounter += 1;
    giveawayTokenCounter += 1;
    assignFace(_face, tokenCounter);
    _safeMint(_to, tokenCounter);
  }

  function assignFace(uint8[172] calldata _face, uint256 tokenId) private {
    for (uint8 i; i < 172; ) {
      faces[tokenId][i] = _face[i];

      unchecked {
        i++;
      }
    }

    faces[tokenId][172] = uint8(pseudoRandom()) % 3;
  }

  function tokenURI(uint256 tokenId)
    public
    view
    override
    returns (string memory)
  {
    if (!_exists(tokenId)) {
      return "doesn't exist";
    }
    string memory svgPartial1 = string.concat(
      '<svg xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMinYMin meet" viewBox="0 0 275 275" style="background-color:#fcfcfc"><style>path{stroke-linecap:round;stroke-width:3;stroke:#292828;}circle{fill:#292828;}#special{stroke:#f03f3f;}#outline{transform-box:fill-box;transform-origin:center;transform:translateX(8px) translateY(8px);stroke-width:12;stroke:',
      getOutliner(tokenId),
      ';}.animate{transform-box:fill-box;transform-origin: center bottom;animation:squeeze 5s infinite;}@keyframes squeeze{10% {transform:scaleY(1)}13%{transform:scaleY(0.1)}16% {transform: scaleY(1)}}</style>',
      getEyebrows(tokenId),
      getEyes(tokenId)
    );

    string memory svgPartial2 = string.concat(
      getContour(tokenId),
      getNose(tokenId),
      getMouth(tokenId),
      '</svg>'
    );

    string memory svg = string.concat(svgPartial1, svgPartial2);

    string memory json = Base64.encode(
      bytes(
        string.concat(
          '{"name": "Mime #',
          tokenId.toString(),
          '", "description": "Mimes are unique, on-chain NFTs, generated by a face recognition algorithm and living on the Ethereum blockchain.", "image": "data:image/svg+xml;base64,',
          Base64.encode(bytes(svg)),
          '"}'
        )
      )
    );
    string memory output = string.concat('data:application/json;base64,', json);

    return output;
  }

  function withdraw() external onlyOwner {
    payable(OWNER_ADDRESS).transfer(address(this).balance);
  }

  function price() public view returns (uint256) {
    if (tokenCounter < 722) return PRICE / 2;

    return PRICE;
  }

  function getContour(uint256 tokenId) private view returns (string memory) {
    uint8[] memory contourPoints = new uint8[](54);
    for (uint8 i = 0; i < 54; ) {
      contourPoints[i] = faces[tokenId][i + 118];
      unchecked {
        i++;
      }
    }
    string memory contour = getPath(contourPoints);
    return
      string.concat(
        '<path id="outline" d="',
        contour,
        '"/><path d="',
        contour,
        '"/>'
      );
  }

  function getEyebrows(uint256 tokenId) private view returns (string memory) {
    uint8[] memory leftEyebrowPoints = new uint8[](10);
    uint8[] memory rightEyebrowPoints = new uint8[](10);
    for (uint8 i = 0; i < 10; ) {
      leftEyebrowPoints[i] = faces[tokenId][i];
      rightEyebrowPoints[i] = faces[tokenId][i + 47];

      unchecked {
        i++;
      }
    }
    string memory leftEyebrow = getPath(leftEyebrowPoints);
    string memory rightEyebrow = getPath(rightEyebrowPoints);
    return
      string.concat(
        '<path d="',
        leftEyebrow,
        '"/><path d="',
        rightEyebrow,
        '"/>'
      );
  }

  function getEyes(uint256 tokenId) private view returns (string memory) {
    uint8[] memory leftEyePoints = new uint8[](34);
    uint8[] memory rightEyePoints = new uint8[](34);
    for (uint8 i = 0; i < 34; ) {
      leftEyePoints[i] = faces[tokenId][i + 10];
      rightEyePoints[i] = faces[tokenId][i + 57];

      unchecked {
        i++;
      }
    }
    string memory leftEye = getPath(leftEyePoints);
    string memory rightEye = getPath(rightEyePoints);
    return
      string.concat(
        '<g class="animate"><circle cx="',
        uint256(faces[tokenId][44]).toString(),
        '" cy="',
        uint256(faces[tokenId][45]).toString(),
        '" r="',
        uint256(faces[tokenId][46]).toString(),
        '" /><path  d="',
        leftEye,
        '"/></g><g class="animate"><circle cx="',
        uint256(faces[tokenId][91]).toString(),
        '" cy="',
        uint256(faces[tokenId][92]).toString(),
        '" r="',
        uint256(faces[tokenId][93]).toString(),
        '" /><path  d="',
        rightEye,
        '"/></g>'
      );
  }

  function getNose(uint256 tokenId) private view returns (string memory) {
    uint8[] memory nosePoints = new uint8[](6);
    for (uint8 i = 0; i < 6; ) {
      nosePoints[i] = faces[tokenId][i + 94];

      unchecked {
        i++;
      }
    }
    string memory nose = getPath(nosePoints);
    return string.concat('<path d="', nose, '"/>');
  }

  function getMouth(uint256 tokenId) private view returns (string memory) {
    uint8[] memory mouthPoints = new uint8[](18);
    for (uint8 i = 0; i < 18; ) {
      mouthPoints[i] = faces[tokenId][i + 100];

      unchecked {
        i++;
      }
    }
    string memory mouth = getPath(mouthPoints);
    return string.concat("<path id='special' d='", mouth, "'/>");
  }

  function getOutliner(uint256 tokenId) private view returns (string memory) {
    uint8 outliner = faces[tokenId][172];
    if (outliner == 0) {
      return '#f1f378';
    } else if (outliner == 1) {
      return '#99c7f2';
    }

    return '#a2f2aa';
  }

  function getPath(uint8[] memory points) private pure returns (string memory) {
    uint256 length = points.length;
    length = length - 2;
    string memory move;
    string memory line;
    string memory result = '';
    for (uint256 i = 0; i < length; ) {
      move = string.concat(
        'M',
        uint256(points[i]).toString(),
        ',',
        uint256(points[i + 1]).toString()
      );
      line = string.concat(
        'L',
        uint256(points[i + 2]).toString(),
        ',',
        uint256(points[i + 3]).toString()
      );

      result = string(abi.encodePacked(result, move, line));

      unchecked {
        i += 2;
      }
    }

    return result;
  }

  function pseudoRandom() private view returns (uint256) {
    return
      uint256(keccak256(abi.encodePacked(block.difficulty, block.timestamp)));
  }
}
