// SPDX-License-Identifier: MIT
pragma solidity ^0.8.2;

import "ERC721.sol";
import "Ownable.sol";
import "Counters.sol";
import "Pausable.sol";

contract EggHeadsClub is ERC721, Pausable, Ownable {
    uint internal constant TOKEN_LIMIT = 3500;
    uint internal constant MAX_PUBLIC_MINT = 5;

    using Counters for Counters.Counter;
    Counters.Counter private _tokenIdCounter;

	struct User {
		bool onWhitelist;
		uint256 whitelistRemainingMints;
		uint256 publicMints;
    }
    mapping(address => User) public users;
    uint256 internal _mintPrice = 0.05 ether;

    address payable internal devTeam;

    string internal _baseTokenURI;
    bool internal saleStarted = false;
    bool internal openToPublic = false;
    bool internal URISet = false;
    Counters.Counter private _devSupplyAwarded;



    /// The sale has not started yet.
    error SaleNotStarted();
    /// Max tokens have been minted.
    error MaxTokensMinted();
    /// Mint would exceed max supply.
    error MintExceedsMaxSupply();
    /// You are not on the whitelist
    error NotOnWhitelist();
    /// Mint would exceed your allowance
    error MintedExceedsMaxAllowance();
    /// You have minted your allowance
    error MintedAllowance();
    /// msg.value too low
    error MintPayableTooLow();
    /// Sale has already started
    error SaleStarted();
    /// Dev team award limit reached.
    error DevTeamAwardLimit();

    constructor(string memory name, string memory symbol, address devTeamAddress) ERC721(name, symbol) {
        devTeam = payable(devTeamAddress);
        _tokenIdCounter.increment(); // dev: starts tokens at id of 1
    }

    modifier isBelowMaxSupply(uint _count) {
        uint256 tokenCount = _tokenIdCounter.current();
        if (tokenCount >= TOKEN_LIMIT)
            revert MaxTokensMinted(); // dev: max token supply minted
        if ((tokenCount - 1) + _count >= TOKEN_LIMIT)
            revert MintExceedsMaxSupply(); // dev: mint would exceed max supply
        _;
    }

    modifier isNotBelowMintPrice(uint _count) {
        if (msg.value < _count * _mintPrice)
            revert MintPayableTooLow(); // dev: msg.value too low
        _;
    }


    /**
     * @dev Creates a new token. Its token ID will be automatically
     * assigned (and available on the emitted {IERC721-Transfer} event), and the token
     * URI autogenerated based on the base URI passed at construction.
     *
     * See {ERC721-_mint}.
     *
     */
    function preSaleMint(address _to, uint _count)
    external
    isBelowMaxSupply(_count)
    isNotBelowMintPrice(_count)
    payable {
        if (saleStarted == false)
            revert SaleNotStarted(); // dev: sale not started

        User storage user  = users[msg.sender];
        if (user.onWhitelist == false)
            revert NotOnWhitelist(); // dev: not on the whitelist

        if (user.whitelistRemainingMints <= 0)
            revert MintedAllowance(); // dev: allowance minted

        if (user.whitelistRemainingMints < _count)
            revert MintedExceedsMaxAllowance(); // dev: mint would exceeds allowance

        for (uint i = 0; i < _count; i++) {
            uint256 tokenId = _tokenIdCounter.current();
            user.whitelistRemainingMints--;
            _tokenIdCounter.increment();
            _safeMint(_to, tokenId);
          }
    }

    function publicSaleMint(address _to, uint _count)
    external
    isBelowMaxSupply(_count)
    isNotBelowMintPrice(_count)
    payable {
        if (openToPublic == false)
            revert SaleNotStarted(); // dev: sale not started

        User storage user  = users[msg.sender];
        if (user.publicMints  >= MAX_PUBLIC_MINT)
            revert MintedAllowance(); // dev: allowance minted

        if (user.publicMints + _count > MAX_PUBLIC_MINT)
            revert MintedExceedsMaxAllowance(); // dev: mint would exceeds allowance


        for (uint i = 0; i < _count; i++) {
            uint256 tokenId = _tokenIdCounter.current();
            user.publicMints++;
            _tokenIdCounter.increment();
            _safeMint(_to, tokenId);
          }
    }

    /**
     * @dev takes a list of addresses and gives each address a allocation of mints
     */
    function addToWhiteList(address[] memory whitelist_addresses, uint mintCount) external onlyOwner {
        for (uint i = 0; i < whitelist_addresses.length; i++) {
            User storage user = users[whitelist_addresses[i]];
            user.whitelistRemainingMints = mintCount;
            user.onWhitelist = true;
        }
    }

    /**
    * Can only be called twice. Gives 110 total Tokens to devs for giveaways, marketing purposes and team members.
    */
    function devAward() external onlyOwner {
        uint256 devSupplyAwarded = _devSupplyAwarded.current();
        if (devSupplyAwarded >= 2)
            revert DevTeamAwardLimit(); // dev: dev award limit reached

        for(uint i = 0; i < 55; i++){
            uint256 tokenId = _tokenIdCounter.current();
            _tokenIdCounter.increment();
            _safeMint(devTeam, tokenId);
        }
        _devSupplyAwarded.increment();
    }

    /**
    * open mint up to the public
    */
    function openMintToPublic() external onlyOwner {
        if (openToPublic == true)
            revert SaleStarted(); // dev: public sale has already started
        openToPublic = true;
    }

    /**
    * Start the sale (cant be stopped later)
    */
    function openPreSale() external virtual onlyOwner {
        if (saleStarted == true)
            revert SaleStarted(); // dev: sale has already started
        saleStarted = true;
    }

    /**
    * Withdraw contract funds to owner
    */
    function withdrawFunds() external virtual onlyOwner {
        devTeam.transfer(address(this).balance);
    }

    function setBaseURI(string memory baseTokenURI) external onlyOwner {
        _baseTokenURI = baseTokenURI;
        URISet = true;
    }

    function _baseURI() internal view virtual override returns (string memory) {
        return _baseTokenURI;
    }

    /**
     * @dev See {IERC165-supportsInterface}.
    */
    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721) returns (bool) {
        return super.supportsInterface(interfaceId);
    }

    function getMaxSupply() external pure returns (uint256) {
        return TOKEN_LIMIT;
    }

    function getMintPrice() external view returns (uint256) {
        return _mintPrice;
    }

    function getSaleStarted() external view returns (bool) {
        return saleStarted;
    }

    function getOpenToPublic() external view returns (bool) {
        return openToPublic;
    }

    function getOnWhitelist(address add) external view returns (bool) {
        return users[add].onWhitelist;
    }

    function getRemainingWhitelistMints(address add) external view returns (uint256) {
        return users[add].whitelistRemainingMints;
    }

    function getRemainingPublicMints(address add) external view returns (uint256) {
        return MAX_PUBLIC_MINT - users[add].publicMints;
    }

    function getTotalMinted() external view returns (uint256) {
        uint256 tokenCount = _tokenIdCounter.current();
        return tokenCount - 1;
    }

    function pause() public onlyOwner {
        _pause();
    }

    function unpause() public onlyOwner {
        _unpause();
    }

    function _beforeTokenTransfer(address from, address to, uint256 tokenId)
        internal
        whenNotPaused
        override
    {
        super._beforeTokenTransfer(from, to, tokenId);
    }

}
