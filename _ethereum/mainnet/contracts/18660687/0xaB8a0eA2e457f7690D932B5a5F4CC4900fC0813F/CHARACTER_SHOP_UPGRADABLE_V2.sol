//SPDX-License-Identifier: Unlicense
pragma solidity 0.8.17;

import "./MerkleProofUpgradeable.sol";
import "./OwnableUpgradeable.sol";
import "./ReentrancyGuardUpgradeable.sol";
import "./PausableUpgradeable.sol";
import "./StringsUpgradeable.sol";
import "./Initializable.sol";
import "./CHARACTER_V1_UPGRADABLE.sol";

// @title: Wally Shop Smart contract
// @author: SQuare Enix
// @notice: NFT marketplace for the sale of Symbiogenesis project's NFTs(ERC-721).
// @custom: Users can bid on their favorite NFT tokens and win the auction by making highest bid or buy NFT token direcly

contract CHARACTER_SHOP_UPGRADEABLE_V2 is Initializable, ReentrancyGuardUpgradeable, PausableUpgradeable, OwnableUpgradeable {
    using StringsUpgradeable for uint256;
    //private mapping variable that stores auction data as keys reference to address and id of token 
    //returns structure type auction data
    mapping(address => mapping(uint256 => Auction)) private nftContractAuctions;
    //private mapping variable that stores counts of NFT token which user bought
    mapping(address => mapping(uint256 => uint128)) public userBuyCountInSmallSale;
    //private array variable that stores that stores sale data
    //returns structure type sale data.
    SmallSale[] public smallSales;
    //address that payment for NFT token from users is transferred.
    address public feeReceiver;
    //Amount of ethers which sending transactions are failed in the process of NFT sale.
    uint256 public failedTransferCredits;
    //public mapping variable that stores base Uri for chapter as keys reference to address and id of token.
    //returns structure type  BaseUriForChapter data.
    mapping(address => mapping(uint8 => BaseUrlForChapter)) public baseUrlForChapter;
    //enum type data that stores Sale type.
    enum SaleType {
        BuyNow, // immediate sell and buy sale type that has price larger than zero.
        EnglishAuction, // Auction sale type.
        ZeroPriceSale // imediate sell and buy sale type which price is equal with zero.
    }
    
    struct SmallSale {
        bytes32 allowListRoot; // root value of merkletree for allowlists
        uint128 price; //  price of token being sold or start price of token in auction.
        uint128 buyLimit; // limit count of token that user can purchase.
        address nftContractAddress; // NFT contract address
        uint8 chapterId; // chapter id 
        SaleType saleType; // Sale type
        uint128 bidIncreaseAmount; // amount that user should pay more than prevous highest bidder in Auction
        uint256 startAt; // start time of auction
        uint256 auctionEnd; // end tine of auction
    }

    struct BaseUrlForChapter {
        uint8 isSet; // status variable that represent whether baseUri is set or not
        string baseUrl; // base uri
    }

    struct Auction {
        uint256 auctionEnd; // auction end time
        uint128 nftHighestBid; // amount that highest bidder pay(ether or other native token)
        address nftHighestBidder; // address of highest bidder
        uint8 sold; // status variable represent whether NFT token is sold or not.
        bool isOnAuction; // status variable represent whether auction is going or not.
        uint256 bidsCount; // count of bidders.
        uint256 smallSaleId; // Sale id
    }
    //Comprehensive Auction data structure.
    //it supports to getting the comprehensive auction data and providing it to the out of blockchain 
    struct CombinedAuctionData {
        uint128 bidIncreaseAmount;
        uint32 reserved_1;
        uint256 auctionEnd;
        uint128 minPrice;
        uint128 buyNowPrice;
        uint128 nftHighestBid;
        bytes32 allowListRoot;
        address nftHighestBidder;
        string tokenURI;
        uint8 sold;
        bool isOnAuction;
        uint256 bidsCount;
        uint256 startAt;
        uint256 smallSaleId;
    }

    /*╔═════════════════════════════╗
      ║           EVENTS            ║
      ╚═════════════════════════════╝*/
    //event that is trigered when auction is created
    //NFT contract address, token id and sale id
    event AuctionCreated(
        address indexed nftContractAddress,
        uint256 indexed tokenId,
        uint256 indexed smallSaleId
    );
    //event that is trigered when sale is created
    //NFT contract address, token id, token price and buyer address
    event SaleCreated(
        address indexed nftContractAddress,
        uint256 indexed tokenId,
        uint128 buyNowPrice,
        address buyer
    );
    //event that is trigered when bid is made
    //NFT contract address, token id, bidder address, eth amount bidder pay, time bid is made.
    event BidMade(
        address indexed nftContractAddress,
        uint256 indexed tokenId,
        address bidder,
        uint128 ethAmount,
        uint256 createdAt
    );
    //event that is trigered when payout is failed
    //NFT contract address, token id, sale id, eth amount that payout, recipient address.
    event FailedPayout(
        address indexed nftContractAddress,
        uint256 indexed tokenId,
        address toAddress,
        uint128 ethAmount
    );
    //event that is trigered when auction end time is updated
    //param: NFT contract address, token id and time added to auction end time
    event AuctionPeriodUpdated(
        address indexed nftContractAddress,
        uint256 indexed tokenId,
        uint256 auctionEndPeriod
    );
    //event that is trigered when NFT(id)is minted and nfthighestBid is transferred to feeReceiver address.
    //param: NFT contract address, token id, eth amount of highest bidder pay and address of highest bidder
    event CharaterMintedAndPaymentPaid(
        address indexed nftContractAddress,
        uint256 indexed tokenId,
        uint128 nftHighestBid,
        address nftHighestBidder
    );
    //event that is trigered when auction is settled
    //param: NFT contract address, token id and address of user call settleAuction function.
    event AuctionSettled(
        address indexed nftContractAddress,
        uint256 indexed tokenId,
        address auctionSettler
    );
    //event that is trigered when auction is widrawn
    //param: NFT contract address, token id and address of nft owner.
    event AuctionWithdrawn(
        address indexed nftContractAddress,
        uint256 indexed tokenId,
        address nftOwner
    );
    //event that is trigered when takeHighestBidder is triggered.
    //param: NFT contract address and token id 
    event HighestBidTaken(
        address indexed nftContractAddress,
        uint256 indexed tokenId
    );
    //event that is trigered when sale is created
    //param: NFT contract address, token id, sale id and time that sale created at.
    event SmallSaleCreated(uint256 indexed smallSaleId, uint256 createdAt);
    //event that is trigered when BaseUri is set for chapter.
    //param: NFT contract address, token id, sale id, baseUrl and time that baseUrl is set.
    event BaseUrlForChapterSet(
        address indexed nftContractAddress,
        uint8 indexed chapterId,
        string baseUrl,
        uint256 createdAt
    );
    event MerkleRootUpdated(uint256 indexed smallSaleId, bytes32 merkleRoot);

    /**********************************/
    /*╔═════════════════════════════╗
      ║             END             ║
      ║            EVENTS           ║
      ╚═════════════════════════════╝*/
    /**********************************/
    //modifier that check if auction is ongoing
    //param: NFT contract address, token id and sale id
    //check if token is sold, saleId is valid and current time is in the range of auction time
    modifier auctionOngoing(address _nftContractAddress, uint256 _tokenId) {
        require(
            nftContractAuctions[_nftContractAddress][_tokenId].sold == 0,
            "Token is already sold!"
        );
        require(
            nftContractAuctions[_nftContractAddress][_tokenId].smallSaleId < smallSales.length,
            "Small sale does not exist on this token."
        );
        require(
            _isAuctionOngoing(_nftContractAddress, _tokenId) == 1,
            "Auction has ended or not started yet"
        );
        _;
    }
    //modifier that check if smallSale exists.
    //param: sale id
    //check if the sale id is in the valid range.
    modifier smallSaleExist(uint256 _smallSaleId) {
        require(_smallSaleId < smallSales.length, "SmallSaleID is invalid!");
        _;
    }
    //modifier that check if counts of NFT that user bought exceed the limit.
    //param: NFT contract address, token id 
    //first check if the sale id is in the valid range and check if userBuyCount exceed the limit.
    modifier notExceedBuyLimit(address _nftContractAddress, uint256 _tokenId) {
        uint256 smallSaleId = nftContractAuctions[_nftContractAddress][_tokenId]
            .smallSaleId;
        require(
            smallSaleId < smallSales.length,
            "Not existing small sale for current token"
        );
        require(
            userBuyCountInSmallSale[msg.sender][smallSaleId] <
                smallSales[smallSaleId].buyLimit,
            "User exceeds buy limit for current small sale"
        );
        _;
    }

    //modifier that check if bid amount user pay meets certain requirement 
    //param: NFT contract address, token id 
    //call other modifier _doesBidMeetBidRequirements.
    modifier bidAmountMeetsBidRequirements(
        address _nftContractAddress,
        uint256 _tokenId
    ) {
        require(
            _doesBidMeetBidRequirements(_nftContractAddress, _tokenId) == 1,
            "Not enough funds to bid on NFT"
        );
        _;
    }
    //modifier that check if chapter is valid 
    //param: NFT contract address, token id 
    //check isSet of baseUriForChapter is equal with 1
    modifier isValidChapter(address _nftContractAddress, uint8 _chapterId) {
        require(
            baseUrlForChapter[_nftContractAddress][_chapterId].isSet == 1,
            "Base URL for chapter is not set"
        );
        _;
    }

    /**********************************/
    /*╔═════════════════════════════╗
      ║             END             ║
      ║          MODIFIERS          ║
      ╚═════════════════════════════╝*/

      
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++///@notice: modifier that check if bid amount user pay meets certain requirement 
    //This is a constructor that is executed when contract deployed, 
    //param: wallet address that all ethers that users pay for NFT are transferred
    //check if parameter is valid address.
     function initialize(address _feeReceiver) external initializer {
        require(_feeReceiver != address(0), "Cannot specify 0 address");
        feeReceiver = _feeReceiver;
        __Pausable_init();
        __ReentrancyGuard_init();
        __Ownable_init();
     }


    //@nitice: This is a externalfunction that create one of three kinds of Sales according to Sale type.
    //@param: all variables to create Sale and describe the Sale.
    //@dev: Only Contract Owner can call this function and can execute this function when contract is not paused, there is no reentrance attack and baseUrl for chapter is set correctly. 
    //@return: return Sale id.
    function createSmallSale(
        bytes32 _allowRoot,
        SaleType _saleType,
        uint128 _price,
        uint128 _buyLimit,
        address _nftContractAddress,
        uint8 _chapterId,
        uint128 _bidIncreaseAmount,
        uint256 _startAt,
        uint256 _endAt
    )
        external
        onlyOwner
        whenNotPaused
        nonReentrant
        isValidChapter(_nftContractAddress, _chapterId)
        returns (uint256)
    {
        ///check if cureent time is in the range of auction time
        require(
            block.timestamp < _endAt,
            "Auction end is less than current timestamp"
        );
        require(_startAt < _endAt, "Auction end is less than auction start");
        ///check if buylimits is valid value(must be bigger than zero).
        require(_buyLimit > 0, "Buy limit must larger than 0");
        /// check if corresponding conditions fit depending on the sale type
        if (_saleType == SaleType.ZeroPriceSale && _price > 0)
            revert("Price should be zero on Zero price sale.");
        if (_saleType == SaleType.BuyNow && _price == 0)
            revert("Price should be larger than zero on Buy now sale.");
        if (_saleType == SaleType.EnglishAuction && _bidIncreaseAmount == 0)
            revert(
                "Bid increase amount should be larger than zero on English auction."
            );
        if (_saleType != SaleType.EnglishAuction && _bidIncreaseAmount != 0)
            revert("Bid increae amount should be zero on buy now sale.");
        
        smallSales.push(
            SmallSale(
                _allowRoot,
                _price,
                _buyLimit,
                _nftContractAddress,
                _chapterId,
                _saleType,
                _bidIncreaseAmount,
                _startAt,
                _endAt
            )
        );
        uint256 saleCount = smallSales.length - 1;
        emit SmallSaleCreated(saleCount, block.timestamp);
        return saleCount;
    }

    //@notice: This is a external function that can set the baseUrl for Chapter of NFT.
    //@param: NFT contract address, Chapter id, baseUrl
    //@dev: Only contract owner can call this function and can execute when contract is not paused.
    function setBaseUrlForChapter(
        address _nftContractAddress,
        uint8 _chapterId,
        string calldata _baseUrl
    ) external onlyOwner whenNotPaused {
        require(_nftContractAddress != address(0), "Invalid address");
        baseUrlForChapter[_nftContractAddress][_chapterId] = BaseUrlForChapter(
            1,
            _baseUrl
        );
        emit BaseUrlForChapterSet(
            _nftContractAddress,
            _chapterId,
            _baseUrl,
            block.timestamp
        );
    }

    /*╔══════════════════════════════╗
      ║    AUCTION CHECK FUNCTIONS   ║
      ╚══════════════════════════════╝*/

    //This is a internal view function that can check msg.sender is in the allow list.
    //param: merkle root and merkle proof of allowlist merkle tree.
    //return bool value that verify if byte value of msg.sender is a part of allowlist merkle tree
    function _isInAllowList(
        bytes32 merkleRoot,
        bytes32[] memory merkleProof
    ) internal view returns (bool) {
        return
            MerkleProofUpgradeable.verify(merkleProof, merkleRoot, toBytes32(msg.sender));
    }

    //This is an internal view function that can get a URI of a certain token 
    //param: NFT contract address, token id 
    //token URI is obtained from baseUriForChapter mapping variable.
    //return: return  token URI as string
    function _tokenURI(
        address _nftContractAddress,
        uint256 _tokenId
    ) internal view returns (string memory) {
        uint256 smallSaleId = nftContractAuctions[_nftContractAddress][_tokenId]
            .smallSaleId;
        string memory baseURI = baseUrlForChapter[_nftContractAddress][
            smallSales[smallSaleId].chapterId
        ].baseUrl;
        return
            bytes(baseURI).length > 0
                ? string(abi.encodePacked(baseURI, _tokenId.toString()))
                : "";
    }

    //This is an internal view function that check if auction is ongoing 
    //param: NFT contract address, token id 
    //token URI is obtained from baseUriForChapter mapping variable.
    //return  uint value that represent the staus whether the auction is going or not.
    function _isAuctionOngoing(
        address _nftContractAddress,
        uint256 _tokenId
    ) internal view returns (uint8) {
        uint256 auctionEndTimestamp = nftContractAuctions[_nftContractAddress][
            _tokenId
        ].auctionEnd;
        uint256 smallSaleId = nftContractAuctions[_nftContractAddress][_tokenId]
            .smallSaleId;
        uint256 auctionStart = smallSales[smallSaleId].startAt;

        if (auctionEndTimestamp != 0 &&
            block.timestamp < auctionEndTimestamp &&
            block.timestamp >= auctionStart) {
            return 1;
        }

        return 0;
    }

    //This is an internal view function that check if there is a bid on a certain auction.
    //param: NFT contract address, token id 
    //return  uint value that represent the staus if there is a bid on a certain auction
    function _isABidMade(
        address _nftContractAddress,
        uint256 _tokenId
    ) internal view returns (uint8) {
        if (nftContractAuctions[_nftContractAddress][_tokenId]
            .nftHighestBidder != address(0)) {
            return 1;
        }
        return 0;
    }

    //This is an internal view function that check whether current auction is one of buyNowSale and zeroSale or not and check if corresponding conditions fit.
    //param: NFT contract address, token id.
    //return uint value that represent the staus if current auction is one of buyNowSale and zeroSale or not and check if corresponding conditions fit.
    function _isBuyNowPriceMetOrZeroSale(
        address _nftContractAddress,
        uint256 _tokenId
    ) internal view returns (uint8) {
        uint256 smallSaleId = nftContractAuctions[_nftContractAddress][_tokenId]
            .smallSaleId;
        if (smallSales[smallSaleId].saleType != SaleType.EnglishAuction &&
            nftContractAuctions[_nftContractAddress][_tokenId].nftHighestBid >= smallSales[smallSaleId].price)
        {
            return 1;
        }

        return 0;
    }

    //This is an internal view function that checks if the current bid meets the requirement of the corresponding auction.
    //param: NFT contract address, token id.
    //return uint value that represent the staus if the current bid meets the requirement of the corresponding auction.
    function _doesBidMeetBidRequirements(
        address _nftContractAddress,
        uint256 _tokenId
    ) internal view returns (uint8) {

        uint256 smallSaleId = nftContractAuctions[_nftContractAddress][_tokenId]
            .smallSaleId;
        SmallSale memory currentSmallSale = smallSales[smallSaleId];
        //if buyNowPrice is met, ether amount of bid is bigger than token price of current auction.
        if (currentSmallSale.saleType == SaleType.BuyNow) {
            if (msg.value >= currentSmallSale.price) {
                return 1;
            }
            return 0;
        } else if (
            smallSales[smallSaleId].saleType == SaleType.EnglishAuction
        ) {
            //if the NFT is up for auction, if highestBid exists, ether amount of bid should be bigger than highestbid + bidIncreaseAmount and if highest bidder nonexists, ether amount of bid should be bigger than minprice of current auction.
            uint256 highestBid = nftContractAuctions[_nftContractAddress][
                _tokenId
            ].nftHighestBid;
            address nftHighestBidder = nftContractAuctions[_nftContractAddress][
                _tokenId
            ].nftHighestBidder;
            uint256 validBidAmount = nftHighestBidder == address(0)
                ? currentSmallSale.price
                : highestBid + currentSmallSale.bidIncreaseAmount;

            if (msg.value >= validBidAmount) {
                return 1;
            }
            return 0;
        } else {
            // ZeroPriceSale
            return 1;
        }
    }

    /**********************************/
    /*╔══════════════════════════════╗
      ║             END              ║
      ║    AUCTION CHECK FUNCTIONS   ║
      ╚══════════════════════════════╝*/
    /**********************************/

    /*╔══════════════════════════════╗
      ║       AUCTION CREATION       ║
      ╚══════════════════════════════╝*/
    //This is an internal function that setup Auction with given auction info.
    //param: Sale id, NFT contract address, token id and auction end time
    //store auction info to the nftContractAuctions mapping variable as keys reference to NFT address and token id.
    function _setupAuction(    
        uint256 _smallSaleId,
        address _nftContractAddress,
        uint256 _tokenId,
        uint256 _auctionEnd
    ) internal {

        nftContractAuctions[_nftContractAddress][_tokenId]
            .auctionEnd = _auctionEnd;

        nftContractAuctions[_nftContractAddress][_tokenId]
            .smallSaleId = _smallSaleId;

        nftContractAuctions[_nftContractAddress][_tokenId]
            .isOnAuction = true;

        // emit AuctionCreated(_nftContractAddress, _tokenId, _smallSaleId);
    }
    //This is an internal function that create Auction with given auction info.
    //param: Sale id, NFT contract address, token id and auction end time
    //first check if current auction is already created and check if there is higest bidder ,and call _sepupAuction function. 
    function _createNewNftAuction(
        uint256 _smallSaleId,
        address _nftContractAddress,
        uint256 _tokenId,
        uint256 _auctionEnd
    ) internal {
        if (nftContractAuctions[_nftContractAddress][_tokenId].isOnAuction) {
            require(
                block.timestamp > nftContractAuctions[_nftContractAddress][_tokenId].auctionEnd &&
                nftContractAuctions[_nftContractAddress][_tokenId].nftHighestBidder == address(0), 
                "Auction still ongoing or there is highestBidder"
            );
        }
        _setupAuction(
            _smallSaleId,
            _nftContractAddress,
            _tokenId,
            _auctionEnd
        );
    }
    //@notice: This is an external function that create Auction on batch token ids.
    //@param: Sale id and token ids
    //@dev: Only contract owner can execute this function, this function can execute when contract is not paused and Sale id is valid. check if current token is minted or burned on every token id while circulate token ids. if not minted and not burned, call _createNewNftAuction function.
    function createNewNftAuction(
        uint256 _smallSaleId,
        uint256[] calldata _tokenIds
        ) external onlyOwner whenNotPaused smallSaleExist(_smallSaleId) {
        SmallSale memory smallSale = smallSales[_smallSaleId];
        address _nftContractAddress = smallSale.nftContractAddress;
        uint256 auctionEndTime = smallSale.auctionEnd;
        CHARACTER_V1_UPGRADEABLE character = CHARACTER_V1_UPGRADEABLE(_nftContractAddress);
        uint256 length = _tokenIds.length;

        for (uint16 i; i < length;) {
            // require(!character.isBurnedToken(_tokenIds[i]), "Token is burned");
            require(!character.exists(_tokenIds[i]), "Token is minted");
            _createNewNftAuction(
                _smallSaleId,
                _nftContractAddress,
                _tokenIds[i],
                auctionEndTime
            );
            unchecked {++i;}
        }
    }
    //@notice: This is an external view function that get comprehensive Auction data depending on Nft address and token id.
    //@param: NFT contract address and token id
    //@return: if auction exists, return CombinedAuctionData according Nft address and token id and if auction is nonexist, return CombinedAuctionData with empty values.
    function getAunctionData(
        address _nftContractAddress,
        uint256 _tokenId
    ) external view returns (CombinedAuctionData memory auctionData) {
        Auction memory res_1 = nftContractAuctions[_nftContractAddress][
            _tokenId
        ];
        if (res_1.auctionEnd == 0) {
            auctionData = CombinedAuctionData(
                0,
                0,
                0,
                0,
                0,
                0,
                bytes32(0),
                address(0),
                "",
                0,
                false,
                0,
                0,
                0
            );
        } else {
            SmallSale memory res_2 = smallSales[res_1.smallSaleId];
            string memory tokenURI = _tokenURI(_nftContractAddress, _tokenId);
            auctionData = CombinedAuctionData(
                res_2.bidIncreaseAmount,
                0,
                res_1.auctionEnd,
                res_2.price,
                res_2.price,
                res_1.nftHighestBid,
                res_2.allowListRoot,
                res_1.nftHighestBidder,
                tokenURI,
                res_1.sold,
                res_1.isOnAuction,
                res_1.bidsCount,
                res_2.startAt,
                res_1.smallSaleId
            );
        }
        return auctionData;
    }

    /**********************************/
    /*╔══════════════════════════════╗
      ║             END              ║
      ║       AUCTION CREATION       ║
      ╚══════════════════════════════╝*/
    /**********************************/

    /*╔══════════════════════════════╗
      ║            SALES             ║
      ╚══════════════════════════════╝*/

    /********************************************************************
     * Allows for a standard sale mechanism where the NFT seller can    *
     * can select an allow list. This list is then    *
     * allowed to make a bid on the NFT. No other address can bid on    *
     * the NFT.                                                         *
     ********************************************************************/

    //This is an internal function that deal with the sale in case of BuyNow sale and ZeroPrice sale.
    //param: NFT contract address and token id
    //call _mintNftAndTransferPayment with zero status value(EnglishAuction:1, BuyNow and ZeroPrice:0)
    function _createSale(
        address _nftContractAddress,
        uint256 _tokenId
    ) internal {
        _mintNftAndTransferPayment(_nftContractAddress, _tokenId, 0);
        address _buyer = nftContractAuctions[_nftContractAddress][_tokenId]
            .nftHighestBidder;
        uint128 _amount = nftContractAuctions[_nftContractAddress][_tokenId]
            .nftHighestBid;

        emit SaleCreated(_nftContractAddress, _tokenId, _amount, _buyer);
    }

    /**********************************/
    /*╔══════════════════════════════╗
      ║             END              ║
      ║            SALES             ║
      ╚══════════════════════════════╝*/
    /**********************************/

    /*╔═════════════════════════════╗
      ║        BID FUNCTIONS        ║
      ╚═════════════════════════════╝*/

    
    //This is an internal function that deal with making a bid
    //param: NFT contract address and token id
    //this function execute when amount of bid meets requirement of current auction. Call _reversePreviousBidAndUpdateHighestBid function, update auction time(extend the auction duration) and increase bidsCount.
    function _makeBid(
        address _nftContractAddress,
        uint256 _tokenId
    ) internal bidAmountMeetsBidRequirements(_nftContractAddress, _tokenId) {
        _reversePreviousBidAndUpdateHighestBid(_nftContractAddress, _tokenId);

        _updateOngoingAuction(_nftContractAddress, _tokenId);
        nftContractAuctions[_nftContractAddress][_tokenId].bidsCount++;

        emit BidMade(
            _nftContractAddress,
            _tokenId,
            msg.sender,
            uint128(msg.value),
            block.timestamp
        );
    }
    //@notice: This is an external payable function that deal with making a bid
    //@param: NFT contract address, token id and merkleproof.
    //@dev: this function execute when contract is not paused, there is no reentrance call, auction is on the status of ongoing, do not exceed the buylimits and there is valid sale id and merkleproof. Call _makeBid and in case of BuyNow and Zeroprice, call _createSale.
    function makeBid(
        address _nftContractAddress,
        uint256 _tokenId,
        bytes32[] calldata merkleProof
    )
        external
        payable
        whenNotPaused
        nonReentrant
        auctionOngoing(_nftContractAddress, _tokenId)
        notExceedBuyLimit(_nftContractAddress, _tokenId)
    {
        bytes32 root = smallSales[
            nftContractAuctions[_nftContractAddress][_tokenId].smallSaleId
        ].allowListRoot;
        require(
            root == bytes32(0) || _isInAllowList(root, merkleProof),
            "invalid merkle proof"
        );
        _makeBid(_nftContractAddress, _tokenId);
        if (_isBuyNowPriceMetOrZeroSale(_nftContractAddress, _tokenId) == 1) {
            _createSale(_nftContractAddress, _tokenId);
        }
    }

    /**********************************/
    /*╔══════════════════════════════╗
      ║             END              ║
      ║        BID FUNCTIONS         ║
      ╚══════════════════════════════╝*/
    /**********************************/

    /*╔══════════════════════════════╗
      ║       UPDATE AUCTION         ║
      ╚══════════════════════════════╝*/

    /***************************************************************
     * Settle an auction or sale if the buyNowPrice is met or set  *
     *  auction period to begin if the minimum price has been met. *
     ***************************************************************/

    //This is an internal function that update Auction time
    //param: NFT contract address and token id
    //When sale type is EmglishAuction, Call _updateAuctionEnd.
    function _updateOngoingAuction(
        address _nftContractAddress,
        uint256 _tokenId
    ) internal {
        if (_isBuyNowPriceMetOrZeroSale(_nftContractAddress, _tokenId) == 1) {
            return;
        }
        //min price not set, nft not up for auction yet
        _updateAuctionEnd(_nftContractAddress, _tokenId);
    }
    //his is an internal function that update Auction End time
    //param: NFT contract address and token id
    //When it is 5 mins before auction end, increase auction end by 5 mins.
    function _updateAuctionEnd(
        address _nftContractAddress,
        uint256 _tokenId
    ) internal {
        //the auction end is always set to now + the bid period
        if (
            nftContractAuctions[_nftContractAddress][_tokenId].auctionEnd -
                block.timestamp <
            300
        ) {
            nftContractAuctions[_nftContractAddress][_tokenId]
                .auctionEnd += 300;
            emit AuctionPeriodUpdated(
                _nftContractAddress,
                _tokenId,
                nftContractAuctions[_nftContractAddress][_tokenId].auctionEnd
            );
        }
    }

    /**********************************/
    /*╔══════════════════════════════╗
      ║             END              ║
      ║       UPDATE AUCTION         ║
      ╚══════════════════════════════╝*/
    /**********************************/


    /*╔══════════════════════════════╗
      ║         UPDATE BIDS          ║
      ╚══════════════════════════════╝*/
    /******************************************************************
     * Internal functions that update bid parameters and reverse bids *
     * to ensure contract only holds the highest bid.                 *
     ******************************************************************/

    //This is an internal function that update highestBid
    //param: NFT contract address and token id
    //Set current bidder as highest bidder and increase corresponding userBuyCountInSmallSale.
    function _updateHighestBid(
        address _nftContractAddress,
        uint256 _tokenId
    ) internal {
        nftContractAuctions[_nftContractAddress][_tokenId]
            .nftHighestBid = uint128(msg.value);
        nftContractAuctions[_nftContractAddress][_tokenId]
            .nftHighestBidder = msg.sender;
        // update user's buyCount in smallSale
        userBuyCountInSmallSale[msg.sender][
            nftContractAuctions[_nftContractAddress][_tokenId].smallSaleId
        ]++;
    }
    //This is an internal function that refund previousBid and update highest bid when there is new highest bidder.
    //param: NFT contract address and token id
    //Call _updateHighestBid and when there is prevNftHighestBidder, refund. 
    function _reversePreviousBidAndUpdateHighestBid(
        address _nftContractAddress,
        uint256 _tokenId
    ) internal {
        address prevNftHighestBidder = nftContractAuctions[_nftContractAddress][
            _tokenId
        ].nftHighestBidder;

        uint128 prevNftHighestBid = nftContractAuctions[_nftContractAddress][
            _tokenId
        ].nftHighestBid;
        uint256 smallSaleId = nftContractAuctions[_nftContractAddress][_tokenId]
            .smallSaleId;
        _updateHighestBid(_nftContractAddress, _tokenId);

        if (prevNftHighestBidder != address(0)) {
            if (prevNftHighestBid > 0) {
                _payout(
                    _nftContractAddress,
                    _tokenId,
                    prevNftHighestBidder,
                    prevNftHighestBid
                );
            }
            userBuyCountInSmallSale[prevNftHighestBidder][smallSaleId]--;
        }
    }

    /**********************************/
    /*╔══════════════════════════════╗
      ║             END              ║
      ║         UPDATE BIDS          ║
      ╚══════════════════════════════╝*/
    /**********************************/

    /*╔══════════════════════════════╗
      ║  TRANSFER NFT & PAY SELLER   ║
      ╚══════════════════════════════╝*/
    //This is an internal function that mint NFT and transfer payments when auction winner is determined or auction end.
    //param: NFT contract address, token id and _refundWhenMinted the status value that represent whether refund or not when token is minted.
    //Check if NFT token id is minted. if not minted mint NFT token to the address of winner, transfer payment to the feeReceiver address, set sold status of auction data as true and update the auctionEnd of auction data as current time. if minted, in case of EnglishAuctoin(depending on _refundWhenMinted), refund payment to winner and in case of rest cases, just revert with error message.
    function _mintNftAndTransferPayment(
        address _nftContractAddress,
        uint256 _tokenId,
        uint8 _refundWhenMinted
    ) internal {
        address _nftHighestBidder = nftContractAuctions[_nftContractAddress][
            _tokenId
        ].nftHighestBidder;
        uint128 _nftHighestBid = nftContractAuctions[_nftContractAddress][
            _tokenId
        ].nftHighestBid;
        string memory _tokenUri = _tokenURI(_nftContractAddress, _tokenId);

        if (CHARACTER_V1_UPGRADEABLE(_nftContractAddress).exists(_tokenId)) {
            if (_refundWhenMinted == 1) {
                if (_nftHighestBid > 0) {
                    _payout(
                        _nftContractAddress,
                        _tokenId,
                        _nftHighestBidder,
                        _nftHighestBid
                    );
                }
            }
            else {
                revert("Token is already minted");
            }
        } else {
            if (_nftHighestBid > 0) {
                _payout(_nftContractAddress, _tokenId, feeReceiver, _nftHighestBid);
            }

            CHARACTER_V1_UPGRADEABLE(_nftContractAddress).mint(
                _tokenId,
                _nftHighestBidder,
                _tokenUri
            );

            emit CharaterMintedAndPaymentPaid(
                _nftContractAddress,
                _tokenId,
                _nftHighestBid,
                _nftHighestBidder
            );
        }

        nftContractAuctions[_nftContractAddress][_tokenId].auctionEnd = block.timestamp;
        nftContractAuctions[_nftContractAddress][_tokenId].sold = 1;
    }
    //This is an internal function that transfer fund(ethers or other native token)
    //param: NFT contract address, token id, recipient address and amount to be transferred.
    //Check if transferring succeed. if not success, increase failedTransferCredits.
    function _payout(
        address _nftContractAddress,
        uint256 _tokenId,
        address _toAddress,
        uint128 _amount
    ) internal {
        // attempt to send the funds to the recipient
        (bool success, ) = payable(_toAddress).call{value: _amount, gas: 5000}("");

        // if someone tried to pull the trick of Dos, keep the fund
        if (!success) {
            failedTransferCredits += _amount;

            emit FailedPayout(
                _nftContractAddress,
                _tokenId,
                _toAddress,
                _amount
            );
        }
    }

    /**********************************/
    /*╔══════════════════════════════╗
      ║             END              ║
      ║  TRANSFER NFT & PAY SELLER   ║
      ╚══════════════════════════════╝*/
    /**********************************/

    /*╔══════════════════════════════╗
      ║      SETTLE & WITHDRAW       ║
      ╚══════════════════════════════╝*/

    //@notice: This is an external function that settle auction
    //@param: NFT contract address and token id.
    //@dev: This function can be executed when contract is not paused and there is not reentrance call. it requires that auction is ongoing, there is a bid made and token is not sold. Finally all conditions meet, call _mintNftAndTransferPayment
    function settleAuction(
        address _nftContractAddress,
        uint256 _tokenId
    ) external whenNotPaused nonReentrant {
        require(
            _isAuctionOngoing(_nftContractAddress, _tokenId) == 0,
            "Auction is not yet over"
        );
        require(
            _isABidMade(_nftContractAddress, _tokenId) == 1,
            "No highest bidder yet"
        );
        require(
            nftContractAuctions[_nftContractAddress][_tokenId].sold == 0,
            "Token already sold"
        );

        _mintNftAndTransferPayment(_nftContractAddress, _tokenId, 1);
        emit AuctionSettled(_nftContractAddress, _tokenId, msg.sender);
    }

    //@notice: This is an external function that withdraw auction.
    //@param: NFT contract address and token id.
    //@dev: Only contract ownner can call this function. This function can be executed when there is no reentrance call. it requires that token is not sold and there is no bid made.Finally reset main variables of auction data determinative to auction as zeros and false.
    function withdrawAuction(
        address _nftContractAddress,
        uint256 _tokenId
    ) external onlyOwner nonReentrant {
        require(
            nftContractAuctions[_nftContractAddress][_tokenId].sold == 0,
            "token has already sold"
        );
        require(
            nftContractAuctions[_nftContractAddress][_tokenId].nftHighestBid ==
                0,
            "Can not withdraw when a bid is made"
        );

        nftContractAuctions[_nftContractAddress][_tokenId].auctionEnd = 0;
        nftContractAuctions[_nftContractAddress][_tokenId].nftHighestBid = 0;
        nftContractAuctions[_nftContractAddress][_tokenId].nftHighestBidder = address(0);
        nftContractAuctions[_nftContractAddress][_tokenId].isOnAuction = false;
        nftContractAuctions[_nftContractAddress][_tokenId].bidsCount = 0;

        emit AuctionWithdrawn(_nftContractAddress, _tokenId, msg.sender);
    }

    /**********************************/
    /*╔══════════════════════════════╗
      ║             END              ║
      ║      SETTLE & WITHDRAW       ║
      ╚══════════════════════════════╝*/
    /**********************************/

    /*╔══════════════════════════════╗
      ║       UPDATE AUCTION         ║
      ╚══════════════════════════════╝*/
    /*
     * The NFT seller can opt to end an auction by taking the current highest bid.
     */
    //@notice: This is an external function that take highest bidder regardless of auction end time.
    //@param: NFT contract address and token id.
    //@dev: Only contract ownner can call this function. This function can be executed when contract is not paused and there is no reentrance call. it requires that token is not sold and there is a bid made.Finally call _mintNftAndTransferPaymen
    function takeHighestBid(
        address _nftContractAddress,
        uint256 _tokenId
    ) external onlyOwner whenNotPaused nonReentrant {
        require(
            _isABidMade(_nftContractAddress, _tokenId) == 1,
            "No highest bidder yet"
        );
        require(
            nftContractAuctions[_nftContractAddress][_tokenId].sold == 0,
            "Token already sold"
        );
        _mintNftAndTransferPayment(_nftContractAddress, _tokenId, 1);
        emit HighestBidTaken(_nftContractAddress, _tokenId);
    }

    /**********************************/
    /*╔══════════════════════════════╗
      ║             END              ║
      ║       UPDATE AUCTION         ║
      ╚══════════════════════════════╝*/
    /**********************************/

    function toBytes32(address addr) internal pure returns (bytes32) {
        return bytes32(uint256(uint160(addr)));
    }

    /*
     * Claim all the leftover fund to recepient and settle payment later
     */
    //@notice: This is an external function that Claim all fund which tansferring is failed to recepient
    //@param: address of fund receiver.
    //@dev: Only contract ownner can call this function. This function can be executed when there is no reentrance call. it requires that amount of failed fund is not equal with zero.
    function withdrawAllFailedCredits(address receiver) external onlyOwner nonReentrant {
        uint256 amount = failedTransferCredits;
        require(amount != 0, "no credits to withdraw");
        (bool success, ) = payable(receiver).call{value: amount, gas: 5000}("");
        if(success){
            failedTransferCredits = 0;
        }
    }

    //@notice: This is an external function that triger pause state of contract.
    //@dev: Only contract ownner can call this function. Call _pause() in the Pausable Cootract.
    function pause() external onlyOwner
    {
        _pause();
    }

    //@notice: This is an external function that triger uppause state of contract from pause state.
    //@dev: Only contract ownner can call this function. Call _unpause() in the Pausable Cootract.
    function unpause() external onlyOwner
    {
        _unpause();
    }
    //@notice: This is an external function that update the address of feeReceiver.
    //@param: address of feeReceiver to be updated
    //@dev: Only contract ownner can call this function. This function is executed when there is no reentrance calling. It requires feeReceiver address is valid.
    function updateFeeReceiver(address updatedFeeReceiver) external onlyOwner nonReentrant {
        require(updatedFeeReceiver != address(0), "Invalid address");
        feeReceiver = updatedFeeReceiver;

    }
    //@notice: This is an external function that renounce ownership.
    //@dev: Only contract ownner can call this function. 
    //@inheritdoc: Ownerable
    function renounceOwnership() public virtual override onlyOwner {
        revert("Can not renounce onwership");
    }
    // if there is emergency or when migrating to other shop contract, close current ongoing Auction.
    function _closeAuction(address _nftContractAddress,uint256 _tokenId) internal {

        address nftHighestBidder = nftContractAuctions[_nftContractAddress][_tokenId].nftHighestBidder;
        uint128 nftHighestBid = nftContractAuctions[_nftContractAddress][_tokenId].nftHighestBid;
        uint8 sold = nftContractAuctions[_nftContractAddress][_tokenId].sold;
        // refund to highest bidder when  
        if(nftHighestBidder != address(0) && sold == 0){
            if(nftHighestBid >0){
                _payout(
                    _nftContractAddress,
                    _tokenId,
                    nftHighestBidder,
                    nftHighestBid
                );
            }
        nftContractAuctions[_nftContractAddress][_tokenId].auctionEnd = 0;
        nftContractAuctions[_nftContractAddress][_tokenId].nftHighestBid = 0;
        nftContractAuctions[_nftContractAddress][_tokenId].nftHighestBidder = address(0);
        nftContractAuctions[_nftContractAddress][_tokenId].isOnAuction = false;
        nftContractAuctions[_nftContractAddress][_tokenId].bidsCount = 0;
        }
    }

    function closeAuction(address _nftContractAddress, uint256 tokenId) external onlyOwner nonReentrant whenPaused{
    _closeAuction(_nftContractAddress, tokenId);
    }

    function closeBatchAuctions(address _nftContractAddress, uint256 count) external onlyOwner nonReentrant whenPaused{
        for(uint256 i=1; i<= count; i++){
            _closeAuction(_nftContractAddress, i);
        }
    }

    /*
     * Update merkle root of allowlist
     */
    function updateMerkleRoot(uint256 _smallSaleId, bytes32 _allowRoot) external onlyOwner smallSaleExist(_smallSaleId) {
        smallSales[_smallSaleId].allowListRoot = _allowRoot;
        emit MerkleRootUpdated(_smallSaleId, _allowRoot);
    }
}